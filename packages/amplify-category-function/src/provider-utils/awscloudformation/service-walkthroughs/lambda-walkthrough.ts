import generalQuestionsWalkthrough from './generalQuestionsWalkthrough';
import autogeneratedParameters from './autogeneratedParameters';
import { runtimeWalkthrough, templateWalkthrough } from '../utils/functionPluginLoader';
import _ from 'lodash';
import { FunctionParameters } from 'amplify-function-plugin-interface';
import fs from 'fs-extra';
import inquirer from 'inquirer';
import path from 'path';
import { serviceName, categoryName, functionParametersFileName, parametersFileName } from '../utils/constants';
import { getNewCFNParameters, getNewCFNEnvVariables } from '../utils/cloudformationHelpers';
import { askExecRolePermissionsQuestions } from './execPermissionsWalkthrough';
import { scheduleWalkthrough } from './scheduleWalkthrough';
import { merge } from '../utils/funcParamsUtils';
import { topLevelCommentPrefix, topLevelCommentSuffix } from '../../../constants';

/**
 * Starting point for CLI walkthrough that generates a lambda function
 * @param context The Amplify Context object
 */
export async function createWalkthrough(
  context: any,
  templateParameters: Partial<FunctionParameters>,
): Promise<Partial<FunctionParameters>> {
  // merge in parameters that don't require any additional input
  templateParameters = merge(templateParameters, autogeneratedParameters(context));

  // ask generic function questions and merge in results
  templateParameters = merge(templateParameters, await generalQuestionsWalkthrough(context));

  // ask runtime selection questions and merge in results
  if (!templateParameters.runtime) {
    templateParameters = merge(templateParameters, await runtimeWalkthrough(context, templateParameters));
  }

  // ask template selection questions and merge in results
  templateParameters = merge(templateParameters, await templateWalkthrough(context, templateParameters));

  let topLevelComment;
  templateParameters.parametersFileObj = {};
  if (await context.amplify.confirmPrompt.run('Do you want to access other resources created in this project from your Lambda function?')) {
    let legacyParameters = {};
    ({ topLevelComment } = await askExecRolePermissionsQuestions(context, templateParameters, legacyParameters));
    templateParameters.parametersFileObj = legacyParameters;
  }
  templateParameters.topLevelComment = topLevelComment;

  // ask scheduling Lambda questions and merge in results
  templateParameters = merge(templateParameters, await scheduleWalkthrough(context, templateParameters));
  return templateParameters;
}

export async function updateWalkthrough(context, lambdaToUpdate) {
  const { allResources } = await context.amplify.getResourceStatus();
  const resources = allResources.filter(resource => resource.service === serviceName).map(resource => resource.resourceName);

  if (resources.length === 0) {
    context.print.error('No Lambda Functions resource to update. Please use "amplify add function" command to create a new Function');
    process.exit(0);
    return;
  }

  const resourceQuestion = [
    {
      name: 'resourceName',
      message: 'Please select the Lambda Function you would want to update',
      type: 'list',
      choices: resources,
    },
  ];

  const newParams = {};
  const answers: any = {};
  const currentDefaults: any = {};
  let dependsOn;

  const resourceAnswer = !lambdaToUpdate ? await inquirer.prompt(resourceQuestion) : { resourceName: lambdaToUpdate };
  answers.resourceName = resourceAnswer.resourceName;

  const projectBackendDirPath = context.amplify.pathManager.getBackendDirPath();
  const resourceDirPath = path.join(projectBackendDirPath, categoryName, resourceAnswer.resourceName);
  const parametersFilePath = path.join(resourceDirPath, functionParametersFileName);
  let currentParameters;
  try {
    currentParameters = context.amplify.readJsonFile(parametersFilePath);
  } catch (e) {
    currentParameters = {};
  }
  if (currentParameters.permissions) {
    currentDefaults.categories = Object.keys(currentParameters.permissions);
    currentDefaults.categoryPermissionMap = currentParameters.permissions;
  }

  if (
    await context.amplify.confirmPrompt.run(
      'Do you want to update permissions granted to this Lambda function to perform on other resources in your project?',
    )
  ) {
    // Get current dependsOn for the resource

    const amplifyMetaFilePath = context.amplify.pathManager.getAmplifyMetaFilePath();
    const amplifyMeta = context.amplify.readJsonFile(amplifyMetaFilePath);
    const resourceDependsOn = amplifyMeta.function[answers.resourceName].dependsOn || [];
    answers.dependsOn = resourceDependsOn;

    const { topLevelComment } = await askExecRolePermissionsQuestions(context, answers, newParams, currentDefaults);

    const cfnFileName = `${resourceAnswer.resourceName}-cloudformation-template.json`;
    const cfnFilePath = path.join(resourceDirPath, cfnFileName);
    const cfnContent = context.amplify.readJsonFile(cfnFilePath);
    const dependsOnParams = { env: { Type: 'String' } };

    Object.keys(answers.resourcePropertiesJSON)
      .filter(resourceProperty => 'Ref' in answers.resourcePropertiesJSON[resourceProperty])
      .forEach(resourceProperty => {
        dependsOnParams[answers.resourcePropertiesJSON[resourceProperty].Ref] = {
          Type: 'String',
          Default: answers.resourcePropertiesJSON[resourceProperty].Ref,
        };
      });

    cfnContent.Parameters = getNewCFNParameters(cfnContent.Parameters, currentParameters, dependsOnParams, newParams);

    Object.assign(answers.resourcePropertiesJSON, { ENV: { Ref: 'env' }, REGION: { Ref: 'AWS::Region' } });

    if (!cfnContent.Resources.AmplifyResourcesPolicy) {
      cfnContent.Resources.AmplifyResourcesPolicy = {
        DependsOn: ['LambdaExecutionRole'],
        Type: 'AWS::IAM::Policy',
        Properties: {
          PolicyName: 'amplify-lambda-execution-policy',
          Roles: [
            {
              Ref: 'LambdaExecutionRole',
            },
          ],
          PolicyDocument: {
            Version: '2012-10-17',
            Statement: [],
          },
        },
      };
    }

    if (answers.categoryPolicies.length === 0) {
      delete cfnContent.Resources.AmplifyResourcesPolicy;
    } else {
      cfnContent.Resources.AmplifyResourcesPolicy.Properties.PolicyDocument.Statement = answers.categoryPolicies;
    }

    cfnContent.Resources.LambdaFunction.Properties.Environment.Variables = getNewCFNEnvVariables(
      cfnContent.Resources.LambdaFunction.Properties.Environment.Variables,
      currentParameters,
      answers.resourcePropertiesJSON,
      newParams,
    ); // Need to update
    // Update top level comment in app.js or index.js file

    const updateTopLevelComment = filePath => {
      const commentRegex = new RegExp(
        `${_.escapeRegExp(topLevelCommentPrefix)}[a-zA-Z0-9\\-\\s._=]+${_.escapeRegExp(topLevelCommentSuffix)}`,
      );
      let fileContents = fs.readFileSync(filePath).toString();
      const commentMatches = fileContents.match(commentRegex);
      if (!commentMatches || commentMatches.length === 0) {
        fileContents = topLevelComment + fileContents;
      } else {
        fileContents = fileContents.replace(commentRegex, topLevelComment);
      }
      fs.writeFileSync(filePath, fileContents);
    };
    const appJSFilePath = path.join(resourceDirPath, 'src', 'app.js');
    const indexJSFilePath = path.join(resourceDirPath, 'src', 'index.js');
    if (fs.existsSync(appJSFilePath)) {
      updateTopLevelComment(appJSFilePath);
    } else if (fs.existsSync(indexJSFilePath)) {
      updateTopLevelComment(indexJSFilePath);
    }

    fs.writeFileSync(cfnFilePath, JSON.stringify(cfnContent, null, 4));
    answers.parameters = newParams;
    ({ dependsOn } = answers);
    if (!dependsOn) {
      dependsOn = [];
    }
  }
  // ask scheduling Lambda questions and merge in results
  const scheduleParametersFilePath = path.join(resourceDirPath, parametersFileName);
  let params;
  try {
    params = context.amplify.readJsonFile(scheduleParametersFilePath);
  } catch (e) {
    params = {};
  }
  let scheduleParameters: Partial<FunctionParameters> = params;
  scheduleParameters.cloudwatchRule = params.CloudWatchRule;
  scheduleParameters.resourceName = answers.resourceName;
  let scheduleParams = await scheduleWalkthrough(context, scheduleParameters);
  answers.parameters = newParams;
  answers.parameters.CloudWatchRule = scheduleParams.cloudwatchRule;
  return { answers, dependsOn };
}

export function migrate(context, projectPath, resourceName) {
  const resourceDirPath = path.join(projectPath, 'amplify', 'backend', categoryName, resourceName);
  const cfnFilePath = path.join(resourceDirPath, `${resourceName}-cloudformation-template.json`);
  const oldCfn = context.amplify.readJsonFile(cfnFilePath);
  const newCfn: any = {};
  Object.assign(newCfn, oldCfn);

  // Add env parameter
  if (!newCfn.Parameters) {
    newCfn.Parameters = {};
  }
  newCfn.Parameters.env = {
    Type: 'String',
  };

  // Add conditions block
  if (!newCfn.Conditions) {
    newCfn.Conditions = {};
  }
  newCfn.Conditions.ShouldNotCreateEnvResources = {
    'Fn::Equals': [
      {
        Ref: 'env',
      },
      'NONE',
    ],
  };

  // Add if condition for resource name change
  const oldFunctionName = newCfn.Resources.LambdaFunction.Properties.FunctionName;

  newCfn.Resources.LambdaFunction.Properties.FunctionName = {
    'Fn::If': [
      'ShouldNotCreateEnvResources',
      oldFunctionName,
      {
        'Fn::Join': [
          '',
          [
            oldFunctionName,
            '-',
            {
              Ref: 'env',
            },
          ],
        ],
      },
    ],
  };

  newCfn.Resources.LambdaFunction.Properties.Environment = { Variables: { ENV: { Ref: 'env' } } };

  const oldRoleName = newCfn.Resources.LambdaExecutionRole.Properties.RoleName;

  newCfn.Resources.LambdaExecutionRole.Properties.RoleName = {
    'Fn::If': [
      'ShouldNotCreateEnvResources',
      oldRoleName,
      {
        'Fn::Join': [
          '',
          [
            oldRoleName,
            '-',
            {
              Ref: 'env',
            },
          ],
        ],
      },
    ],
  };

  const jsonString = JSON.stringify(newCfn, null, '\t');
  fs.writeFileSync(cfnFilePath, jsonString, 'utf8');
}

module.exports = {
  createWalkthrough,
  updateWalkthrough,
  migrate,
};
