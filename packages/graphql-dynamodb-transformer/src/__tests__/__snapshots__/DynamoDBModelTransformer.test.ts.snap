// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`Current version transformer snapshot test 1`] = `
"type Post {
  id: ID!
  content: String
  createdAt: AWSDateTime!
  updatedAt: AWSDateTime!
}

enum ModelSortDirection {
  ASC
  DESC
}

type ModelPostConnection {
  items: [Post]!
  nextToken: String
}

input ModelStringInput {
  ne: String
  eq: String
  le: String
  lt: String
  ge: String
  gt: String
  contains: String
  notContains: String
  between: [String]
  beginsWith: String
  attributeExists: Boolean
  attributeType: ModelAttributeTypes
  size: ModelSizeInput
}

input ModelIDInput {
  ne: ID
  eq: ID
  le: ID
  lt: ID
  ge: ID
  gt: ID
  contains: ID
  notContains: ID
  between: [ID]
  beginsWith: ID
  attributeExists: Boolean
  attributeType: ModelAttributeTypes
  size: ModelSizeInput
}

input ModelIntInput {
  ne: Int
  eq: Int
  le: Int
  lt: Int
  ge: Int
  gt: Int
  between: [Int]
  attributeExists: Boolean
  attributeType: ModelAttributeTypes
}

input ModelFloatInput {
  ne: Float
  eq: Float
  le: Float
  lt: Float
  ge: Float
  gt: Float
  between: [Float]
  attributeExists: Boolean
  attributeType: ModelAttributeTypes
}

input ModelBooleanInput {
  ne: Boolean
  eq: Boolean
  attributeExists: Boolean
  attributeType: ModelAttributeTypes
}

input ModelSizeInput {
  ne: Int
  eq: Int
  le: Int
  lt: Int
  ge: Int
  gt: Int
  between: [Int]
}

input ModelPostFilterInput {
  id: ModelIDInput
  content: ModelStringInput
  and: [ModelPostFilterInput]
  or: [ModelPostFilterInput]
  not: ModelPostFilterInput
}

enum ModelAttributeTypes {
  binary
  binarySet
  bool
  list
  map
  number
  numberSet
  string
  stringSet
  _null
}

type Query {
  getPost(id: ID!): Post
  listPosts(filter: ModelPostFilterInput, limit: Int, nextToken: String): ModelPostConnection
}

input CreatePostInput {
  id: ID
  content: String
}

input UpdatePostInput {
  id: ID!
  content: String
}

input DeletePostInput {
  id: ID!
}

type Mutation {
  createPost(input: CreatePostInput!, condition: ModelPostConditionInput): Post
  updatePost(input: UpdatePostInput!, condition: ModelPostConditionInput): Post
  deletePost(input: DeletePostInput!, condition: ModelPostConditionInput): Post
}

input ModelPostConditionInput {
  content: ModelStringInput
  and: [ModelPostConditionInput]
  or: [ModelPostConditionInput]
  not: ModelPostConditionInput
}

type Subscription {
  onCreatePost: Post @aws_subscribe(mutations: [\\"createPost\\"])
  onUpdatePost: Post @aws_subscribe(mutations: [\\"updatePost\\"])
  onDeletePost: Post @aws_subscribe(mutations: [\\"deletePost\\"])
}
"
`;

exports[`DynamoDB transformer should not add default primary key when ID is defined 1`] = `
"## [Start] Set default values. **
#set( $createdAt = $util.time.nowISO8601() )
## Automatically set the createdAt timestamp. **
$util.qr($context.args.input.put(\\"createdAt\\", $util.defaultIfNull($ctx.args.input.createdAt, $createdAt)))
## Automatically set the updatedAt timestamp. **
$util.qr($context.args.input.put(\\"updatedAt\\", $util.defaultIfNull($ctx.args.input.updatedAt, $createdAt)))
## [End] Set default values. **
## [Start] Prepare DynamoDB PutItem Request. **
$util.qr($context.args.input.put(\\"__typename\\", \\"Post\\"))
#if( $modelObjectKey )
  #set( $condition = {
  \\"expression\\": \\"\\",
  \\"expressionNames\\": {},
  \\"expressionValues\\": {}
} )
  #foreach( $entry in $modelObjectKey.entrySet() )
    #if( $velocityCount == 1 )
      $util.qr($condition.put(\\"expression\\", \\"attribute_not_exists(#keyCondition$velocityCount)\\"))
    #else
      $util.qr($condition.put(\\"expression\\", \\"$condition.expression AND attribute_not_exists(#keyCondition$velocityCount)\\"))
    #end
    $util.qr($condition.expressionNames.put(\\"#keyCondition$velocityCount\\", \\"$entry.key\\"))
  #end
#else
  #set( $condition = {
  \\"expression\\": \\"attribute_not_exists(#id)\\",
  \\"expressionNames\\": {
      \\"#id\\": \\"id\\"
  },
  \\"expressionValues\\": {}
} )
#end
#if( $context.args.condition )
  #set( $condition.expressionValues = {} )
  #set( $conditionFilterExpressions = $util.parseJson($util.transform.toDynamoDBConditionExpression($context.args.condition)) )
  $util.qr($condition.put(\\"expression\\", \\"($condition.expression) AND $conditionFilterExpressions.expression\\"))
  $util.qr($condition.expressionNames.putAll($conditionFilterExpressions.expressionNames))
  $util.qr($condition.expressionValues.putAll($conditionFilterExpressions.expressionValues))
#end
#if( $condition.expressionValues && $condition.expressionValues.size() == 0 )
  #set( $condition = {
  \\"expression\\": $condition.expression,
  \\"expressionNames\\": $condition.expressionNames
} )
#end
{
  \\"version\\": \\"2018-05-29\\",
  \\"operation\\": \\"PutItem\\",
  \\"key\\": #if( $modelObjectKey ) $util.toJson($modelObjectKey) #else {
  \\"id\\":   $util.dynamodb.toDynamoDBJson($ctx.args.input.id)
} #end,
  \\"attributeValues\\": $util.dynamodb.toMapValuesJson($context.args.input),
  \\"condition\\": $util.toJson($condition)
}
## [End] Prepare DynamoDB PutItem Request. **"
`;

exports[`Test create and update mutation input should have timestamps as nullable fields when the type makes it non-nullable 1`] = `
"type Post {
  id: ID!
  str: String
  createdAt: AWSDateTime!
  updatedAt: AWSDateTime!
}

enum ModelSortDirection {
  ASC
  DESC
}

type ModelPostConnection {
  items: [Post]!
  nextToken: String
}

input ModelStringFilterInput {
  ne: String
  eq: String
  le: String
  lt: String
  ge: String
  gt: String
  contains: String
  notContains: String
  between: [String]
  beginsWith: String
}

input ModelIDFilterInput {
  ne: ID
  eq: ID
  le: ID
  lt: ID
  ge: ID
  gt: ID
  contains: ID
  notContains: ID
  between: [ID]
  beginsWith: ID
}

input ModelIntFilterInput {
  ne: Int
  eq: Int
  le: Int
  lt: Int
  ge: Int
  gt: Int
  between: [Int]
}

input ModelFloatFilterInput {
  ne: Float
  eq: Float
  le: Float
  lt: Float
  ge: Float
  gt: Float
  between: [Float]
}

input ModelBooleanFilterInput {
  ne: Boolean
  eq: Boolean
}

input ModelPostFilterInput {
  id: ModelIDFilterInput
  str: ModelStringFilterInput
  createdAt: ModelStringFilterInput
  updatedAt: ModelStringFilterInput
  and: [ModelPostFilterInput]
  or: [ModelPostFilterInput]
  not: ModelPostFilterInput
}

type Query {
  getPost(id: ID!): Post
  listPosts(filter: ModelPostFilterInput, limit: Int, nextToken: String): ModelPostConnection
}

input CreatePostInput {
  id: ID
  str: String
  createdAt: AWSDateTime
  updatedAt: AWSDateTime
}

input UpdatePostInput {
  id: ID!
  str: String
  createdAt: AWSDateTime
  updatedAt: AWSDateTime
}

input DeletePostInput {
  id: ID!
}

type Mutation {
  createPost(input: CreatePostInput!): Post
  updatePost(input: UpdatePostInput!): Post
  deletePost(input: DeletePostInput!): Post
}

type Subscription {
  onCreatePost: Post @aws_subscribe(mutations: [\\"createPost\\"])
  onUpdatePost: Post @aws_subscribe(mutations: [\\"updatePost\\"])
  onDeletePost: Post @aws_subscribe(mutations: [\\"deletePost\\"])
}
"
`;

exports[`Test create and update mutation input should have timestamps as nullable fields when the type makes it non-nullable 2`] = `
"## [Start] Set default values. **
$util.qr($context.args.input.put(\\"id\\", $util.defaultIfNull($ctx.args.input.id, $util.autoId())))
#set( $createdAt = $util.time.nowISO8601() )
## Automatically set the createdAt timestamp. **
$util.qr($context.args.input.put(\\"createdAt\\", $util.defaultIfNull($ctx.args.input.createdAt, $createdAt)))
## Automatically set the updatedAt timestamp. **
$util.qr($context.args.input.put(\\"updatedAt\\", $util.defaultIfNull($ctx.args.input.updatedAt, $createdAt)))
## [End] Set default values. **
## [Start] Prepare DynamoDB PutItem Request. **
$util.qr($context.args.input.put(\\"__typename\\", \\"Post\\"))
#if( $modelObjectKey )
  #set( $condition = {
  \\"expression\\": \\"\\",
  \\"expressionNames\\": {},
  \\"expressionValues\\": {}
} )
  #foreach( $entry in $modelObjectKey.entrySet() )
    #if( $velocityCount == 1 )
      $util.qr($condition.put(\\"expression\\", \\"attribute_not_exists(#keyCondition$velocityCount)\\"))
    #else
      $util.qr($condition.put(\\"expression\\", \\"$condition.expression AND attribute_not_exists(#keyCondition$velocityCount)\\"))
    #end
    $util.qr($condition.expressionNames.put(\\"#keyCondition$velocityCount\\", \\"$entry.key\\"))
  #end
#else
  #set( $condition = {
  \\"expression\\": \\"attribute_not_exists(#id)\\",
  \\"expressionNames\\": {
      \\"#id\\": \\"id\\"
  },
  \\"expressionValues\\": {}
} )
#end
#if( $context.args.condition )
  #set( $condition.expressionValues = {} )
  #set( $conditionFilterExpressions = $util.parseJson($util.transform.toDynamoDBConditionExpression($context.args.condition)) )
  $util.qr($condition.put(\\"expression\\", \\"($condition.expression) AND $conditionFilterExpressions.expression\\"))
  $util.qr($condition.expressionNames.putAll($conditionFilterExpressions.expressionNames))
  $util.qr($condition.expressionValues.putAll($conditionFilterExpressions.expressionValues))
#end
#if( $condition.expressionValues && $condition.expressionValues.size() == 0 )
  #set( $condition = {
  \\"expression\\": $condition.expression,
  \\"expressionNames\\": $condition.expressionNames
} )
#end
{
  \\"version\\": \\"2018-05-29\\",
  \\"operation\\": \\"PutItem\\",
  \\"key\\": #if( $modelObjectKey ) $util.toJson($modelObjectKey) #else {
  \\"id\\":   $util.dynamodb.toDynamoDBJson($ctx.args.input.id)
} #end,
  \\"attributeValues\\": $util.dynamodb.toMapValuesJson($context.args.input),
  \\"condition\\": $util.toJson($condition)
}
## [End] Prepare DynamoDB PutItem Request. **"
`;

exports[`Test create and update mutation input should have timestamps as nullable fields when the type makes it non-nullable 3`] = `
"#set( $optionalNonNullableFields = [\\"createdAt\\", \\"updatedAt\\"] )
#foreach( $field in $optionalNonNullableFields )
  #if( $context.arguments.input.keySet().contains($field) && $util.isNull($context.args.input.get($field)) )
$util.error(\\"An argument you marked as Non-Null is set to Null in the query or the body of your request.\\")
  #end
#end
#if( $authCondition && $authCondition.expression != \\"\\" )
  #set( $condition = $authCondition )
  #if( $modelObjectKey )
    #foreach( $entry in $modelObjectKey.entrySet() )
      $util.qr($condition.put(\\"expression\\", \\"$condition.expression AND attribute_exists(#keyCondition$velocityCount)\\"))
      $util.qr($condition.expressionNames.put(\\"#keyCondition$velocityCount\\", \\"$entry.key\\"))
    #end
  #else
    $util.qr($condition.put(\\"expression\\", \\"$condition.expression AND attribute_exists(#id)\\"))
    $util.qr($condition.expressionNames.put(\\"#id\\", \\"id\\"))
  #end
#else
  #if( $modelObjectKey )
    #set( $condition = {
  \\"expression\\": \\"\\",
  \\"expressionNames\\": {},
  \\"expressionValues\\": {}
} )
    #foreach( $entry in $modelObjectKey.entrySet() )
      #if( $velocityCount == 1 )
        $util.qr($condition.put(\\"expression\\", \\"attribute_exists(#keyCondition$velocityCount)\\"))
      #else
        $util.qr($condition.put(\\"expression\\", \\"$condition.expression AND attribute_exists(#keyCondition$velocityCount)\\"))
      #end
      $util.qr($condition.expressionNames.put(\\"#keyCondition$velocityCount\\", \\"$entry.key\\"))
    #end
  #else
    #set( $condition = {
  \\"expression\\": \\"attribute_exists(#id)\\",
  \\"expressionNames\\": {
      \\"#id\\": \\"id\\"
  },
  \\"expressionValues\\": {}
} )
  #end
#end
## Automatically set the updatedAt timestamp. **
$util.qr($context.args.input.put(\\"updatedAt\\", $util.defaultIfNull($ctx.args.input.updatedAt, $util.time.nowISO8601())))
$util.qr($context.args.input.put(\\"__typename\\", \\"Post\\"))
## Update condition if type is @versioned **
#if( $versionedCondition )
  $util.qr($condition.put(\\"expression\\", \\"($condition.expression) AND $versionedCondition.expression\\"))
  $util.qr($condition.expressionNames.putAll($versionedCondition.expressionNames))
  $util.qr($condition.expressionValues.putAll($versionedCondition.expressionValues))
#end
#if( $context.args.condition )
  #set( $conditionFilterExpressions = $util.parseJson($util.transform.toDynamoDBConditionExpression($context.args.condition)) )
  $util.qr($condition.put(\\"expression\\", \\"($condition.expression) AND $conditionFilterExpressions.expression\\"))
  $util.qr($condition.expressionNames.putAll($conditionFilterExpressions.expressionNames))
  $util.qr($condition.expressionValues.putAll($conditionFilterExpressions.expressionValues))
#end
#if( $condition.expressionValues && $condition.expressionValues.size() == 0 )
  #set( $condition = {
  \\"expression\\": $condition.expression,
  \\"expressionNames\\": $condition.expressionNames
} )
#end
#set( $expNames = {} )
#set( $expValues = {} )
#set( $expSet = {} )
#set( $expAdd = {} )
#set( $expRemove = [] )
#if( $modelObjectKey )
  #set( $keyFields = [] )
  #foreach( $entry in $modelObjectKey.entrySet() )
    $util.qr($keyFields.add(\\"$entry.key\\"))
  #end
#else
  #set( $keyFields = [\\"id\\"] )
#end
#foreach( $entry in $util.map.copyAndRemoveAllKeys($context.args.input, $keyFields).entrySet() )
  #if( !$util.isNull($dynamodbNameOverrideMap) && $dynamodbNameOverrideMap.containsKey(\\"$entry.key\\") )
    #set( $entryKeyAttributeName = $dynamodbNameOverrideMap.get(\\"$entry.key\\") )
  #else
    #set( $entryKeyAttributeName = $entry.key )
  #end
  #if( $util.isNull($entry.value) )
    #set( $discard = $expRemove.add(\\"#$entryKeyAttributeName\\") )
    $util.qr($expNames.put(\\"#$entryKeyAttributeName\\", \\"$entry.key\\"))
  #else
    $util.qr($expSet.put(\\"#$entryKeyAttributeName\\", \\":$entryKeyAttributeName\\"))
    $util.qr($expNames.put(\\"#$entryKeyAttributeName\\", \\"$entry.key\\"))
    $util.qr($expValues.put(\\":$entryKeyAttributeName\\", $util.dynamodb.toDynamoDB($entry.value)))
  #end
#end
#set( $expression = \\"\\" )
#if( !$expSet.isEmpty() )
  #set( $expression = \\"SET\\" )
  #foreach( $entry in $expSet.entrySet() )
    #set( $expression = \\"$expression $entry.key = $entry.value\\" )
    #if( $foreach.hasNext() )
      #set( $expression = \\"$expression,\\" )
    #end
  #end
#end
#if( !$expAdd.isEmpty() )
  #set( $expression = \\"$expression ADD\\" )
  #foreach( $entry in $expAdd.entrySet() )
    #set( $expression = \\"$expression $entry.key $entry.value\\" )
    #if( $foreach.hasNext() )
      #set( $expression = \\"$expression,\\" )
    #end
  #end
#end
#if( !$expRemove.isEmpty() )
  #set( $expression = \\"$expression REMOVE\\" )
  #foreach( $entry in $expRemove )
    #set( $expression = \\"$expression $entry\\" )
    #if( $foreach.hasNext() )
      #set( $expression = \\"$expression,\\" )
    #end
  #end
#end
#set( $update = {} )
$util.qr($update.put(\\"expression\\", \\"$expression\\"))
#if( !$expNames.isEmpty() )
  $util.qr($update.put(\\"expressionNames\\", $expNames))
#end
#if( !$expValues.isEmpty() )
  $util.qr($update.put(\\"expressionValues\\", $expValues))
#end
{
  \\"version\\": \\"2018-05-29\\",
  \\"operation\\": \\"UpdateItem\\",
  \\"key\\": #if( $modelObjectKey ) $util.toJson($modelObjectKey) #else {
  \\"id\\": {
      \\"S\\": $util.toJson($context.args.input.id)
  }
} #end,
  \\"update\\": $util.toJson($update),
  \\"condition\\": $util.toJson($condition)
}"
`;

exports[`Test not to include createdAt and updatedAt field when timestamps is set to null 1`] = `
"type Post {
  id: ID!
  str: String
}

enum ModelSortDirection {
  ASC
  DESC
}

type ModelPostConnection {
  items: [Post]!
  nextToken: String
}

input ModelStringFilterInput {
  ne: String
  eq: String
  le: String
  lt: String
  ge: String
  gt: String
  contains: String
  notContains: String
  between: [String]
  beginsWith: String
}

input ModelIDFilterInput {
  ne: ID
  eq: ID
  le: ID
  lt: ID
  ge: ID
  gt: ID
  contains: ID
  notContains: ID
  between: [ID]
  beginsWith: ID
}

input ModelIntFilterInput {
  ne: Int
  eq: Int
  le: Int
  lt: Int
  ge: Int
  gt: Int
  between: [Int]
}

input ModelFloatFilterInput {
  ne: Float
  eq: Float
  le: Float
  lt: Float
  ge: Float
  gt: Float
  between: [Float]
}

input ModelBooleanFilterInput {
  ne: Boolean
  eq: Boolean
}

input ModelPostFilterInput {
  id: ModelIDFilterInput
  str: ModelStringFilterInput
  and: [ModelPostFilterInput]
  or: [ModelPostFilterInput]
  not: ModelPostFilterInput
}

type Query {
  getPost(id: ID!): Post
  listPosts(filter: ModelPostFilterInput, limit: Int, nextToken: String): ModelPostConnection
}

input CreatePostInput {
  id: ID
  str: String
}

input UpdatePostInput {
  id: ID!
  str: String
}

input DeletePostInput {
  id: ID!
}

type Mutation {
  createPost(input: CreatePostInput!): Post
  updatePost(input: UpdatePostInput!): Post
  deletePost(input: DeletePostInput!): Post
}

type Subscription {
  onCreatePost: Post @aws_subscribe(mutations: [\\"createPost\\"])
  onUpdatePost: Post @aws_subscribe(mutations: [\\"updatePost\\"])
  onDeletePost: Post @aws_subscribe(mutations: [\\"deletePost\\"])
}
"
`;

exports[`Test not to include createdAt and updatedAt field when timestamps is set to null 2`] = `
"## [Start] Set default values. **
$util.qr($context.args.input.put(\\"id\\", $util.defaultIfNull($ctx.args.input.id, $util.autoId())))
## [End] Set default values. **
## [Start] Prepare DynamoDB PutItem Request. **
$util.qr($context.args.input.put(\\"__typename\\", \\"Post\\"))
#if( $modelObjectKey )
  #set( $condition = {
  \\"expression\\": \\"\\",
  \\"expressionNames\\": {},
  \\"expressionValues\\": {}
} )
  #foreach( $entry in $modelObjectKey.entrySet() )
    #if( $velocityCount == 1 )
      $util.qr($condition.put(\\"expression\\", \\"attribute_not_exists(#keyCondition$velocityCount)\\"))
    #else
      $util.qr($condition.put(\\"expression\\", \\"$condition.expression AND attribute_not_exists(#keyCondition$velocityCount)\\"))
    #end
    $util.qr($condition.expressionNames.put(\\"#keyCondition$velocityCount\\", \\"$entry.key\\"))
  #end
#else
  #set( $condition = {
  \\"expression\\": \\"attribute_not_exists(#id)\\",
  \\"expressionNames\\": {
      \\"#id\\": \\"id\\"
  },
  \\"expressionValues\\": {}
} )
#end
#if( $context.args.condition )
  #set( $condition.expressionValues = {} )
  #set( $conditionFilterExpressions = $util.parseJson($util.transform.toDynamoDBConditionExpression($context.args.condition)) )
  $util.qr($condition.put(\\"expression\\", \\"($condition.expression) AND $conditionFilterExpressions.expression\\"))
  $util.qr($condition.expressionNames.putAll($conditionFilterExpressions.expressionNames))
  $util.qr($condition.expressionValues.putAll($conditionFilterExpressions.expressionValues))
#end
#if( $condition.expressionValues && $condition.expressionValues.size() == 0 )
  #set( $condition = {
  \\"expression\\": $condition.expression,
  \\"expressionNames\\": $condition.expressionNames
} )
#end
{
  \\"version\\": \\"2018-05-29\\",
  \\"operation\\": \\"PutItem\\",
  \\"key\\": #if( $modelObjectKey ) $util.toJson($modelObjectKey) #else {
  \\"id\\":   $util.dynamodb.toDynamoDBJson($ctx.args.input.id)
} #end,
  \\"attributeValues\\": $util.dynamodb.toMapValuesJson($context.args.input),
  \\"condition\\": $util.toJson($condition)
}
## [End] Prepare DynamoDB PutItem Request. **"
`;

exports[`Test not to include createdAt and updatedAt field when timestamps is set to null 3`] = `
"#set( $optionalNonNullableFields = [] )
#foreach( $field in $optionalNonNullableFields )
  #if( $context.arguments.input.keySet().contains($field) && $util.isNull($context.args.input.get($field)) )
$util.error(\\"An argument you marked as Non-Null is set to Null in the query or the body of your request.\\")
  #end
#end
#if( $authCondition && $authCondition.expression != \\"\\" )
  #set( $condition = $authCondition )
  #if( $modelObjectKey )
    #foreach( $entry in $modelObjectKey.entrySet() )
      $util.qr($condition.put(\\"expression\\", \\"$condition.expression AND attribute_exists(#keyCondition$velocityCount)\\"))
      $util.qr($condition.expressionNames.put(\\"#keyCondition$velocityCount\\", \\"$entry.key\\"))
    #end
  #else
    $util.qr($condition.put(\\"expression\\", \\"$condition.expression AND attribute_exists(#id)\\"))
    $util.qr($condition.expressionNames.put(\\"#id\\", \\"id\\"))
  #end
#else
  #if( $modelObjectKey )
    #set( $condition = {
  \\"expression\\": \\"\\",
  \\"expressionNames\\": {},
  \\"expressionValues\\": {}
} )
    #foreach( $entry in $modelObjectKey.entrySet() )
      #if( $velocityCount == 1 )
        $util.qr($condition.put(\\"expression\\", \\"attribute_exists(#keyCondition$velocityCount)\\"))
      #else
        $util.qr($condition.put(\\"expression\\", \\"$condition.expression AND attribute_exists(#keyCondition$velocityCount)\\"))
      #end
      $util.qr($condition.expressionNames.put(\\"#keyCondition$velocityCount\\", \\"$entry.key\\"))
    #end
  #else
    #set( $condition = {
  \\"expression\\": \\"attribute_exists(#id)\\",
  \\"expressionNames\\": {
      \\"#id\\": \\"id\\"
  },
  \\"expressionValues\\": {}
} )
  #end
#end
$util.qr($context.args.input.put(\\"__typename\\", \\"Post\\"))
## Update condition if type is @versioned **
#if( $versionedCondition )
  $util.qr($condition.put(\\"expression\\", \\"($condition.expression) AND $versionedCondition.expression\\"))
  $util.qr($condition.expressionNames.putAll($versionedCondition.expressionNames))
  $util.qr($condition.expressionValues.putAll($versionedCondition.expressionValues))
#end
#if( $context.args.condition )
  #set( $conditionFilterExpressions = $util.parseJson($util.transform.toDynamoDBConditionExpression($context.args.condition)) )
  $util.qr($condition.put(\\"expression\\", \\"($condition.expression) AND $conditionFilterExpressions.expression\\"))
  $util.qr($condition.expressionNames.putAll($conditionFilterExpressions.expressionNames))
  $util.qr($condition.expressionValues.putAll($conditionFilterExpressions.expressionValues))
#end
#if( $condition.expressionValues && $condition.expressionValues.size() == 0 )
  #set( $condition = {
  \\"expression\\": $condition.expression,
  \\"expressionNames\\": $condition.expressionNames
} )
#end
#set( $expNames = {} )
#set( $expValues = {} )
#set( $expSet = {} )
#set( $expAdd = {} )
#set( $expRemove = [] )
#if( $modelObjectKey )
  #set( $keyFields = [] )
  #foreach( $entry in $modelObjectKey.entrySet() )
    $util.qr($keyFields.add(\\"$entry.key\\"))
  #end
#else
  #set( $keyFields = [\\"id\\"] )
#end
#foreach( $entry in $util.map.copyAndRemoveAllKeys($context.args.input, $keyFields).entrySet() )
  #if( !$util.isNull($dynamodbNameOverrideMap) && $dynamodbNameOverrideMap.containsKey(\\"$entry.key\\") )
    #set( $entryKeyAttributeName = $dynamodbNameOverrideMap.get(\\"$entry.key\\") )
  #else
    #set( $entryKeyAttributeName = $entry.key )
  #end
  #if( $util.isNull($entry.value) )
    #set( $discard = $expRemove.add(\\"#$entryKeyAttributeName\\") )
    $util.qr($expNames.put(\\"#$entryKeyAttributeName\\", \\"$entry.key\\"))
  #else
    $util.qr($expSet.put(\\"#$entryKeyAttributeName\\", \\":$entryKeyAttributeName\\"))
    $util.qr($expNames.put(\\"#$entryKeyAttributeName\\", \\"$entry.key\\"))
    $util.qr($expValues.put(\\":$entryKeyAttributeName\\", $util.dynamodb.toDynamoDB($entry.value)))
  #end
#end
#set( $expression = \\"\\" )
#if( !$expSet.isEmpty() )
  #set( $expression = \\"SET\\" )
  #foreach( $entry in $expSet.entrySet() )
    #set( $expression = \\"$expression $entry.key = $entry.value\\" )
    #if( $foreach.hasNext() )
      #set( $expression = \\"$expression,\\" )
    #end
  #end
#end
#if( !$expAdd.isEmpty() )
  #set( $expression = \\"$expression ADD\\" )
  #foreach( $entry in $expAdd.entrySet() )
    #set( $expression = \\"$expression $entry.key $entry.value\\" )
    #if( $foreach.hasNext() )
      #set( $expression = \\"$expression,\\" )
    #end
  #end
#end
#if( !$expRemove.isEmpty() )
  #set( $expression = \\"$expression REMOVE\\" )
  #foreach( $entry in $expRemove )
    #set( $expression = \\"$expression $entry\\" )
    #if( $foreach.hasNext() )
      #set( $expression = \\"$expression,\\" )
    #end
  #end
#end
#set( $update = {} )
$util.qr($update.put(\\"expression\\", \\"$expression\\"))
#if( !$expNames.isEmpty() )
  $util.qr($update.put(\\"expressionNames\\", $expNames))
#end
#if( !$expValues.isEmpty() )
  $util.qr($update.put(\\"expressionValues\\", $expValues))
#end
{
  \\"version\\": \\"2018-05-29\\",
  \\"operation\\": \\"UpdateItem\\",
  \\"key\\": #if( $modelObjectKey ) $util.toJson($modelObjectKey) #else {
  \\"id\\": {
      \\"S\\": $util.toJson($context.args.input.id)
  }
} #end,
  \\"update\\": $util.toJson($update),
  \\"condition\\": $util.toJson($condition)
}"
`;

exports[`Test only get does not generate superfluous input and filter types 1`] = `
"type Entity {
  id: ID!
  str: String
  createdAt: AWSDateTime!
  updatedAt: AWSDateTime!
}

type Query {
  getEntity(id: ID!): Entity
}
"
`;

exports[`Test resolver template not to auto generate createdAt and updatedAt when the type in schema is not AWSDateTime 1`] = `
"type Post {
  id: ID!
  str: String
  createdAt: AWSTimestamp
  updatedAt: AWSTimestamp
}

enum ModelSortDirection {
  ASC
  DESC
}

type ModelPostConnection {
  items: [Post]!
  nextToken: String
}

input ModelStringFilterInput {
  ne: String
  eq: String
  le: String
  lt: String
  ge: String
  gt: String
  contains: String
  notContains: String
  between: [String]
  beginsWith: String
}

input ModelIDFilterInput {
  ne: ID
  eq: ID
  le: ID
  lt: ID
  ge: ID
  gt: ID
  contains: ID
  notContains: ID
  between: [ID]
  beginsWith: ID
}

input ModelIntFilterInput {
  ne: Int
  eq: Int
  le: Int
  lt: Int
  ge: Int
  gt: Int
  between: [Int]
}

input ModelFloatFilterInput {
  ne: Float
  eq: Float
  le: Float
  lt: Float
  ge: Float
  gt: Float
  between: [Float]
}

input ModelBooleanFilterInput {
  ne: Boolean
  eq: Boolean
}

input ModelPostFilterInput {
  id: ModelIDFilterInput
  str: ModelStringFilterInput
  createdAt: ModelIntFilterInput
  updatedAt: ModelIntFilterInput
  and: [ModelPostFilterInput]
  or: [ModelPostFilterInput]
  not: ModelPostFilterInput
}

type Query {
  getPost(id: ID!): Post
  listPosts(filter: ModelPostFilterInput, limit: Int, nextToken: String): ModelPostConnection
}

input CreatePostInput {
  id: ID
  str: String
  createdAt: AWSTimestamp
  updatedAt: AWSTimestamp
}

input UpdatePostInput {
  id: ID!
  str: String
  createdAt: AWSTimestamp
  updatedAt: AWSTimestamp
}

input DeletePostInput {
  id: ID!
}

type Mutation {
  createPost(input: CreatePostInput!): Post
  updatePost(input: UpdatePostInput!): Post
  deletePost(input: DeletePostInput!): Post
}

type Subscription {
  onCreatePost: Post @aws_subscribe(mutations: [\\"createPost\\"])
  onUpdatePost: Post @aws_subscribe(mutations: [\\"updatePost\\"])
  onDeletePost: Post @aws_subscribe(mutations: [\\"deletePost\\"])
}
"
`;

exports[`Test resolver template not to auto generate createdAt and updatedAt when the type in schema is not AWSDateTime 2`] = `
"## [Start] Set default values. **
$util.qr($context.args.input.put(\\"id\\", $util.defaultIfNull($ctx.args.input.id, $util.autoId())))
## [End] Set default values. **
## [Start] Prepare DynamoDB PutItem Request. **
$util.qr($context.args.input.put(\\"__typename\\", \\"Post\\"))
#if( $modelObjectKey )
  #set( $condition = {
  \\"expression\\": \\"\\",
  \\"expressionNames\\": {},
  \\"expressionValues\\": {}
} )
  #foreach( $entry in $modelObjectKey.entrySet() )
    #if( $velocityCount == 1 )
      $util.qr($condition.put(\\"expression\\", \\"attribute_not_exists(#keyCondition$velocityCount)\\"))
    #else
      $util.qr($condition.put(\\"expression\\", \\"$condition.expression AND attribute_not_exists(#keyCondition$velocityCount)\\"))
    #end
    $util.qr($condition.expressionNames.put(\\"#keyCondition$velocityCount\\", \\"$entry.key\\"))
  #end
#else
  #set( $condition = {
  \\"expression\\": \\"attribute_not_exists(#id)\\",
  \\"expressionNames\\": {
      \\"#id\\": \\"id\\"
  },
  \\"expressionValues\\": {}
} )
#end
#if( $context.args.condition )
  #set( $condition.expressionValues = {} )
  #set( $conditionFilterExpressions = $util.parseJson($util.transform.toDynamoDBConditionExpression($context.args.condition)) )
  $util.qr($condition.put(\\"expression\\", \\"($condition.expression) AND $conditionFilterExpressions.expression\\"))
  $util.qr($condition.expressionNames.putAll($conditionFilterExpressions.expressionNames))
  $util.qr($condition.expressionValues.putAll($conditionFilterExpressions.expressionValues))
#end
#if( $condition.expressionValues && $condition.expressionValues.size() == 0 )
  #set( $condition = {
  \\"expression\\": $condition.expression,
  \\"expressionNames\\": $condition.expressionNames
} )
#end
{
  \\"version\\": \\"2018-05-29\\",
  \\"operation\\": \\"PutItem\\",
  \\"key\\": #if( $modelObjectKey ) $util.toJson($modelObjectKey) #else {
  \\"id\\":   $util.dynamodb.toDynamoDBJson($ctx.args.input.id)
} #end,
  \\"attributeValues\\": $util.dynamodb.toMapValuesJson($context.args.input),
  \\"condition\\": $util.toJson($condition)
}
## [End] Prepare DynamoDB PutItem Request. **"
`;

exports[`Test resolver template not to auto generate createdAt and updatedAt when the type in schema is not AWSDateTime 3`] = `
"#set( $optionalNonNullableFields = [] )
#foreach( $field in $optionalNonNullableFields )
  #if( $context.arguments.input.keySet().contains($field) && $util.isNull($context.args.input.get($field)) )
$util.error(\\"An argument you marked as Non-Null is set to Null in the query or the body of your request.\\")
  #end
#end
#if( $authCondition && $authCondition.expression != \\"\\" )
  #set( $condition = $authCondition )
  #if( $modelObjectKey )
    #foreach( $entry in $modelObjectKey.entrySet() )
      $util.qr($condition.put(\\"expression\\", \\"$condition.expression AND attribute_exists(#keyCondition$velocityCount)\\"))
      $util.qr($condition.expressionNames.put(\\"#keyCondition$velocityCount\\", \\"$entry.key\\"))
    #end
  #else
    $util.qr($condition.put(\\"expression\\", \\"$condition.expression AND attribute_exists(#id)\\"))
    $util.qr($condition.expressionNames.put(\\"#id\\", \\"id\\"))
  #end
#else
  #if( $modelObjectKey )
    #set( $condition = {
  \\"expression\\": \\"\\",
  \\"expressionNames\\": {},
  \\"expressionValues\\": {}
} )
    #foreach( $entry in $modelObjectKey.entrySet() )
      #if( $velocityCount == 1 )
        $util.qr($condition.put(\\"expression\\", \\"attribute_exists(#keyCondition$velocityCount)\\"))
      #else
        $util.qr($condition.put(\\"expression\\", \\"$condition.expression AND attribute_exists(#keyCondition$velocityCount)\\"))
      #end
      $util.qr($condition.expressionNames.put(\\"#keyCondition$velocityCount\\", \\"$entry.key\\"))
    #end
  #else
    #set( $condition = {
  \\"expression\\": \\"attribute_exists(#id)\\",
  \\"expressionNames\\": {
      \\"#id\\": \\"id\\"
  },
  \\"expressionValues\\": {}
} )
  #end
#end
$util.qr($context.args.input.put(\\"__typename\\", \\"Post\\"))
## Update condition if type is @versioned **
#if( $versionedCondition )
  $util.qr($condition.put(\\"expression\\", \\"($condition.expression) AND $versionedCondition.expression\\"))
  $util.qr($condition.expressionNames.putAll($versionedCondition.expressionNames))
  $util.qr($condition.expressionValues.putAll($versionedCondition.expressionValues))
#end
#if( $context.args.condition )
  #set( $conditionFilterExpressions = $util.parseJson($util.transform.toDynamoDBConditionExpression($context.args.condition)) )
  $util.qr($condition.put(\\"expression\\", \\"($condition.expression) AND $conditionFilterExpressions.expression\\"))
  $util.qr($condition.expressionNames.putAll($conditionFilterExpressions.expressionNames))
  $util.qr($condition.expressionValues.putAll($conditionFilterExpressions.expressionValues))
#end
#if( $condition.expressionValues && $condition.expressionValues.size() == 0 )
  #set( $condition = {
  \\"expression\\": $condition.expression,
  \\"expressionNames\\": $condition.expressionNames
} )
#end
#set( $expNames = {} )
#set( $expValues = {} )
#set( $expSet = {} )
#set( $expAdd = {} )
#set( $expRemove = [] )
#if( $modelObjectKey )
  #set( $keyFields = [] )
  #foreach( $entry in $modelObjectKey.entrySet() )
    $util.qr($keyFields.add(\\"$entry.key\\"))
  #end
#else
  #set( $keyFields = [\\"id\\"] )
#end
#foreach( $entry in $util.map.copyAndRemoveAllKeys($context.args.input, $keyFields).entrySet() )
  #if( !$util.isNull($dynamodbNameOverrideMap) && $dynamodbNameOverrideMap.containsKey(\\"$entry.key\\") )
    #set( $entryKeyAttributeName = $dynamodbNameOverrideMap.get(\\"$entry.key\\") )
  #else
    #set( $entryKeyAttributeName = $entry.key )
  #end
  #if( $util.isNull($entry.value) )
    #set( $discard = $expRemove.add(\\"#$entryKeyAttributeName\\") )
    $util.qr($expNames.put(\\"#$entryKeyAttributeName\\", \\"$entry.key\\"))
  #else
    $util.qr($expSet.put(\\"#$entryKeyAttributeName\\", \\":$entryKeyAttributeName\\"))
    $util.qr($expNames.put(\\"#$entryKeyAttributeName\\", \\"$entry.key\\"))
    $util.qr($expValues.put(\\":$entryKeyAttributeName\\", $util.dynamodb.toDynamoDB($entry.value)))
  #end
#end
#set( $expression = \\"\\" )
#if( !$expSet.isEmpty() )
  #set( $expression = \\"SET\\" )
  #foreach( $entry in $expSet.entrySet() )
    #set( $expression = \\"$expression $entry.key = $entry.value\\" )
    #if( $foreach.hasNext() )
      #set( $expression = \\"$expression,\\" )
    #end
  #end
#end
#if( !$expAdd.isEmpty() )
  #set( $expression = \\"$expression ADD\\" )
  #foreach( $entry in $expAdd.entrySet() )
    #set( $expression = \\"$expression $entry.key $entry.value\\" )
    #if( $foreach.hasNext() )
      #set( $expression = \\"$expression,\\" )
    #end
  #end
#end
#if( !$expRemove.isEmpty() )
  #set( $expression = \\"$expression REMOVE\\" )
  #foreach( $entry in $expRemove )
    #set( $expression = \\"$expression $entry\\" )
    #if( $foreach.hasNext() )
      #set( $expression = \\"$expression,\\" )
    #end
  #end
#end
#set( $update = {} )
$util.qr($update.put(\\"expression\\", \\"$expression\\"))
#if( !$expNames.isEmpty() )
  $util.qr($update.put(\\"expressionNames\\", $expNames))
#end
#if( !$expValues.isEmpty() )
  $util.qr($update.put(\\"expressionValues\\", $expValues))
#end
{
  \\"version\\": \\"2018-05-29\\",
  \\"operation\\": \\"UpdateItem\\",
  \\"key\\": #if( $modelObjectKey ) $util.toJson($modelObjectKey) #else {
  \\"id\\": {
      \\"S\\": $util.toJson($context.args.input.id)
  }
} #end,
  \\"update\\": $util.toJson($update),
  \\"condition\\": $util.toJson($condition)
}"
`;

exports[`Test schema includes attribute enum when only queries specified 1`] = `
"type Entity {
  id: ID!
  str: String
  createdAt: AWSDateTime!
  updatedAt: AWSDateTime!
}

enum ModelSortDirection {
  ASC
  DESC
}

type ModelEntityConnection {
  items: [Entity]!
  nextToken: String
}

input ModelStringInput {
  ne: String
  eq: String
  le: String
  lt: String
  ge: String
  gt: String
  contains: String
  notContains: String
  between: [String]
  beginsWith: String
  attributeExists: Boolean
  attributeType: ModelAttributeTypes
  size: ModelSizeInput
}

input ModelIDInput {
  ne: ID
  eq: ID
  le: ID
  lt: ID
  ge: ID
  gt: ID
  contains: ID
  notContains: ID
  between: [ID]
  beginsWith: ID
  attributeExists: Boolean
  attributeType: ModelAttributeTypes
  size: ModelSizeInput
}

input ModelIntInput {
  ne: Int
  eq: Int
  le: Int
  lt: Int
  ge: Int
  gt: Int
  between: [Int]
  attributeExists: Boolean
  attributeType: ModelAttributeTypes
}

input ModelFloatInput {
  ne: Float
  eq: Float
  le: Float
  lt: Float
  ge: Float
  gt: Float
  between: [Float]
  attributeExists: Boolean
  attributeType: ModelAttributeTypes
}

input ModelBooleanInput {
  ne: Boolean
  eq: Boolean
  attributeExists: Boolean
  attributeType: ModelAttributeTypes
}

input ModelSizeInput {
  ne: Int
  eq: Int
  le: Int
  lt: Int
  ge: Int
  gt: Int
  between: [Int]
}

input ModelEntityFilterInput {
  id: ModelIDInput
  str: ModelStringInput
  and: [ModelEntityFilterInput]
  or: [ModelEntityFilterInput]
  not: ModelEntityFilterInput
}

enum ModelAttributeTypes {
  binary
  binarySet
  bool
  list
  map
  number
  numberSet
  string
  stringSet
  _null
}

type Query {
  getEntity(id: ID!): Entity
  listEntities(filter: ModelEntityFilterInput, limit: Int, nextToken: String): ModelEntityConnection
}
"
`;

exports[`Test timestamp parameters when generating resolvers and output schema 1`] = `
"type Post {
  id: ID!
  str: String
  createdOn: AWSDateTime!
  updatedOn: AWSDateTime!
}

enum ModelSortDirection {
  ASC
  DESC
}

type ModelPostConnection {
  items: [Post]!
  nextToken: String
}

input ModelStringFilterInput {
  ne: String
  eq: String
  le: String
  lt: String
  ge: String
  gt: String
  contains: String
  notContains: String
  between: [String]
  beginsWith: String
}

input ModelIDFilterInput {
  ne: ID
  eq: ID
  le: ID
  lt: ID
  ge: ID
  gt: ID
  contains: ID
  notContains: ID
  between: [ID]
  beginsWith: ID
}

input ModelIntFilterInput {
  ne: Int
  eq: Int
  le: Int
  lt: Int
  ge: Int
  gt: Int
  between: [Int]
}

input ModelFloatFilterInput {
  ne: Float
  eq: Float
  le: Float
  lt: Float
  ge: Float
  gt: Float
  between: [Float]
}

input ModelBooleanFilterInput {
  ne: Boolean
  eq: Boolean
}

input ModelPostFilterInput {
  id: ModelIDFilterInput
  str: ModelStringFilterInput
  and: [ModelPostFilterInput]
  or: [ModelPostFilterInput]
  not: ModelPostFilterInput
}

type Query {
  getPost(id: ID!): Post
  listPosts(filter: ModelPostFilterInput, limit: Int, nextToken: String): ModelPostConnection
}

input CreatePostInput {
  id: ID
  str: String
}

input UpdatePostInput {
  id: ID!
  str: String
}

input DeletePostInput {
  id: ID!
}

type Mutation {
  createPost(input: CreatePostInput!): Post
  updatePost(input: UpdatePostInput!): Post
  deletePost(input: DeletePostInput!): Post
}

type Subscription {
  onCreatePost: Post @aws_subscribe(mutations: [\\"createPost\\"])
  onUpdatePost: Post @aws_subscribe(mutations: [\\"updatePost\\"])
  onDeletePost: Post @aws_subscribe(mutations: [\\"deletePost\\"])
}
"
`;

exports[`Test timestamp parameters when generating resolvers and output schema 2`] = `
"## [Start] Set default values. **
$util.qr($context.args.input.put(\\"id\\", $util.defaultIfNull($ctx.args.input.id, $util.autoId())))
#set( $createdAt = $util.time.nowISO8601() )
## Automatically set the createdAt timestamp. **
$util.qr($context.args.input.put(\\"createdOn\\", $util.defaultIfNull($ctx.args.input.createdOn, $createdAt)))
## Automatically set the updatedAt timestamp. **
$util.qr($context.args.input.put(\\"updatedOn\\", $util.defaultIfNull($ctx.args.input.updatedOn, $createdAt)))
## [End] Set default values. **
## [Start] Prepare DynamoDB PutItem Request. **
$util.qr($context.args.input.put(\\"__typename\\", \\"Post\\"))
#if( $modelObjectKey )
  #set( $condition = {
  \\"expression\\": \\"\\",
  \\"expressionNames\\": {},
  \\"expressionValues\\": {}
} )
  #foreach( $entry in $modelObjectKey.entrySet() )
    #if( $velocityCount == 1 )
      $util.qr($condition.put(\\"expression\\", \\"attribute_not_exists(#keyCondition$velocityCount)\\"))
    #else
      $util.qr($condition.put(\\"expression\\", \\"$condition.expression AND attribute_not_exists(#keyCondition$velocityCount)\\"))
    #end
    $util.qr($condition.expressionNames.put(\\"#keyCondition$velocityCount\\", \\"$entry.key\\"))
  #end
#else
  #set( $condition = {
  \\"expression\\": \\"attribute_not_exists(#id)\\",
  \\"expressionNames\\": {
      \\"#id\\": \\"id\\"
  },
  \\"expressionValues\\": {}
} )
#end
#if( $context.args.condition )
  #set( $condition.expressionValues = {} )
  #set( $conditionFilterExpressions = $util.parseJson($util.transform.toDynamoDBConditionExpression($context.args.condition)) )
  $util.qr($condition.put(\\"expression\\", \\"($condition.expression) AND $conditionFilterExpressions.expression\\"))
  $util.qr($condition.expressionNames.putAll($conditionFilterExpressions.expressionNames))
  $util.qr($condition.expressionValues.putAll($conditionFilterExpressions.expressionValues))
#end
#if( $condition.expressionValues && $condition.expressionValues.size() == 0 )
  #set( $condition = {
  \\"expression\\": $condition.expression,
  \\"expressionNames\\": $condition.expressionNames
} )
#end
{
  \\"version\\": \\"2018-05-29\\",
  \\"operation\\": \\"PutItem\\",
  \\"key\\": #if( $modelObjectKey ) $util.toJson($modelObjectKey) #else {
  \\"id\\":   $util.dynamodb.toDynamoDBJson($ctx.args.input.id)
} #end,
  \\"attributeValues\\": $util.dynamodb.toMapValuesJson($context.args.input),
  \\"condition\\": $util.toJson($condition)
}
## [End] Prepare DynamoDB PutItem Request. **"
`;

exports[`Test timestamp parameters when generating resolvers and output schema 3`] = `
"#set( $optionalNonNullableFields = [] )
#foreach( $field in $optionalNonNullableFields )
  #if( $context.arguments.input.keySet().contains($field) && $util.isNull($context.args.input.get($field)) )
$util.error(\\"An argument you marked as Non-Null is set to Null in the query or the body of your request.\\")
  #end
#end
#if( $authCondition && $authCondition.expression != \\"\\" )
  #set( $condition = $authCondition )
  #if( $modelObjectKey )
    #foreach( $entry in $modelObjectKey.entrySet() )
      $util.qr($condition.put(\\"expression\\", \\"$condition.expression AND attribute_exists(#keyCondition$velocityCount)\\"))
      $util.qr($condition.expressionNames.put(\\"#keyCondition$velocityCount\\", \\"$entry.key\\"))
    #end
  #else
    $util.qr($condition.put(\\"expression\\", \\"$condition.expression AND attribute_exists(#id)\\"))
    $util.qr($condition.expressionNames.put(\\"#id\\", \\"id\\"))
  #end
#else
  #if( $modelObjectKey )
    #set( $condition = {
  \\"expression\\": \\"\\",
  \\"expressionNames\\": {},
  \\"expressionValues\\": {}
} )
    #foreach( $entry in $modelObjectKey.entrySet() )
      #if( $velocityCount == 1 )
        $util.qr($condition.put(\\"expression\\", \\"attribute_exists(#keyCondition$velocityCount)\\"))
      #else
        $util.qr($condition.put(\\"expression\\", \\"$condition.expression AND attribute_exists(#keyCondition$velocityCount)\\"))
      #end
      $util.qr($condition.expressionNames.put(\\"#keyCondition$velocityCount\\", \\"$entry.key\\"))
    #end
  #else
    #set( $condition = {
  \\"expression\\": \\"attribute_exists(#id)\\",
  \\"expressionNames\\": {
      \\"#id\\": \\"id\\"
  },
  \\"expressionValues\\": {}
} )
  #end
#end
## Automatically set the updatedAt timestamp. **
$util.qr($context.args.input.put(\\"updatedOn\\", $util.defaultIfNull($ctx.args.input.updatedOn, $util.time.nowISO8601())))
$util.qr($context.args.input.put(\\"__typename\\", \\"Post\\"))
## Update condition if type is @versioned **
#if( $versionedCondition )
  $util.qr($condition.put(\\"expression\\", \\"($condition.expression) AND $versionedCondition.expression\\"))
  $util.qr($condition.expressionNames.putAll($versionedCondition.expressionNames))
  $util.qr($condition.expressionValues.putAll($versionedCondition.expressionValues))
#end
#if( $context.args.condition )
  #set( $conditionFilterExpressions = $util.parseJson($util.transform.toDynamoDBConditionExpression($context.args.condition)) )
  $util.qr($condition.put(\\"expression\\", \\"($condition.expression) AND $conditionFilterExpressions.expression\\"))
  $util.qr($condition.expressionNames.putAll($conditionFilterExpressions.expressionNames))
  $util.qr($condition.expressionValues.putAll($conditionFilterExpressions.expressionValues))
#end
#if( $condition.expressionValues && $condition.expressionValues.size() == 0 )
  #set( $condition = {
  \\"expression\\": $condition.expression,
  \\"expressionNames\\": $condition.expressionNames
} )
#end
#set( $expNames = {} )
#set( $expValues = {} )
#set( $expSet = {} )
#set( $expAdd = {} )
#set( $expRemove = [] )
#if( $modelObjectKey )
  #set( $keyFields = [] )
  #foreach( $entry in $modelObjectKey.entrySet() )
    $util.qr($keyFields.add(\\"$entry.key\\"))
  #end
#else
  #set( $keyFields = [\\"id\\"] )
#end
#foreach( $entry in $util.map.copyAndRemoveAllKeys($context.args.input, $keyFields).entrySet() )
  #if( !$util.isNull($dynamodbNameOverrideMap) && $dynamodbNameOverrideMap.containsKey(\\"$entry.key\\") )
    #set( $entryKeyAttributeName = $dynamodbNameOverrideMap.get(\\"$entry.key\\") )
  #else
    #set( $entryKeyAttributeName = $entry.key )
  #end
  #if( $util.isNull($entry.value) )
    #set( $discard = $expRemove.add(\\"#$entryKeyAttributeName\\") )
    $util.qr($expNames.put(\\"#$entryKeyAttributeName\\", \\"$entry.key\\"))
  #else
    $util.qr($expSet.put(\\"#$entryKeyAttributeName\\", \\":$entryKeyAttributeName\\"))
    $util.qr($expNames.put(\\"#$entryKeyAttributeName\\", \\"$entry.key\\"))
    $util.qr($expValues.put(\\":$entryKeyAttributeName\\", $util.dynamodb.toDynamoDB($entry.value)))
  #end
#end
#set( $expression = \\"\\" )
#if( !$expSet.isEmpty() )
  #set( $expression = \\"SET\\" )
  #foreach( $entry in $expSet.entrySet() )
    #set( $expression = \\"$expression $entry.key = $entry.value\\" )
    #if( $foreach.hasNext() )
      #set( $expression = \\"$expression,\\" )
    #end
  #end
#end
#if( !$expAdd.isEmpty() )
  #set( $expression = \\"$expression ADD\\" )
  #foreach( $entry in $expAdd.entrySet() )
    #set( $expression = \\"$expression $entry.key $entry.value\\" )
    #if( $foreach.hasNext() )
      #set( $expression = \\"$expression,\\" )
    #end
  #end
#end
#if( !$expRemove.isEmpty() )
  #set( $expression = \\"$expression REMOVE\\" )
  #foreach( $entry in $expRemove )
    #set( $expression = \\"$expression $entry\\" )
    #if( $foreach.hasNext() )
      #set( $expression = \\"$expression,\\" )
    #end
  #end
#end
#set( $update = {} )
$util.qr($update.put(\\"expression\\", \\"$expression\\"))
#if( !$expNames.isEmpty() )
  $util.qr($update.put(\\"expressionNames\\", $expNames))
#end
#if( !$expValues.isEmpty() )
  $util.qr($update.put(\\"expressionValues\\", $expValues))
#end
{
  \\"version\\": \\"2018-05-29\\",
  \\"operation\\": \\"UpdateItem\\",
  \\"key\\": #if( $modelObjectKey ) $util.toJson($modelObjectKey) #else {
  \\"id\\": {
      \\"S\\": $util.toJson($context.args.input.id)
  }
} #end,
  \\"update\\": $util.toJson($update),
  \\"condition\\": $util.toJson($condition)
}"
`;

exports[`V4 transformer snapshot test 1`] = `
"type Post {
  id: ID!
  content: String
  createdAt: AWSDateTime!
  updatedAt: AWSDateTime!
}

enum ModelSortDirection {
  ASC
  DESC
}

type ModelPostConnection {
  items: [Post]!
  nextToken: String
}

input ModelStringFilterInput {
  ne: String
  eq: String
  le: String
  lt: String
  ge: String
  gt: String
  contains: String
  notContains: String
  between: [String]
  beginsWith: String
}

input ModelIDFilterInput {
  ne: ID
  eq: ID
  le: ID
  lt: ID
  ge: ID
  gt: ID
  contains: ID
  notContains: ID
  between: [ID]
  beginsWith: ID
}

input ModelIntFilterInput {
  ne: Int
  eq: Int
  le: Int
  lt: Int
  ge: Int
  gt: Int
  between: [Int]
}

input ModelFloatFilterInput {
  ne: Float
  eq: Float
  le: Float
  lt: Float
  ge: Float
  gt: Float
  between: [Float]
}

input ModelBooleanFilterInput {
  ne: Boolean
  eq: Boolean
}

input ModelPostFilterInput {
  id: ModelIDFilterInput
  content: ModelStringFilterInput
  and: [ModelPostFilterInput]
  or: [ModelPostFilterInput]
  not: ModelPostFilterInput
}

type Query {
  getPost(id: ID!): Post
  listPosts(filter: ModelPostFilterInput, limit: Int, nextToken: String): ModelPostConnection
}

input CreatePostInput {
  id: ID
  content: String
}

input UpdatePostInput {
  id: ID!
  content: String
}

input DeletePostInput {
  id: ID!
}

type Mutation {
  createPost(input: CreatePostInput!): Post
  updatePost(input: UpdatePostInput!): Post
  deletePost(input: DeletePostInput!): Post
}

type Subscription {
  onCreatePost: Post @aws_subscribe(mutations: [\\"createPost\\"])
  onUpdatePost: Post @aws_subscribe(mutations: [\\"updatePost\\"])
  onDeletePost: Post @aws_subscribe(mutations: [\\"deletePost\\"])
}
"
`;

exports[`V5 transformer snapshot test 1`] = `
"type Post {
  id: ID!
  content: String
  createdAt: AWSDateTime!
  updatedAt: AWSDateTime!
}

enum ModelSortDirection {
  ASC
  DESC
}

type ModelPostConnection {
  items: [Post]!
  nextToken: String
}

input ModelStringInput {
  ne: String
  eq: String
  le: String
  lt: String
  ge: String
  gt: String
  contains: String
  notContains: String
  between: [String]
  beginsWith: String
  attributeExists: Boolean
  attributeType: ModelAttributeTypes
  size: ModelSizeInput
}

input ModelIDInput {
  ne: ID
  eq: ID
  le: ID
  lt: ID
  ge: ID
  gt: ID
  contains: ID
  notContains: ID
  between: [ID]
  beginsWith: ID
  attributeExists: Boolean
  attributeType: ModelAttributeTypes
  size: ModelSizeInput
}

input ModelIntInput {
  ne: Int
  eq: Int
  le: Int
  lt: Int
  ge: Int
  gt: Int
  between: [Int]
  attributeExists: Boolean
  attributeType: ModelAttributeTypes
}

input ModelFloatInput {
  ne: Float
  eq: Float
  le: Float
  lt: Float
  ge: Float
  gt: Float
  between: [Float]
  attributeExists: Boolean
  attributeType: ModelAttributeTypes
}

input ModelBooleanInput {
  ne: Boolean
  eq: Boolean
  attributeExists: Boolean
  attributeType: ModelAttributeTypes
}

input ModelSizeInput {
  ne: Int
  eq: Int
  le: Int
  lt: Int
  ge: Int
  gt: Int
  between: [Int]
}

input ModelPostFilterInput {
  id: ModelIDInput
  content: ModelStringInput
  and: [ModelPostFilterInput]
  or: [ModelPostFilterInput]
  not: ModelPostFilterInput
}

enum ModelAttributeTypes {
  binary
  binarySet
  bool
  list
  map
  number
  numberSet
  string
  stringSet
  _null
}

type Query {
  getPost(id: ID!): Post
  listPosts(filter: ModelPostFilterInput, limit: Int, nextToken: String): ModelPostConnection
}

input CreatePostInput {
  id: ID
  content: String
}

input UpdatePostInput {
  id: ID!
  content: String
}

input DeletePostInput {
  id: ID!
}

type Mutation {
  createPost(input: CreatePostInput!, condition: ModelPostConditionInput): Post
  updatePost(input: UpdatePostInput!, condition: ModelPostConditionInput): Post
  deletePost(input: DeletePostInput!, condition: ModelPostConditionInput): Post
}

input ModelPostConditionInput {
  content: ModelStringInput
  and: [ModelPostConditionInput]
  or: [ModelPostConditionInput]
  not: ModelPostConditionInput
}

type Subscription {
  onCreatePost: Post @aws_subscribe(mutations: [\\"createPost\\"])
  onUpdatePost: Post @aws_subscribe(mutations: [\\"updatePost\\"])
  onDeletePost: Post @aws_subscribe(mutations: [\\"deletePost\\"])
}
"
`;
