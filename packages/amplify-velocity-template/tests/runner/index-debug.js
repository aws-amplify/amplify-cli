define('velocityjs/0.4.10/index-debug', [], function(require, exports, module) {
  'use strict';
  module.exports = require('velocityjs/0.4.10/src/velocity-debug');
});
define('velocityjs/0.4.10/src/velocity-debug', [], function(require, exports, module) {
  var Parser = require('velocityjs/0.4.10/src/parse/index-debug');
  var utils = require('velocityjs/0.4.10/src/utils-debug');
  var Compile = require('velocityjs/0.4.10/src/compile/index-debug');
  var Helper = require('velocityjs/0.4.10/src/helper/index-debug');

  Compile.Parser = Parser;
  Parser._parse = Parser.parse;

  Parser.parse = function(str) {
    var asts = Parser._parse(str);

    /**
     * remove all newline after all direction such as `#set, #each`
     */
    utils.forEach(asts, function trim(ast, i) {
      var TRIM_REG = /^[ \t]*\n/;
      if (ast.type && ast.type !== 'references') {
        var _ast = asts[i + 1];
        if (typeof _ast === 'string' && TRIM_REG.test(_ast)) {
          asts[i + 1] = _ast.replace(TRIM_REG, '');
        }
      }
    });

    return utils.makeLevel(asts);
  };

  var Velocity = {
    Parser: Parser,
    Compile: Compile,
    Helper: Helper,
  };

  Velocity.render = function(template, context, macros) {
    var asts = Parser.parse(template);
    var compile = new Compile(asts);
    return compile.render(context, macros);
  };

  module.exports = Velocity;
});
define('velocityjs/0.4.10/src/parse/index-debug', [], function(require, exports, module) {
  /* parser generated by jison 0.4.15 */
  /*
  Returns a Parser object of the following structure:

  Parser: {
    yy: {}
  }

  Parser.prototype: {
    yy: {},
    trace: function(),
    symbols_: {associative list: name ==> number},
    terminals_: {associative list: number ==> name},
    productions_: [...],
    performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate, $$, _$),
    table: [...],
    defaultActions: {...},
    parseError: function(str, hash),
    parse: function(input),

    lexer: {
        EOF: 1,
        parseError: function(str, hash),
        setInput: function(input),
        input: function(),
        unput: function(str),
        more: function(),
        less: function(n),
        pastInput: function(),
        upcomingInput: function(),
        showPosition: function(),
        test_match: function(regex_match_array, rule_index),
        next: function(),
        lex: function(),
        begin: function(condition),
        popState: function(),
        _currentRules: function(),
        topState: function(),
        pushState: function(condition),

        options: {
            ranges: boolean           (optional: true ==> token location info will include a .range[] member)
            flex: boolean             (optional: true ==> flex-like lexing behaviour where the rules are tested exhaustively to find the longest match)
            backtrack_lexer: boolean  (optional: true ==> lexer regexes are tested in order and for each matching regex the action code is invoked; the lexer terminates the scan when a token is returned by the action code)
        },

        performAction: function(yy, yy_, $avoiding_name_collisions, YY_START),
        rules: [...],
        conditions: {associative list: name ==> set},
    }
  }


  token location info (@$, _$, etc.): {
    first_line: n,
    last_line: n,
    first_column: n,
    last_column: n,
    range: [start_number, end_number]       (where the numbers are indexes into the input string, regular zero-based)
  }


  the parseError function receives a 'hash' object with these members for lexer and parser errors: {
    text:        (matched text)
    token:       (the produced terminal token, if any)
    line:        (yylineno)
  }
  while parser (grammar) errors will also provide these members, i.e. parser errors deliver a superset of attributes: {
    loc:         (yylloc)
    expected:    (string describing the set of expected tokens)
    recoverable: (boolean: TRUE when the parser has a error recovery rule available for this particular error)
  }
*/
  var parser = (function() {
    var o = function(k, v, o, l) {
        for (o = o || {}, l = k.length; l--; o[k[l]] = v);
        return o;
      },
      $V0 = [1, 8],
      $V1 = [1, 18],
      $V2 = [1, 9],
      $V3 = [1, 22],
      $V4 = [1, 21],
      $V5 = [4, 10, 19, 33, 34, 79],
      $V6 = [1, 26],
      $V7 = [1, 29],
      $V8 = [1, 30],
      $V9 = [4, 10, 19, 22, 33, 34, 44, 45, 46, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 72, 79, 81, 91],
      $Va = [1, 46],
      $Vb = [1, 51],
      $Vc = [1, 52],
      $Vd = [1, 66],
      $Ve = [1, 67],
      $Vf = [1, 78],
      $Vg = [1, 89],
      $Vh = [1, 81],
      $Vi = [1, 79],
      $Vj = [1, 84],
      $Vk = [1, 88],
      $Vl = [1, 85],
      $Vm = [1, 86],
      $Vn = [4, 10, 19, 22, 33, 34, 44, 45, 46, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 71, 72, 77, 79, 80, 81, 91],
      $Vo = [1, 115],
      $Vp = [1, 111],
      $Vq = [1, 112],
      $Vr = [1, 123],
      $Vs = [22, 45, 81],
      $Vt = [2, 89],
      $Vu = [22, 44, 45, 72, 81],
      $Vv = [22, 44, 45, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 72, 79, 81],
      $Vw = [22, 44, 45, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 72, 79, 81, 93],
      $Vx = [2, 102],
      $Vy = [22, 44, 45, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 72, 79, 81, 91],
      $Vz = [2, 105],
      $VA = [1, 132],
      $VB = [1, 138],
      $VC = [22, 44, 45],
      $VD = [1, 143],
      $VE = [1, 144],
      $VF = [1, 145],
      $VG = [1, 146],
      $VH = [1, 147],
      $VI = [1, 148],
      $VJ = [1, 149],
      $VK = [1, 150],
      $VL = [1, 151],
      $VM = [1, 152],
      $VN = [1, 153],
      $VO = [1, 154],
      $VP = [1, 155],
      $VQ = [22, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61],
      $VR = [45, 81],
      $VS = [2, 106],
      $VT = [22, 33],
      $VU = [1, 202],
      $VV = [1, 201],
      $VW = [45, 72],
      $VX = [22, 49, 50],
      $VY = [22, 49, 50, 51, 52, 56, 57, 58, 59, 60, 61],
      $VZ = [22, 49, 50, 56, 57, 58, 59, 60, 61];
    var parser = {
      trace: function trace() {},
      yy: {},
      symbols_: {
        error: 2,
        root: 3,
        EOF: 4,
        statements: 5,
        statement: 6,
        references: 7,
        directives: 8,
        content: 9,
        COMMENT: 10,
        set: 11,
        if: 12,
        elseif: 13,
        else: 14,
        end: 15,
        foreach: 16,
        break: 17,
        define: 18,
        HASH: 19,
        NOESCAPE: 20,
        PARENTHESIS: 21,
        CLOSE_PARENTHESIS: 22,
        macro: 23,
        macro_call: 24,
        SET: 25,
        equal: 26,
        IF: 27,
        expression: 28,
        ELSEIF: 29,
        ELSE: 30,
        END: 31,
        FOREACH: 32,
        DOLLAR: 33,
        ID: 34,
        IN: 35,
        array: 36,
        BREAK: 37,
        DEFINE: 38,
        MACRO: 39,
        macro_args: 40,
        macro_call_args_all: 41,
        macro_call_args: 42,
        literals: 43,
        SPACE: 44,
        COMMA: 45,
        EQUAL: 46,
        map: 47,
        math: 48,
        '||': 49,
        '&&': 50,
        '+': 51,
        '-': 52,
        '*': 53,
        '/': 54,
        '%': 55,
        '>': 56,
        '<': 57,
        '==': 58,
        '>=': 59,
        '<=': 60,
        '!=': 61,
        parenthesis: 62,
        '!': 63,
        literal: 64,
        brace_begin: 65,
        attributes: 66,
        brace_end: 67,
        methodbd: 68,
        VAR_BEGIN: 69,
        MAP_BEGIN: 70,
        VAR_END: 71,
        MAP_END: 72,
        attribute: 73,
        method: 74,
        index: 75,
        property: 76,
        DOT: 77,
        params: 78,
        CONTENT: 79,
        BRACKET: 80,
        CLOSE_BRACKET: 81,
        string: 82,
        number: 83,
        BOOL: 84,
        integer: 85,
        INTEGER: 86,
        DECIMAL_POINT: 87,
        STRING: 88,
        EVAL_STRING: 89,
        range: 90,
        RANGE: 91,
        map_item: 92,
        MAP_SPLIT: 93,
        $accept: 0,
        $end: 1,
      },
      terminals_: {
        2: 'error',
        4: 'EOF',
        10: 'COMMENT',
        19: 'HASH',
        20: 'NOESCAPE',
        21: 'PARENTHESIS',
        22: 'CLOSE_PARENTHESIS',
        25: 'SET',
        27: 'IF',
        29: 'ELSEIF',
        30: 'ELSE',
        31: 'END',
        32: 'FOREACH',
        33: 'DOLLAR',
        34: 'ID',
        35: 'IN',
        37: 'BREAK',
        38: 'DEFINE',
        39: 'MACRO',
        44: 'SPACE',
        45: 'COMMA',
        46: 'EQUAL',
        49: '||',
        50: '&&',
        51: '+',
        52: '-',
        53: '*',
        54: '/',
        55: '%',
        56: '>',
        57: '<',
        58: '==',
        59: '>=',
        60: '<=',
        61: '!=',
        63: '!',
        69: 'VAR_BEGIN',
        70: 'MAP_BEGIN',
        71: 'VAR_END',
        72: 'MAP_END',
        77: 'DOT',
        79: 'CONTENT',
        80: 'BRACKET',
        81: 'CLOSE_BRACKET',
        84: 'BOOL',
        86: 'INTEGER',
        87: 'DECIMAL_POINT',
        88: 'STRING',
        89: 'EVAL_STRING',
        91: 'RANGE',
        93: 'MAP_SPLIT',
      },
      productions_: [
        0,
        [3, 1],
        [3, 2],
        [5, 1],
        [5, 2],
        [6, 1],
        [6, 1],
        [6, 1],
        [6, 1],
        [8, 1],
        [8, 1],
        [8, 1],
        [8, 1],
        [8, 1],
        [8, 1],
        [8, 1],
        [8, 1],
        [8, 4],
        [8, 1],
        [8, 1],
        [11, 5],
        [12, 5],
        [13, 5],
        [14, 2],
        [15, 2],
        [16, 8],
        [16, 8],
        [17, 2],
        [18, 6],
        [23, 6],
        [23, 5],
        [40, 1],
        [40, 2],
        [24, 5],
        [24, 4],
        [42, 1],
        [42, 1],
        [42, 3],
        [42, 3],
        [42, 3],
        [42, 3],
        [41, 1],
        [41, 2],
        [41, 3],
        [41, 2],
        [26, 3],
        [28, 1],
        [28, 1],
        [28, 1],
        [48, 3],
        [48, 3],
        [48, 3],
        [48, 3],
        [48, 3],
        [48, 3],
        [48, 3],
        [48, 3],
        [48, 3],
        [48, 3],
        [48, 3],
        [48, 3],
        [48, 3],
        [48, 1],
        [48, 2],
        [48, 2],
        [48, 1],
        [48, 1],
        [62, 3],
        [7, 5],
        [7, 3],
        [7, 5],
        [7, 3],
        [7, 2],
        [7, 4],
        [7, 2],
        [7, 4],
        [65, 1],
        [65, 1],
        [67, 1],
        [67, 1],
        [66, 1],
        [66, 2],
        [73, 1],
        [73, 1],
        [73, 1],
        [74, 2],
        [68, 4],
        [68, 3],
        [78, 1],
        [78, 1],
        [78, 3],
        [78, 3],
        [76, 2],
        [76, 2],
        [75, 3],
        [75, 3],
        [75, 3],
        [75, 2],
        [75, 2],
        [64, 1],
        [64, 1],
        [64, 1],
        [83, 1],
        [83, 3],
        [83, 4],
        [85, 1],
        [85, 2],
        [82, 1],
        [82, 1],
        [43, 1],
        [43, 1],
        [43, 1],
        [36, 3],
        [36, 1],
        [36, 2],
        [90, 5],
        [90, 5],
        [90, 5],
        [90, 5],
        [47, 3],
        [47, 2],
        [92, 3],
        [92, 3],
        [92, 2],
        [92, 5],
        [92, 5],
        [9, 1],
        [9, 1],
        [9, 2],
        [9, 3],
        [9, 3],
        [9, 2],
      ],
      performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate /* action[1] */, $$ /* vstack */, _$ /* lstack */) {
        /* this == yyval */

        var $0 = $$.length - 1;
        switch (yystate) {
          case 1:
            return [];
            break;
          case 2:
            return $$[$0 - 1];
            break;
          case 3:
          case 31:
          case 35:
          case 36:
          case 80:
          case 88:
          case 89:
            this.$ = [$$[$0]];
            break;
          case 4:
          case 32:
          case 81:
            this.$ = [].concat($$[$0 - 1], $$[$0]);
            break;
          case 5:
            $$[$0]['prue'] = true;
            $$[$0].pos = this._$;
            this.$ = $$[$0];
            break;
          case 6:
            $$[$0].pos = this._$;
            this.$ = $$[$0];
            break;
          case 7:
          case 9:
          case 10:
          case 11:
          case 12:
          case 13:
          case 14:
          case 15:
          case 16:
          case 18:
          case 19:
          case 41:
          case 42:
          case 46:
          case 47:
          case 48:
          case 62:
          case 65:
          case 66:
          case 76:
          case 77:
          case 78:
          case 79:
          case 85:
          case 92:
          case 99:
          case 100:
          case 105:
          case 111:
          case 113:
          case 126:
          case 127:
            this.$ = $$[$0];
            break;
          case 8:
            this.$ = { type: 'comment', value: $$[$0] };
            break;
          case 17:
            this.$ = { type: 'noescape' };
            break;
          case 20:
            this.$ = { type: 'set', equal: $$[$0 - 1] };
            break;
          case 21:
            this.$ = { type: 'if', condition: $$[$0 - 1] };
            break;
          case 22:
            this.$ = { type: 'elseif', condition: $$[$0 - 1] };
            break;
          case 23:
            this.$ = { type: 'else' };
            break;
          case 24:
            this.$ = { type: 'end' };
            break;
          case 25:
          case 26:
            this.$ = { type: 'foreach', to: $$[$0 - 3], from: $$[$0 - 1] };
            break;
          case 27:
            this.$ = { type: $$[$0] };
            break;
          case 28:
            this.$ = { type: 'define', id: $$[$0 - 1] };
            break;
          case 29:
            this.$ = { type: 'macro', id: $$[$0 - 2], args: $$[$0 - 1] };
            break;
          case 30:
            this.$ = { type: 'macro', id: $$[$0 - 1] };
            break;
          case 33:
            this.$ = { type: 'macro_call', id: $$[$0 - 3].replace(/^\s+|\s+$/g, ''), args: $$[$0 - 1] };
            break;
          case 34:
            this.$ = { type: 'macro_call', id: $$[$0 - 2].replace(/^\s+|\s+$/g, '') };
            break;
          case 37:
          case 38:
          case 39:
          case 40:
          case 90:
          case 91:
            this.$ = [].concat($$[$0 - 2], $$[$0]);
            break;
          case 43:
          case 44:
          case 94:
          case 95:
            this.$ = $$[$0 - 1];
            break;
          case 45:
            this.$ = [$$[$0 - 2], $$[$0]];
            break;
          case 49:
          case 50:
          case 51:
          case 52:
          case 53:
          case 54:
          case 55:
          case 56:
          case 57:
          case 58:
          case 59:
          case 60:
          case 61:
            this.$ = { type: 'math', expression: [$$[$0 - 2], $$[$0]], operator: $$[$0 - 1] };
            break;
          case 63:
            this.$ = { type: 'math', expression: [$$[$0]], operator: 'minus' };
            break;
          case 64:
            this.$ = { type: 'math', expression: [$$[$0]], operator: 'not' };
            break;
          case 67:
            this.$ = { type: 'math', expression: [$$[$0 - 1]], operator: 'parenthesis' };
            break;
          case 68:
            this.$ = { type: 'references', id: $$[$0 - 2], path: $$[$0 - 1], isWraped: true, leader: $$[$0 - 4] };
            break;
          case 69:
            this.$ = { type: 'references', id: $$[$0 - 1], path: $$[$0], leader: $$[$0 - 2] };
            break;
          case 70:
            this.$ = { type: 'references', id: $$[$0 - 2].id, path: $$[$0 - 1], isWraped: true, leader: $$[$0 - 4], args: $$[$0 - 2].args };
            break;
          case 71:
            this.$ = { type: 'references', id: $$[$0 - 1].id, path: $$[$0], leader: $$[$0 - 2], args: $$[$0 - 1].args };
            break;
          case 72:
            this.$ = { type: 'references', id: $$[$0], leader: $$[$0 - 1] };
            break;
          case 73:
            this.$ = { type: 'references', id: $$[$0 - 1], isWraped: true, leader: $$[$0 - 3] };
            break;
          case 74:
            this.$ = { type: 'references', id: $$[$0].id, leader: $$[$0 - 1], args: $$[$0].args };
            break;
          case 75:
            this.$ = { type: 'references', id: $$[$0 - 1].id, isWraped: true, args: $$[$0 - 1].args, leader: $$[$0 - 3] };
            break;
          case 82:
            this.$ = { type: 'method', id: $$[$0].id, args: $$[$0].args };
            break;
          case 83:
            this.$ = { type: 'index', id: $$[$0] };
            break;
          case 84:
            this.$ = { type: 'property', id: $$[$0] };
            if ($$[$0].type === 'content') this.$ = $$[$0];
            break;
          case 86:
            this.$ = { id: $$[$0 - 3], args: $$[$0 - 1] };
            break;
          case 87:
            this.$ = { id: $$[$0 - 2], args: false };
            break;
          case 93:
            this.$ = { type: 'content', value: $$[$0 - 1] + $$[$0] };
            break;
          case 96:
            this.$ = { type: 'content', value: $$[$0 - 2] + $$[$0 - 1].value + $$[$0] };
            break;
          case 97:
          case 98:
            this.$ = { type: 'content', value: $$[$0 - 1] + $$[$0] };
            break;
          case 101:
            this.$ = { type: 'bool', value: $$[$0] };
            break;
          case 102:
            this.$ = { type: 'integer', value: $$[$0] };
            break;
          case 103:
            this.$ = { type: 'decimal', value: +($$[$0 - 2] + '.' + $$[$0]) };
            break;
          case 104:
            this.$ = { type: 'decimal', value: -($$[$0 - 2] + '.' + $$[$0]) };
            break;
          case 106:
            this.$ = -parseInt($$[$0], 10);
            break;
          case 107:
            this.$ = { type: 'string', value: $$[$0] };
            break;
          case 108:
            this.$ = { type: 'string', value: $$[$0], isEval: true };
            break;
          case 109:
          case 110:
            this.$ = $$[$0];
            break;
          case 112:
            this.$ = { type: 'array', value: $$[$0 - 1] };
            break;
          case 114:
            this.$ = { type: 'array', value: [] };
            break;
          case 115:
          case 116:
          case 117:
          case 118:
            this.$ = { type: 'array', isRange: true, value: [$$[$0 - 3], $$[$0 - 1]] };
            break;
          case 119:
            this.$ = { type: 'map', value: $$[$0 - 1] };
            break;
          case 120:
            this.$ = { type: 'map' };
            break;
          case 121:
          case 122:
            this.$ = {};
            this.$[$$[$0 - 2].value] = $$[$0];
            break;
          case 123:
            this.$ = {};
            this.$[$$[$0 - 1].value] = $$[$01];
            break;
          case 124:
          case 125:
            this.$ = $$[$0 - 4];
            this.$[$$[$0 - 2].value] = $$[$0];
            break;
          case 128:
          case 131:
            this.$ = $$[$0 - 1] + $$[$0];
            break;
          case 129:
            this.$ = $$[$0 - 2] + $$[$0 - 1] + $$[$0];
            break;
          case 130:
            this.$ = $$[$0 - 2] + $$[$0 - 1];
            break;
        }
      },
      table: [
        {
          3: 1,
          4: [1, 2],
          5: 3,
          6: 4,
          7: 5,
          8: 6,
          9: 7,
          10: $V0,
          11: 10,
          12: 11,
          13: 12,
          14: 13,
          15: 14,
          16: 15,
          17: 16,
          18: 17,
          19: $V1,
          23: 19,
          24: 20,
          33: $V2,
          34: $V3,
          79: $V4,
        },
        { 1: [3] },
        { 1: [2, 1] },
        {
          4: [1, 23],
          6: 24,
          7: 5,
          8: 6,
          9: 7,
          10: $V0,
          11: 10,
          12: 11,
          13: 12,
          14: 13,
          15: 14,
          16: 15,
          17: 16,
          18: 17,
          19: $V1,
          23: 19,
          24: 20,
          33: $V2,
          34: $V3,
          79: $V4,
        },
        o($V5, [2, 3]),
        o($V5, [2, 5]),
        o($V5, [2, 6]),
        o($V5, [2, 7]),
        o($V5, [2, 8]),
        { 34: $V6, 65: 25, 68: 27, 69: $V7, 70: $V8, 79: [1, 28] },
        o($V5, [2, 9]),
        o($V5, [2, 10]),
        o($V5, [2, 11]),
        o($V5, [2, 12]),
        o($V5, [2, 13]),
        o($V5, [2, 14]),
        o($V5, [2, 15]),
        o($V5, [2, 16]),
        {
          20: [1, 31],
          25: [1, 34],
          27: [1, 35],
          29: [1, 36],
          30: [1, 37],
          31: [1, 38],
          32: [1, 39],
          34: [1, 33],
          37: [1, 40],
          38: [1, 41],
          39: [1, 42],
          79: [1, 32],
        },
        o($V5, [2, 18]),
        o($V5, [2, 19]),
        o($V5, [2, 126]),
        o($V5, [2, 127]),
        { 1: [2, 2] },
        o($V5, [2, 4]),
        { 34: [1, 43], 68: 44 },
        o($V9, [2, 72], { 66: 45, 73: 47, 74: 48, 75: 49, 76: 50, 21: $Va, 77: $Vb, 80: $Vc }),
        o($V9, [2, 74], { 73: 47, 74: 48, 75: 49, 76: 50, 66: 53, 77: $Vb, 80: $Vc }),
        o($V5, [2, 131]),
        { 34: [2, 76] },
        { 34: [2, 77] },
        { 21: [1, 54] },
        o($V5, [2, 128]),
        { 4: [1, 56], 21: [1, 57], 79: [1, 55] },
        { 21: [1, 58] },
        { 21: [1, 59] },
        { 21: [1, 60] },
        o($V5, [2, 23]),
        o($V5, [2, 24]),
        { 21: [1, 61] },
        o($V5, [2, 27]),
        { 21: [1, 62] },
        { 21: [1, 63] },
        { 21: $Va, 66: 64, 67: 65, 71: $Vd, 72: $Ve, 73: 47, 74: 48, 75: 49, 76: 50, 77: $Vb, 80: $Vc },
        { 66: 68, 67: 69, 71: $Vd, 72: $Ve, 73: 47, 74: 48, 75: 49, 76: 50, 77: $Vb, 80: $Vc },
        o($V9, [2, 69], { 74: 48, 75: 49, 76: 50, 73: 70, 77: $Vb, 80: $Vc }),
        {
          7: 74,
          22: [1, 72],
          33: $Vf,
          36: 75,
          43: 73,
          47: 76,
          52: $Vg,
          64: 77,
          70: $Vh,
          78: 71,
          80: $Vi,
          82: 82,
          83: 83,
          84: $Vj,
          85: 87,
          86: $Vk,
          88: $Vl,
          89: $Vm,
          90: 80,
        },
        o($Vn, [2, 80]),
        o($Vn, [2, 82]),
        o($Vn, [2, 83]),
        o($Vn, [2, 84]),
        { 34: [1, 91], 68: 90, 79: [1, 92] },
        { 7: 94, 33: $Vf, 52: $Vg, 64: 93, 79: [1, 95], 81: [1, 96], 82: 82, 83: 83, 84: $Vj, 85: 87, 86: $Vk, 88: $Vl, 89: $Vm },
        o($V9, [2, 71], { 74: 48, 75: 49, 76: 50, 73: 70, 77: $Vb, 80: $Vc }),
        { 22: [1, 97] },
        o($V5, [2, 129]),
        o($V5, [2, 130]),
        {
          7: 103,
          22: [1, 99],
          33: $Vf,
          36: 75,
          41: 98,
          42: 100,
          43: 102,
          44: [1, 101],
          47: 76,
          52: $Vg,
          64: 77,
          70: $Vh,
          80: $Vi,
          82: 82,
          83: 83,
          84: $Vj,
          85: 87,
          86: $Vk,
          88: $Vl,
          89: $Vm,
          90: 80,
        },
        { 7: 105, 26: 104, 33: $Vf },
        {
          7: 113,
          21: $Vo,
          28: 106,
          33: $Vf,
          36: 107,
          47: 108,
          48: 109,
          52: $Vp,
          62: 110,
          63: $Vq,
          64: 114,
          70: $Vh,
          80: $Vi,
          82: 82,
          83: 83,
          84: $Vj,
          85: 87,
          86: $Vk,
          88: $Vl,
          89: $Vm,
          90: 80,
        },
        {
          7: 113,
          21: $Vo,
          28: 116,
          33: $Vf,
          36: 107,
          47: 108,
          48: 109,
          52: $Vp,
          62: 110,
          63: $Vq,
          64: 114,
          70: $Vh,
          80: $Vi,
          82: 82,
          83: 83,
          84: $Vj,
          85: 87,
          86: $Vk,
          88: $Vl,
          89: $Vm,
          90: 80,
        },
        { 33: [1, 117] },
        { 33: [1, 118] },
        { 34: [1, 119] },
        { 67: 120, 71: $Vd, 72: $Ve, 73: 70, 74: 48, 75: 49, 76: 50, 77: $Vb, 80: $Vc },
        o($V9, [2, 73]),
        o($V9, [2, 78]),
        o($V9, [2, 79]),
        { 67: 121, 71: $Vd, 72: $Ve, 73: 70, 74: 48, 75: 49, 76: 50, 77: $Vb, 80: $Vc },
        o($V9, [2, 75]),
        o($Vn, [2, 81]),
        { 22: [1, 122], 45: $Vr },
        o($Vn, [2, 87]),
        o($Vs, [2, 88]),
        o([22, 45], $Vt),
        o($Vu, [2, 109]),
        o($Vu, [2, 110]),
        o($Vu, [2, 111]),
        { 34: $V6, 65: 25, 68: 27, 69: $V7, 70: $V8 },
        {
          7: 127,
          33: $Vf,
          36: 75,
          43: 73,
          47: 76,
          52: $Vg,
          64: 77,
          70: $Vh,
          78: 124,
          80: $Vi,
          81: [1, 125],
          82: 82,
          83: 83,
          84: $Vj,
          85: 126,
          86: $Vk,
          88: $Vl,
          89: $Vm,
          90: 80,
        },
        o($Vu, [2, 113]),
        { 72: [1, 129], 82: 130, 88: $Vl, 89: $Vm, 92: 128 },
        o($Vv, [2, 99]),
        o($Vv, [2, 100]),
        o($Vv, [2, 101]),
        o($Vw, [2, 107]),
        o($Vw, [2, 108]),
        o($Vv, $Vx),
        o($Vy, $Vz, { 87: [1, 131] }),
        { 86: $VA },
        o($Vn, [2, 85]),
        o($Vn, [2, 92], { 21: $Va }),
        o($Vn, [2, 93]),
        { 79: [1, 134], 81: [1, 133] },
        { 81: [1, 135] },
        o($Vn, [2, 97]),
        o($Vn, [2, 98]),
        o($V5, [2, 17]),
        { 22: [1, 136] },
        o($V5, [2, 34]),
        { 22: [2, 41], 44: [1, 137], 45: $VB },
        {
          7: 103,
          33: $Vf,
          36: 75,
          42: 139,
          43: 102,
          47: 76,
          52: $Vg,
          64: 77,
          70: $Vh,
          80: $Vi,
          82: 82,
          83: 83,
          84: $Vj,
          85: 87,
          86: $Vk,
          88: $Vl,
          89: $Vm,
          90: 80,
        },
        o($VC, [2, 35]),
        o($VC, [2, 36]),
        { 22: [1, 140] },
        { 46: [1, 141] },
        { 22: [1, 142] },
        { 22: [2, 46] },
        { 22: [2, 47] },
        {
          22: [2, 48],
          49: $VD,
          50: $VE,
          51: $VF,
          52: $VG,
          53: $VH,
          54: $VI,
          55: $VJ,
          56: $VK,
          57: $VL,
          58: $VM,
          59: $VN,
          60: $VO,
          61: $VP,
        },
        o($VQ, [2, 62]),
        { 21: $Vo, 62: 156, 86: $VA },
        {
          7: 113,
          21: $Vo,
          33: $Vf,
          48: 157,
          52: $Vp,
          62: 110,
          63: $Vq,
          64: 114,
          82: 82,
          83: 83,
          84: $Vj,
          85: 87,
          86: $Vk,
          88: $Vl,
          89: $Vm,
        },
        o($VQ, [2, 65]),
        o($VQ, [2, 66]),
        {
          7: 113,
          21: $Vo,
          33: $Vf,
          48: 158,
          52: $Vp,
          62: 110,
          63: $Vq,
          64: 114,
          82: 82,
          83: 83,
          84: $Vj,
          85: 87,
          86: $Vk,
          88: $Vl,
          89: $Vm,
        },
        { 22: [1, 159] },
        { 34: [1, 160] },
        { 34: [1, 161] },
        { 7: 164, 22: [1, 163], 33: $Vf, 40: 162 },
        o($V9, [2, 68]),
        o($V9, [2, 70]),
        o($Vn, [2, 86]),
        {
          7: 166,
          33: $Vf,
          36: 75,
          43: 165,
          47: 76,
          52: $Vg,
          64: 77,
          70: $Vh,
          80: $Vi,
          82: 82,
          83: 83,
          84: $Vj,
          85: 87,
          86: $Vk,
          88: $Vl,
          89: $Vm,
          90: 80,
        },
        { 45: $Vr, 81: [1, 167] },
        o($Vu, [2, 114]),
        o($VR, $Vx, { 91: [1, 168] }),
        o($VR, $Vt, { 91: [1, 169] }),
        { 45: [1, 171], 72: [1, 170] },
        o($Vu, [2, 120]),
        { 93: [1, 172] },
        { 86: [1, 173] },
        o($Vy, $VS, { 87: [1, 174] }),
        o($Vn, [2, 94]),
        o($Vn, [2, 96]),
        o($Vn, [2, 95]),
        o($V5, [2, 33]),
        {
          7: 176,
          22: [2, 44],
          33: $Vf,
          36: 75,
          43: 175,
          47: 76,
          52: $Vg,
          64: 77,
          70: $Vh,
          80: $Vi,
          82: 82,
          83: 83,
          84: $Vj,
          85: 87,
          86: $Vk,
          88: $Vl,
          89: $Vm,
          90: 80,
        },
        {
          7: 178,
          33: $Vf,
          36: 75,
          43: 177,
          47: 76,
          52: $Vg,
          64: 77,
          70: $Vh,
          80: $Vi,
          82: 82,
          83: 83,
          84: $Vj,
          85: 87,
          86: $Vk,
          88: $Vl,
          89: $Vm,
          90: 80,
        },
        { 22: [2, 42], 44: [1, 179], 45: $VB },
        o($V5, [2, 20]),
        {
          7: 113,
          21: $Vo,
          28: 180,
          33: $Vf,
          36: 107,
          47: 108,
          48: 109,
          52: $Vp,
          62: 110,
          63: $Vq,
          64: 114,
          70: $Vh,
          80: $Vi,
          82: 82,
          83: 83,
          84: $Vj,
          85: 87,
          86: $Vk,
          88: $Vl,
          89: $Vm,
          90: 80,
        },
        o($V5, [2, 21]),
        {
          7: 113,
          21: $Vo,
          33: $Vf,
          48: 181,
          52: $Vp,
          62: 110,
          63: $Vq,
          64: 114,
          82: 82,
          83: 83,
          84: $Vj,
          85: 87,
          86: $Vk,
          88: $Vl,
          89: $Vm,
        },
        {
          7: 113,
          21: $Vo,
          33: $Vf,
          48: 182,
          52: $Vp,
          62: 110,
          63: $Vq,
          64: 114,
          82: 82,
          83: 83,
          84: $Vj,
          85: 87,
          86: $Vk,
          88: $Vl,
          89: $Vm,
        },
        {
          7: 113,
          21: $Vo,
          33: $Vf,
          48: 183,
          52: $Vp,
          62: 110,
          63: $Vq,
          64: 114,
          82: 82,
          83: 83,
          84: $Vj,
          85: 87,
          86: $Vk,
          88: $Vl,
          89: $Vm,
        },
        {
          7: 113,
          21: $Vo,
          33: $Vf,
          48: 184,
          52: $Vp,
          62: 110,
          63: $Vq,
          64: 114,
          82: 82,
          83: 83,
          84: $Vj,
          85: 87,
          86: $Vk,
          88: $Vl,
          89: $Vm,
        },
        {
          7: 113,
          21: $Vo,
          33: $Vf,
          48: 185,
          52: $Vp,
          62: 110,
          63: $Vq,
          64: 114,
          82: 82,
          83: 83,
          84: $Vj,
          85: 87,
          86: $Vk,
          88: $Vl,
          89: $Vm,
        },
        {
          7: 113,
          21: $Vo,
          33: $Vf,
          48: 186,
          52: $Vp,
          62: 110,
          63: $Vq,
          64: 114,
          82: 82,
          83: 83,
          84: $Vj,
          85: 87,
          86: $Vk,
          88: $Vl,
          89: $Vm,
        },
        {
          7: 113,
          21: $Vo,
          33: $Vf,
          48: 187,
          52: $Vp,
          62: 110,
          63: $Vq,
          64: 114,
          82: 82,
          83: 83,
          84: $Vj,
          85: 87,
          86: $Vk,
          88: $Vl,
          89: $Vm,
        },
        {
          7: 113,
          21: $Vo,
          33: $Vf,
          48: 188,
          52: $Vp,
          62: 110,
          63: $Vq,
          64: 114,
          82: 82,
          83: 83,
          84: $Vj,
          85: 87,
          86: $Vk,
          88: $Vl,
          89: $Vm,
        },
        {
          7: 113,
          21: $Vo,
          33: $Vf,
          48: 189,
          52: $Vp,
          62: 110,
          63: $Vq,
          64: 114,
          82: 82,
          83: 83,
          84: $Vj,
          85: 87,
          86: $Vk,
          88: $Vl,
          89: $Vm,
        },
        {
          7: 113,
          21: $Vo,
          33: $Vf,
          48: 190,
          52: $Vp,
          62: 110,
          63: $Vq,
          64: 114,
          82: 82,
          83: 83,
          84: $Vj,
          85: 87,
          86: $Vk,
          88: $Vl,
          89: $Vm,
        },
        {
          7: 113,
          21: $Vo,
          33: $Vf,
          48: 191,
          52: $Vp,
          62: 110,
          63: $Vq,
          64: 114,
          82: 82,
          83: 83,
          84: $Vj,
          85: 87,
          86: $Vk,
          88: $Vl,
          89: $Vm,
        },
        {
          7: 113,
          21: $Vo,
          33: $Vf,
          48: 192,
          52: $Vp,
          62: 110,
          63: $Vq,
          64: 114,
          82: 82,
          83: 83,
          84: $Vj,
          85: 87,
          86: $Vk,
          88: $Vl,
          89: $Vm,
        },
        {
          7: 113,
          21: $Vo,
          33: $Vf,
          48: 193,
          52: $Vp,
          62: 110,
          63: $Vq,
          64: 114,
          82: 82,
          83: 83,
          84: $Vj,
          85: 87,
          86: $Vk,
          88: $Vl,
          89: $Vm,
        },
        o($VQ, [2, 63]),
        o($VQ, [2, 64]),
        {
          22: [1, 194],
          49: $VD,
          50: $VE,
          51: $VF,
          52: $VG,
          53: $VH,
          54: $VI,
          55: $VJ,
          56: $VK,
          57: $VL,
          58: $VM,
          59: $VN,
          60: $VO,
          61: $VP,
        },
        o($V5, [2, 22]),
        { 35: [1, 195] },
        { 22: [1, 196] },
        { 7: 198, 22: [1, 197], 33: $Vf },
        o($V5, [2, 30]),
        o($VT, [2, 31]),
        o($Vs, [2, 90]),
        o($Vs, [2, 91]),
        o($Vu, [2, 112]),
        { 7: 200, 33: $Vf, 52: $VU, 85: 199, 86: $VV },
        { 7: 204, 33: $Vf, 52: $VU, 85: 203, 86: $VV },
        o($Vu, [2, 119]),
        { 82: 205, 88: $Vl, 89: $Vm },
        o($VW, [2, 123], {
          36: 75,
          47: 76,
          64: 77,
          90: 80,
          82: 82,
          83: 83,
          85: 87,
          43: 206,
          7: 207,
          33: $Vf,
          52: $Vg,
          70: $Vh,
          80: $Vi,
          84: $Vj,
          86: $Vk,
          88: $Vl,
          89: $Vm,
        }),
        o($Vv, [2, 103]),
        { 86: [1, 208] },
        o($VC, [2, 37]),
        o($VC, [2, 40]),
        o($VC, [2, 38]),
        o($VC, [2, 39]),
        {
          7: 176,
          22: [2, 43],
          33: $Vf,
          36: 75,
          43: 175,
          47: 76,
          52: $Vg,
          64: 77,
          70: $Vh,
          80: $Vi,
          82: 82,
          83: 83,
          84: $Vj,
          85: 87,
          86: $Vk,
          88: $Vl,
          89: $Vm,
          90: 80,
        },
        { 22: [2, 45] },
        o($VX, [2, 49], { 51: $VF, 52: $VG, 53: $VH, 54: $VI, 55: $VJ, 56: $VK, 57: $VL, 58: $VM, 59: $VN, 60: $VO, 61: $VP }),
        o($VX, [2, 50], { 51: $VF, 52: $VG, 53: $VH, 54: $VI, 55: $VJ, 56: $VK, 57: $VL, 58: $VM, 59: $VN, 60: $VO, 61: $VP }),
        o($VY, [2, 51], { 53: $VH, 54: $VI, 55: $VJ }),
        o($VY, [2, 52], { 53: $VH, 54: $VI, 55: $VJ }),
        o($VQ, [2, 53]),
        o($VQ, [2, 54]),
        o($VQ, [2, 55]),
        o($VZ, [2, 56], { 51: $VF, 52: $VG, 53: $VH, 54: $VI, 55: $VJ }),
        o($VZ, [2, 57], { 51: $VF, 52: $VG, 53: $VH, 54: $VI, 55: $VJ }),
        o($VZ, [2, 58], { 51: $VF, 52: $VG, 53: $VH, 54: $VI, 55: $VJ }),
        o($VZ, [2, 59], { 51: $VF, 52: $VG, 53: $VH, 54: $VI, 55: $VJ }),
        o($VZ, [2, 60], { 51: $VF, 52: $VG, 53: $VH, 54: $VI, 55: $VJ }),
        o($VZ, [2, 61], { 51: $VF, 52: $VG, 53: $VH, 54: $VI, 55: $VJ }),
        o($VQ, [2, 67]),
        { 7: 209, 33: $Vf, 36: 210, 80: $Vi, 90: 80 },
        o($V5, [2, 28]),
        o($V5, [2, 29]),
        o($VT, [2, 32]),
        { 81: [1, 211] },
        { 81: [1, 212] },
        { 81: $Vz },
        { 86: [1, 213] },
        { 81: [1, 214] },
        { 81: [1, 215] },
        { 93: [1, 216] },
        o($VW, [2, 121]),
        o($VW, [2, 122]),
        o($Vv, [2, 104]),
        { 22: [1, 217] },
        { 22: [1, 218] },
        o($Vu, [2, 115]),
        o($Vu, [2, 117]),
        { 81: $VS },
        o($Vu, [2, 116]),
        o($Vu, [2, 118]),
        {
          7: 219,
          33: $Vf,
          36: 75,
          43: 220,
          47: 76,
          52: $Vg,
          64: 77,
          70: $Vh,
          80: $Vi,
          82: 82,
          83: 83,
          84: $Vj,
          85: 87,
          86: $Vk,
          88: $Vl,
          89: $Vm,
          90: 80,
        },
        o($V5, [2, 25]),
        o($V5, [2, 26]),
        o($VW, [2, 124]),
        o($VW, [2, 125]),
      ],
      defaultActions: {
        2: [2, 1],
        23: [2, 2],
        29: [2, 76],
        30: [2, 77],
        107: [2, 46],
        108: [2, 47],
        180: [2, 45],
        201: [2, 105],
        213: [2, 106],
      },
      parseError: function parseError(str, hash) {
        if (hash.recoverable) {
          this.trace(str);
        } else {
          throw new Error(str);
        }
      },
      parse: function parse(input) {
        var self = this,
          stack = [0],
          tstack = [],
          vstack = [null],
          lstack = [],
          table = this.table,
          yytext = '',
          yylineno = 0,
          yyleng = 0,
          recovering = 0,
          TERROR = 2,
          EOF = 1;
        var args = lstack.slice.call(arguments, 1);
        var lexer = Object.create(this.lexer);
        var sharedState = { yy: {} };
        for (var k in this.yy) {
          if (Object.prototype.hasOwnProperty.call(this.yy, k)) {
            sharedState.yy[k] = this.yy[k];
          }
        }
        lexer.setInput(input, sharedState.yy);
        sharedState.yy.lexer = lexer;
        sharedState.yy.parser = this;
        if (typeof lexer.yylloc == 'undefined') {
          lexer.yylloc = {};
        }
        var yyloc = lexer.yylloc;
        lstack.push(yyloc);
        var ranges = lexer.options && lexer.options.ranges;
        if (typeof sharedState.yy.parseError === 'function') {
          this.parseError = sharedState.yy.parseError;
        } else {
          this.parseError = Object.getPrototypeOf(this).parseError;
        }
        function popStack(n) {
          stack.length = stack.length - 2 * n;
          vstack.length = vstack.length - n;
          lstack.length = lstack.length - n;
        }
        _token_stack: function lex() {
          var token;
          token = lexer.lex() || EOF;
          if (typeof token !== 'number') {
            token = self.symbols_[token] || token;
          }
          return token;
        }
        var symbol,
          preErrorSymbol,
          state,
          action,
          a,
          r,
          yyval = {},
          p,
          len,
          newState,
          expected;
        while (true) {
          state = stack[stack.length - 1];
          if (this.defaultActions[state]) {
            action = this.defaultActions[state];
          } else {
            if (symbol === null || typeof symbol == 'undefined') {
              symbol = lex();
            }
            action = table[state] && table[state][symbol];
          }
          if (typeof action === 'undefined' || !action.length || !action[0]) {
            var errStr = '';
            expected = [];
            for (p in table[state]) {
              if (this.terminals_[p] && p > TERROR) {
                expected.push("'" + this.terminals_[p] + "'");
              }
            }
            if (lexer.showPosition) {
              errStr =
                'Parse error on line ' +
                (yylineno + 1) +
                ':\n' +
                lexer.showPosition() +
                '\nExpecting ' +
                expected.join(', ') +
                ", got '" +
                (this.terminals_[symbol] || symbol) +
                "'";
            } else {
              errStr =
                'Parse error on line ' +
                (yylineno + 1) +
                ': Unexpected ' +
                (symbol == EOF ? 'end of input' : "'" + (this.terminals_[symbol] || symbol) + "'");
            }
            this.parseError(errStr, {
              text: lexer.match,
              token: this.terminals_[symbol] || symbol,
              line: lexer.yylineno,
              loc: yyloc,
              expected: expected,
            });
          }
          if (action[0] instanceof Array && action.length > 1) {
            throw new Error('Parse Error: multiple actions possible at state: ' + state + ', token: ' + symbol);
          }
          switch (action[0]) {
            case 1:
              stack.push(symbol);
              vstack.push(lexer.yytext);
              lstack.push(lexer.yylloc);
              stack.push(action[1]);
              symbol = null;
              if (!preErrorSymbol) {
                yyleng = lexer.yyleng;
                yytext = lexer.yytext;
                yylineno = lexer.yylineno;
                yyloc = lexer.yylloc;
                if (recovering > 0) {
                  recovering--;
                }
              } else {
                symbol = preErrorSymbol;
                preErrorSymbol = null;
              }
              break;
            case 2:
              len = this.productions_[action[1]][1];
              yyval.$ = vstack[vstack.length - len];
              yyval._$ = {
                first_line: lstack[lstack.length - (len || 1)].first_line,
                last_line: lstack[lstack.length - 1].last_line,
                first_column: lstack[lstack.length - (len || 1)].first_column,
                last_column: lstack[lstack.length - 1].last_column,
              };
              if (ranges) {
                yyval._$.range = [lstack[lstack.length - (len || 1)].range[0], lstack[lstack.length - 1].range[1]];
              }
              r = this.performAction.apply(yyval, [yytext, yyleng, yylineno, sharedState.yy, action[1], vstack, lstack].concat(args));
              if (typeof r !== 'undefined') {
                return r;
              }
              if (len) {
                stack = stack.slice(0, -1 * len * 2);
                vstack = vstack.slice(0, -1 * len);
                lstack = lstack.slice(0, -1 * len);
              }
              stack.push(this.productions_[action[1]][0]);
              vstack.push(yyval.$);
              lstack.push(yyval._$);
              newState = table[stack[stack.length - 2]][stack[stack.length - 1]];
              stack.push(newState);
              break;
            case 3:
              return true;
          }
        }
        return true;
      },
    };
    /* generated by jison-lex 0.3.4 */
    var lexer = (function() {
      var lexer = {
        EOF: 1,

        parseError: function parseError(str, hash) {
          if (this.yy.parser) {
            this.yy.parser.parseError(str, hash);
          } else {
            throw new Error(str);
          }
        },

        // resets the lexer, sets new input
        setInput: function(input, yy) {
          this.yy = yy || this.yy || {};
          this._input = input;
          this._more = this._backtrack = this.done = false;
          this.yylineno = this.yyleng = 0;
          this.yytext = this.matched = this.match = '';
          this.conditionStack = ['INITIAL'];
          this.yylloc = {
            first_line: 1,
            first_column: 0,
            last_line: 1,
            last_column: 0,
          };
          if (this.options.ranges) {
            this.yylloc.range = [0, 0];
          }
          this.offset = 0;
          return this;
        },

        // consumes and returns one char from the input
        input: function() {
          var ch = this._input[0];
          this.yytext += ch;
          this.yyleng++;
          this.offset++;
          this.match += ch;
          this.matched += ch;
          var lines = ch.match(/(?:\r\n?|\n).*/g);
          if (lines) {
            this.yylineno++;
            this.yylloc.last_line++;
          } else {
            this.yylloc.last_column++;
          }
          if (this.options.ranges) {
            this.yylloc.range[1]++;
          }

          this._input = this._input.slice(1);
          return ch;
        },

        // unshifts one char (or a string) into the input
        unput: function(ch) {
          var len = ch.length;
          var lines = ch.split(/(?:\r\n?|\n)/g);

          this._input = ch + this._input;
          this.yytext = this.yytext.substr(0, this.yytext.length - len);
          //this.yyleng -= len;
          this.offset -= len;
          var oldLines = this.match.split(/(?:\r\n?|\n)/g);
          this.match = this.match.substr(0, this.match.length - 1);
          this.matched = this.matched.substr(0, this.matched.length - 1);

          if (lines.length - 1) {
            this.yylineno -= lines.length - 1;
          }
          var r = this.yylloc.range;

          this.yylloc = {
            first_line: this.yylloc.first_line,
            last_line: this.yylineno + 1,
            first_column: this.yylloc.first_column,
            last_column: lines
              ? (lines.length === oldLines.length ? this.yylloc.first_column : 0) +
                oldLines[oldLines.length - lines.length].length -
                lines[0].length
              : this.yylloc.first_column - len,
          };

          if (this.options.ranges) {
            this.yylloc.range = [r[0], r[0] + this.yyleng - len];
          }
          this.yyleng = this.yytext.length;
          return this;
        },

        // When called from action, caches matched text and appends it on next action
        more: function() {
          this._more = true;
          return this;
        },

        // When called from action, signals the lexer that this rule fails to match the input, so the next matching rule (regex) should be tested instead.
        reject: function() {
          if (this.options.backtrack_lexer) {
            this._backtrack = true;
          } else {
            return this.parseError(
              'Lexical error on line ' +
                (this.yylineno + 1) +
                '. You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).\n' +
                this.showPosition(),
              {
                text: '',
                token: null,
                line: this.yylineno,
              }
            );
          }
          return this;
        },

        // retain first n characters of the match
        less: function(n) {
          this.unput(this.match.slice(n));
        },

        // displays already matched input, i.e. for error messages
        pastInput: function() {
          var past = this.matched.substr(0, this.matched.length - this.match.length);
          return (past.length > 20 ? '...' : '') + past.substr(-20).replace(/\n/g, '');
        },

        // displays upcoming input, i.e. for error messages
        upcomingInput: function() {
          var next = this.match;
          if (next.length < 20) {
            next += this._input.substr(0, 20 - next.length);
          }
          return (next.substr(0, 20) + (next.length > 20 ? '...' : '')).replace(/\n/g, '');
        },

        // displays the character position where the lexing error occurred, i.e. for error messages
        showPosition: function() {
          var pre = this.pastInput();
          var c = new Array(pre.length + 1).join('-');
          return pre + this.upcomingInput() + '\n' + c + '^';
        },

        // test the lexed token: return FALSE when not a match, otherwise return token
        test_match: function(match, indexed_rule) {
          var token, lines, backup;

          if (this.options.backtrack_lexer) {
            // save context
            backup = {
              yylineno: this.yylineno,
              yylloc: {
                first_line: this.yylloc.first_line,
                last_line: this.last_line,
                first_column: this.yylloc.first_column,
                last_column: this.yylloc.last_column,
              },
              yytext: this.yytext,
              match: this.match,
              matches: this.matches,
              matched: this.matched,
              yyleng: this.yyleng,
              offset: this.offset,
              _more: this._more,
              _input: this._input,
              yy: this.yy,
              conditionStack: this.conditionStack.slice(0),
              done: this.done,
            };
            if (this.options.ranges) {
              backup.yylloc.range = this.yylloc.range.slice(0);
            }
          }

          lines = match[0].match(/(?:\r\n?|\n).*/g);
          if (lines) {
            this.yylineno += lines.length;
          }
          this.yylloc = {
            first_line: this.yylloc.last_line,
            last_line: this.yylineno + 1,
            first_column: this.yylloc.last_column,
            last_column: lines
              ? lines[lines.length - 1].length - lines[lines.length - 1].match(/\r?\n?/)[0].length
              : this.yylloc.last_column + match[0].length,
          };
          this.yytext += match[0];
          this.match += match[0];
          this.matches = match;
          this.yyleng = this.yytext.length;
          if (this.options.ranges) {
            this.yylloc.range = [this.offset, (this.offset += this.yyleng)];
          }
          this._more = false;
          this._backtrack = false;
          this._input = this._input.slice(match[0].length);
          this.matched += match[0];
          token = this.performAction.call(this, this.yy, this, indexed_rule, this.conditionStack[this.conditionStack.length - 1]);
          if (this.done && this._input) {
            this.done = false;
          }
          if (token) {
            return token;
          } else if (this._backtrack) {
            // recover context
            for (var k in backup) {
              this[k] = backup[k];
            }
            return false; // rule action called reject() implying the next rule should be tested instead.
          }
          return false;
        },

        // return next match in input
        next: function() {
          if (this.done) {
            return this.EOF;
          }
          if (!this._input) {
            this.done = true;
          }

          var token, match, tempMatch, index;
          if (!this._more) {
            this.yytext = '';
            this.match = '';
          }
          var rules = this._currentRules();
          for (var i = 0; i < rules.length; i++) {
            tempMatch = this._input.match(this.rules[rules[i]]);
            if (tempMatch && (!match || tempMatch[0].length > match[0].length)) {
              match = tempMatch;
              index = i;
              if (this.options.backtrack_lexer) {
                token = this.test_match(tempMatch, rules[i]);
                if (token !== false) {
                  return token;
                } else if (this._backtrack) {
                  match = false;
                  continue; // rule action called reject() implying a rule MISmatch.
                } else {
                  // else: this is a lexer rule which consumes input without producing a token (e.g. whitespace)
                  return false;
                }
              } else if (!this.options.flex) {
                break;
              }
            }
          }
          if (match) {
            token = this.test_match(match, rules[index]);
            if (token !== false) {
              return token;
            }
            // else: this is a lexer rule which consumes input without producing a token (e.g. whitespace)
            return false;
          }
          if (this._input === '') {
            return this.EOF;
          } else {
            return this.parseError('Lexical error on line ' + (this.yylineno + 1) + '. Unrecognized text.\n' + this.showPosition(), {
              text: '',
              token: null,
              line: this.yylineno,
            });
          }
        },

        // return next match that has a token
        lex: function lex() {
          var r = this.next();
          if (r) {
            return r;
          } else {
            return this.lex();
          }
        },

        // activates a new lexer condition state (pushes the new lexer condition state onto the condition stack)
        begin: function begin(condition) {
          this.conditionStack.push(condition);
        },

        // pop the previously active lexer condition state off the condition stack
        popState: function popState() {
          var n = this.conditionStack.length - 1;
          if (n > 0) {
            return this.conditionStack.pop();
          } else {
            return this.conditionStack[0];
          }
        },

        // produce the lexer rule set which is active for the currently active lexer condition state
        _currentRules: function _currentRules() {
          if (this.conditionStack.length && this.conditionStack[this.conditionStack.length - 1]) {
            return this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules;
          } else {
            return this.conditions['INITIAL'].rules;
          }
        },

        // return the currently active lexer condition state; when an index argument is provided it produces the N-th previous condition state, if available
        topState: function topState(n) {
          n = this.conditionStack.length - 1 - Math.abs(n || 0);
          if (n >= 0) {
            return this.conditionStack[n];
          } else {
            return 'INITIAL';
          }
        },

        // alias for begin(condition)
        pushState: function pushState(condition) {
          this.begin(condition);
        },

        // return the number of states currently on the stack
        stateStackSize: function stateStackSize() {
          return this.conditionStack.length;
        },
        options: {},
        performAction: function anonymous(yy, yy_, $avoiding_name_collisions, YY_START) {
          var YYSTATE = YY_START;
          switch ($avoiding_name_collisions) {
            case 0:
              var _reg = /\\+$/;
              var _esc = yy_.yytext.match(_reg);
              var _num = _esc ? _esc[0].length : null;
              /*转义实现，非常恶心，暂时没有好的解决方案*/
              if (!_num || !(_num % 2)) {
                this.begin('mu');
              } else {
                yy_.yytext = yy_.yytext.replace(/\\$/, '');
                this.begin('esc');
              }
              if (_num > 1) yy_.yytext = yy_.yytext.replace(/(\\\\)+$/, '\\');
              if (yy_.yytext) return 79;

              break;
            case 1:
              var _reg = /\\+$/;
              var _esc = yy_.yytext.match(_reg);
              var _num = _esc ? _esc[0].length : null;
              if (!_num || !(_num % 2)) {
                this.begin('h');
              } else {
                yy_.yytext = yy_.yytext.replace(/\\$/, '');
                this.begin('esc');
              }
              if (_num > 1) yy_.yytext = yy_.yytext.replace(/(\\\\)+$/, '\\');
              if (yy_.yytext) return 79;

              break;
            case 2:
              return 79;
              break;
            case 3:
              this.popState();
              return 10;
              break;
            case 4:
              this.popState();
              yy_.yytext = yy_.yytext.replace(/^#\[\[|\]\]#$/g, '');
              return 79;
              break;
            case 5:
              this.popState();
              return 10;
              break;
            case 6:
              return 19;
              break;
            case 7:
              return 25;
              break;
            case 8:
              return 27;
              break;
            case 9:
              return 29;
              break;
            case 10:
              this.popState();
              return 30;
              break;
            case 11:
              this.popState();
              return 30;
              break;
            case 12:
              this.popState();
              return 31;
              break;
            case 13:
              this.popState();
              return 37;
              break;
            case 14:
              return 32;
              break;
            case 15:
              return 20;
              break;
            case 16:
              return 38;
              break;
            case 17:
              return 39;
              break;
            case 18:
              return 35;
              break;
            case 19:
              return yy_.yytext;
              break;
            case 20:
              return yy_.yytext;
              break;
            case 21:
              return yy_.yytext;
              break;
            case 22:
              return yy_.yytext;
              break;
            case 23:
              return yy_.yytext;
              break;
            case 24:
              return yy_.yytext;
              break;
            case 25:
              return yy_.yytext;
              break;
            case 26:
              return yy_.yytext;
              break;
            case 27:
              return 33;
              break;
            case 28:
              return 33;
              break;
            case 29:
              return yy_.yytext;
              break;
            case 30:
              return 46;
              break;
            case 31:
              var len = this.stateStackSize();
              if (len >= 2 && this.topState() === 'c' && this.topState(1) === 'run') {
                return 44;
              }

              break;
            case 32 /*ignore whitespace*/:
              break;
            case 33:
              return 70;
              break;
            case 34:
              return 72;
              break;
            case 35:
              return 93;
              break;
            case 36:
              yy.begin = true;
              return 69;
              break;
            case 37:
              this.popState();
              if (yy.begin === true) {
                yy.begin = false;
                return 71;
              } else {
                return 79;
              }
              break;
            case 38:
              this.begin('c');
              return 21;
              break;
            case 39:
              if (this.popState() === 'c') {
                var len = this.stateStackSize();

                if (this.topState() === 'run') {
                  this.popState();
                  len = len - 1;
                }

                var tailStack = this.topState(len - 2);
                /** 遇到#set(a = b)括号结束后结束状态h*/
                if (len === 2 && tailStack === 'h') {
                  this.popState();
                } else if (len === 3 && tailStack === 'mu' && this.topState(len - 3) === 'h') {
                  // issue#7 $foo#if($a)...#end
                  this.popState();
                  this.popState();
                }

                return 22;
              } else {
                return 79;
              }

              break;
            case 40:
              this.begin('i');
              return 80;
              break;
            case 41:
              if (this.popState() === 'i') {
                return 81;
              } else {
                return 79;
              }

              break;
            case 42:
              return 91;
              break;
            case 43:
              return 77;
              break;
            case 44:
              return 87;
              break;
            case 45:
              return 45;
              break;
            case 46:
              yy_.yytext = yy_.yytext.substr(1, yy_.yyleng - 2).replace(/\\"/g, '"');
              return 89;
              break;
            case 47:
              yy_.yytext = yy_.yytext.substr(1, yy_.yyleng - 2).replace(/\\'/g, "'");
              return 88;
              break;
            case 48:
              return 84;
              break;
            case 49:
              return 84;
              break;
            case 50:
              return 84;
              break;
            case 51:
              return 86;
              break;
            case 52:
              return 34;
              break;
            case 53:
              this.begin('run');
              return 34;
              break;
            case 54:
              this.begin('h');
              return 19;
              break;
            case 55:
              this.popState();
              return 79;
              break;
            case 56:
              this.popState();
              return 79;
              break;
            case 57:
              this.popState();
              return 79;
              break;
            case 58:
              this.popState();
              return 4;
              break;
            case 59:
              return 4;
              break;
          }
        },
        rules: [
          /^(?:[^#]*?(?=\$))/,
          /^(?:[^\$]*?(?=#))/,
          /^(?:[^\x00]+)/,
          /^(?:#\*[\s\S]+?\*#)/,
          /^(?:#\[\[[\s\S]+?\]\]#)/,
          /^(?:##[^\n]+)/,
          /^(?:#(?=[a-zA-Z{]))/,
          /^(?:set[ ]*)/,
          /^(?:if[ ]*)/,
          /^(?:elseif[ ]*)/,
          /^(?:else\b)/,
          /^(?:\{else\})/,
          /^(?:end\b)/,
          /^(?:break\b)/,
          /^(?:foreach[ ]*)/,
          /^(?:noescape\b)/,
          /^(?:define[ ]*)/,
          /^(?:macro[ ]*)/,
          /^(?:in\b)/,
          /^(?:[%\+\-\*/])/,
          /^(?:<=)/,
          /^(?:>=)/,
          /^(?:[><])/,
          /^(?:==)/,
          /^(?:\|\|)/,
          /^(?:&&)/,
          /^(?:!=)/,
          /^(?:\$!(?=[{a-zA-Z_]))/,
          /^(?:\$(?=[{a-zA-Z_]))/,
          /^(?:!)/,
          /^(?:=)/,
          /^(?:[ ]+(?=[^,]))/,
          /^(?:\s+)/,
          /^(?:\{)/,
          /^(?:\})/,
          /^(?::[\s]*)/,
          /^(?:\{)/,
          /^(?:\})/,
          /^(?:\([\s]*(?=[$'"\[\{\-0-9\w()!]))/,
          /^(?:\))/,
          /^(?:\[[\s]*(?=[\-$"'0-9{\[\]]+))/,
          /^(?:\])/,
          /^(?:\.\.)/,
          /^(?:\.(?=[a-zA-Z_]))/,
          /^(?:\.(?=[\d]))/,
          /^(?:,[ ]*)/,
          /^(?:"(\\"|[^\"])*")/,
          /^(?:'(\\'|[^\'])*')/,
          /^(?:null\b)/,
          /^(?:false\b)/,
          /^(?:true\b)/,
          /^(?:[0-9]+)/,
          /^(?:[_a-zA-Z][a-zA-Z0-9_\-]*)/,
          /^(?:[_a-zA-Z][a-zA-Z0-9_\-]*[ ]*(?=\())/,
          /^(?:#)/,
          /^(?:.)/,
          /^(?:\s+)/,
          /^(?:[\$#])/,
          /^(?:$)/,
          /^(?:$)/,
        ],
        conditions: {
          mu: { rules: [5, 27, 28, 36, 37, 38, 39, 40, 41, 43, 52, 54, 55, 56, 58], inclusive: false },
          c: {
            rules: [
              18,
              19,
              20,
              21,
              22,
              23,
              24,
              25,
              26,
              27,
              28,
              29,
              30,
              31,
              32,
              33,
              34,
              35,
              38,
              39,
              40,
              41,
              43,
              44,
              45,
              46,
              47,
              48,
              49,
              50,
              51,
              52,
            ],
            inclusive: false,
          },
          i: {
            rules: [
              18,
              19,
              20,
              21,
              22,
              23,
              24,
              25,
              26,
              27,
              28,
              29,
              30,
              32,
              33,
              33,
              34,
              34,
              35,
              38,
              39,
              40,
              41,
              42,
              43,
              44,
              45,
              46,
              47,
              48,
              49,
              50,
              51,
              52,
            ],
            inclusive: false,
          },
          h: {
            rules: [3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 27, 28, 29, 30, 35, 38, 39, 40, 41, 43, 51, 53, 55, 56, 58],
            inclusive: false,
          },
          esc: { rules: [57], inclusive: false },
          run: {
            rules: [27, 28, 29, 31, 32, 33, 34, 35, 38, 39, 40, 41, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 55, 56, 58],
            inclusive: false,
          },
          INITIAL: { rules: [0, 1, 2, 59], inclusive: true },
        },
      };
      return lexer;
    })();
    parser.lexer = lexer;
    function Parser() {
      this.yy = {};
    }
    Parser.prototype = parser;
    parser.Parser = Parser;
    return new Parser();
  })();

  if (typeof require !== 'undefined' && typeof exports !== 'undefined') {
    exports.parser = parser;
    exports.Parser = parser.Parser;
    exports.parse = function() {
      return parser.parse.apply(parser, arguments);
    };
    exports.main = function commonjsMain(args) {
      if (!args[1]) {
        console.log('Usage: ' + args[0] + ' FILE');
        process.exit(1);
      }
      var source = require('fs').readFileSync(require('path').normalize(args[1]), 'utf8');
      return exports.parser.parse(source);
    };
    if (typeof module !== 'undefined' && require.main === module) {
      exports.main(process.argv.slice(1));
    }
  }
});
define('velocityjs/0.4.10/src/utils-debug', [], function(require, exports, module) {
  'use strict';
  var utils = {};

  ['forEach', 'some', 'every', 'filter', 'map'].forEach(function(fnName) {
    utils[fnName] = function(arr, fn, context) {
      if (!arr || typeof arr == 'string') return arr;
      context = context || this;
      if (arr[fnName]) {
        return arr[fnName](fn, context);
      } else {
        var keys = Object.keys(arr);
        return keys[fnName](function(key) {
          return fn.call(context, arr[key], key, arr);
        }, context);
      }
    };
  });

  var number = 0;
  utils.guid = function() {
    return number++;
  };

  utils.mixin = function(to, from) {
    utils.forEach(from, function(val, key) {
      var toString = {}.toString.call(val);
      if (utils.isArray(val) || utils.isObject(val)) {
        to[key] = utils.mixin(val, to[key] || {});
      } else {
        to[key] = val;
      }
    });
    return to;
  };

  utils.isArray = function(obj) {
    return {}.toString.call(obj) === '[object Array]';
  };

  utils.isObject = function(obj) {
    return {}.toString.call(obj) === '[object Object]';
  };

  utils.indexOf = function(elem, arr) {
    if (utils.isArray(arr)) {
      return arr.indexOf(elem);
    }
  };

  utils.keys = Object.keys;
  utils.now = Date.now;

  function makeLevel(block, index) {
    var blockTypes = {
      if: 1,
      foreach: 1,
      macro: 1,
      noescape: 1,
      define: 1,
    };

    var len = block.length;
    index = index || 0;
    var ret = [];
    var ignore = index - 1;

    for (var i = index; i < len; i++) {
      if (i <= ignore) continue;

      var ast = block[i];
      var type = ast.type;

      if (!blockTypes[type] && type !== 'end') {
        ret.push(ast);
      } else if (type === 'end') {
        return { arr: ret, step: i };
      } else {
        var _ret = makeLevel(block, i + 1);
        ignore = _ret.step;
        _ret.arr.unshift(block[i]);
        ret.push(_ret.arr);
      }
    }

    return ret;
  }

  utils.makeLevel = makeLevel;

  module.exports = utils;
});
define('velocityjs/0.4.10/src/compile/index-debug', [], function(require, exports, module) {
  var utils = require('velocityjs/0.4.10/src/utils-debug');
  var Helper = require('velocityjs/0.4.10/src/helper/index-debug');
  function Velocity(asts, config) {
    this.asts = asts;
    this.config = {
      // 自动输出为经过html encode输出
      escape: true,
      // 不需要转义的白名单
      unescape: {},
    };
    utils.mixin(this.config, config);
    this.init();
  }

  Velocity.Helper = Helper;
  Velocity.prototype = {
    constructor: Velocity,
  };

  require('velocityjs/0.4.10/src/compile/blocks-debug')(Velocity, utils);
  require('velocityjs/0.4.10/src/compile/literal-debug')(Velocity, utils);
  require('velocityjs/0.4.10/src/compile/references-debug')(Velocity, utils);
  require('velocityjs/0.4.10/src/compile/set-debug')(Velocity, utils);
  require('velocityjs/0.4.10/src/compile/expression-debug')(Velocity, utils);
  require('velocityjs/0.4.10/src/compile/compile-debug')(Velocity, utils);
  module.exports = Velocity;
});
define('velocityjs/0.4.10/src/helper/index-debug', [], function(require, exports, module) {
  var Helper = {};
  var utils = require('velocityjs/0.4.10/src/utils-debug');
  require('velocityjs/0.4.10/src/helper/text-debug')(Helper, utils);
  module.exports = Helper;
});
define('velocityjs/0.4.10/src/helper/text-debug', [], function(require, exports, module) {
  module.exports = function(Helper, utils) {
    /**
     * 获取引用文本，当引用自身不存在的情况下，需要返回原来的模板字符串
     */
    function getRefText(ast) {
      var ret = ast.leader;
      var isFn = ast.args !== undefined;

      if (ast.type === 'macro_call') {
        ret = '#';
      }

      if (ast.isWraped) ret += '{';

      if (isFn) {
        ret += getMethodText(ast);
      } else {
        ret += ast.id;
      }

      utils.forEach(
        ast.path,
        function(ref) {
          //不支持method并且传递参数
          if (ref.type == 'method') {
            ret += '.' + getMethodText(ref);
          } else if (ref.type == 'index') {
            var text = '';
            var id = ref.id;

            if (id.type === 'integer') {
              text = id.value;
            } else if (id.type === 'string') {
              var sign = id.isEval ? '"' : "'";
              text = sign + id.value + sign;
            } else {
              text = getRefText(id);
            }

            ret += '[' + text + ']';
          } else if (ref.type == 'property') {
            ret += '.' + ref.id;
          }
        },
        this
      );

      if (ast.isWraped) ret += '}';

      return ret;
    }

    function getMethodText(ref) {
      var args = [];
      var ret = '';

      utils.forEach(ref.args, function(arg) {
        args.push(getLiteral(arg));
      });

      ret += ref.id + '(' + args.join(',') + ')';

      return ret;
    }

    function getLiteral(ast) {
      var ret = '';

      switch (ast.type) {
        case 'string': {
          var sign = ast.isEval ? '"' : "'";
          ret = sign + ast.value + sign;
          break;
        }

        case 'integer':
        case 'bool': {
          ret = ast.value;
          break;
        }

        case 'array': {
          ret = '[';
          var len = ast.value.length - 1;
          utils.forEach(ast.value, function(arg, i) {
            ret += getLiteral(arg);
            if (i !== len) ret += ', ';
          });
          ret += ']';
          break;
        }

        default:
          ret = getRefText(ast);
      }

      return ret;
    }

    Helper.getRefText = getRefText;
  };
});
define('velocityjs/0.4.10/src/compile/blocks-debug', [], function(require, exports, module) {
  module.exports = function(Velocity, utils) {
    /**
     * blocks语法处理
     */
    utils.mixin(Velocity.prototype, {
      /**
       * 处理代码库: if foreach macro
       */
      getBlock: function(block) {
        var ast = block[0];
        var ret = '';

        switch (ast.type) {
          case 'if':
            ret = this.getBlockIf(block);
            break;
          case 'foreach':
            ret = this.getBlockEach(block);
            break;
          case 'macro':
            this.setBlockMacro(block);
            break;
          case 'noescape':
            ret = this._render(block.slice(1));
            break;
          case 'define':
            this.setBlockDefine(block);
            break;
          default:
            ret = this._render(block);
        }

        return ret || '';
      },

      /**
       * define
       */
      setBlockDefine: function(block) {
        var ast = block[0];
        var _block = block.slice(1);
        var defines = this.defines;

        defines[ast.id] = _block;
      },

      /**
       * define macro
       */
      setBlockMacro: function(block) {
        var ast = block[0];
        var _block = block.slice(1);
        var macros = this.macros;

        macros[ast.id] = {
          asts: _block,
          args: ast.args,
        };
      },

      /**
       * parse macro call
       */
      getMacro: function(ast) {
        var macro = this.macros[ast.id];
        var ret = '';

        if (!macro) {
          var jsmacros = this.jsmacros;
          macro = jsmacros[ast.id];
          var jsArgs = [];

          if (macro && macro.apply) {
            utils.forEach(
              ast.args,
              function(a) {
                jsArgs.push(this.getLiteral(a));
              },
              this
            );

            try {
              ret = macro.apply(this, jsArgs);
            } catch (e) {
              var pos = ast.pos;
              var text = Velocity.Helper.getRefText(ast);
              // throws error tree
              var err = '\n      at ' + text + ' L/N ' + pos.first_line + ':' + pos.first_column;
              e.name = '';
              e.message += err;
              throw new Error(e);
            }
          }
        } else {
          var asts = macro.asts;
          var args = macro.args;
          var _call_args = ast.args;
          var local = {};
          var localKey = [];
          var guid = utils.guid();
          var contextId = 'macro:' + ast.id + ':' + guid;

          utils.forEach(
            args,
            function(ref, i) {
              if (_call_args[i]) {
                local[ref.id] = this.getLiteral(_call_args[i]);
              } else {
                local[ref.id] = undefined;
              }
            },
            this
          );

          ret = this.eval(asts, local, contextId);
        }

        return ret;
      },

      /**
       * eval
       * @param str {array|string} 需要解析的字符串
       * @param local {object} 局部变量
       * @param contextId {string}
       * @return {string}
       */
      eval: function(str, local, contextId) {
        if (!local) {
          if (utils.isArray(str)) {
            return this._render(str);
          } else {
            return this.evalStr(str);
          }
        } else {
          var asts = [];
          var Parser = Velocity.Parser;
          contextId = contextId || 'eval:' + utils.guid();

          if (utils.isArray(str)) {
            asts = str;
          } else if (Parser) {
            asts = Parser.parse(str);
          }

          if (asts.length) {
            this.local[contextId] = local;
            var ret = this._render(asts, contextId);
            this.local[contextId] = {};
            this.conditions.shift();
            this.condition = this.conditions[0] || '';

            return ret;
          }
        }
      },

      /**
       * parse #foreach
       */
      getBlockEach: function(block) {
        var ast = block[0];
        var _from = this.getLiteral(ast.from);
        var _block = block.slice(1);
        var _to = ast.to;
        var local = {
          foreach: {
            count: 0,
          },
        };
        var ret = '';
        var guid = utils.guid();
        var contextId = 'foreach:' + guid;

        var type = {}.toString.call(_from);
        if (!_from || (type !== '[object Array]' && type !== '[object Object]')) return;

        var len = utils.isArray(_from) ? _from.length : utils.keys(_from).length;

        utils.forEach(
          _from,
          function(val, i) {
            if (this.setBreak) return;
            //构造临时变量
            local[_to] = val;
            //TODO: here, the foreach variable give to local, when _from is not an
            //array, count and hasNext would be undefined, also i is not the
            //index.
            local['foreach']['count'] = i + 1;
            local['foreach']['index'] = i;
            local['foreach']['hasNext'] = i + 1 < len;
            local['velocityCount'] = i + 1;
            this.local[contextId] = local;
            ret += this._render(_block, contextId);
          },
          this
        );

        this.setBreak = false;
        //删除临时变量
        this.local[contextId] = {};
        this.conditions.shift();
        this.condition = this.conditions[0] || '';

        return ret;
      },

      /**
       * parse #if
       */
      getBlockIf: function(block) {
        var str = '';
        var received = false;
        var asts = [];

        utils.some(
          block,
          function(ast) {
            if (ast.condition) {
              if (received) return true;
              received = this.getExpression(ast.condition);
            } else if (ast.type === 'else') {
              if (received) return true;
              received = true;
            } else if (received) {
              asts.push(ast);
            }

            return false;
          },
          this
        );

        return this._render(asts);
      },
    });
  };
});
define('velocityjs/0.4.10/src/compile/literal-debug', [], function(require, exports, module) {
  module.exports = function(Velocity, utils) {
    /**
     * literal解释模块
     * @require {method} getReferences
     */
    utils.mixin(Velocity.prototype, {
      /**
       * 字面量求值，主要包括string, integer, array, map四种数据结构
       * @param literal {object} 定义于velocity.yy文件，type描述数据类型，value属性
       * 是literal值描述
       * @return {object|string|number|array}返回对应的js变量
       */
      getLiteral: function(literal) {
        var type = literal.type;
        var ret = '';

        if (type == 'string') {
          ret = this.getString(literal);
        } else if (type == 'integer') {
          ret = parseInt(literal.value, 10);
        } else if (type == 'decimal') {
          ret = parseFloat(literal.value, 10);
        } else if (type == 'array') {
          ret = this.getArray(literal);
        } else if (type == 'map') {
          ret = {};
          var map = literal.value;

          utils.forEach(
            map,
            function(exp, key) {
              ret[key] = this.getLiteral(exp);
            },
            this
          );
        } else if (type == 'bool') {
          if (literal.value === 'null') {
            ret = null;
          } else if (literal.value === 'false') {
            ret = false;
          } else if (literal.value === 'true') {
            ret = true;
          }
        } else {
          return this.getReferences(literal);
        }

        return ret;
      },

      /**
       * 对字符串求值，对已双引号字符串，需要做变量替换
       */
      getString: function(literal) {
        var val = literal.value;
        var ret = val;

        if (literal.isEval && (val.indexOf('#') !== -1 || val.indexOf('$') !== -1)) {
          ret = this.evalStr(val);
        }

        return ret;
      },

      /**
       * 对array字面量求值，比如[1, 2]=> [1,2]，[1..5] => [1,2,3,4,5]
       * @param literal {object} array字面量的描述对象，分为普通数组和range数组两种
       * ，和js基本一致
       * @return {array} 求值得到的数组
       */
      getArray: function(literal) {
        var ret = [];

        if (literal.isRange) {
          var begin = literal.value[0];
          if (begin.type === 'references') {
            begin = this.getReferences(begin);
          }

          var end = literal.value[1];
          if (end.type === 'references') {
            end = this.getReferences(end);
          }

          end = parseInt(end, 10);
          begin = parseInt(begin, 10);

          var i;

          if (!isNaN(begin) && !isNaN(end)) {
            if (begin < end) {
              for (i = begin; i <= end; i++) ret.push(i);
            } else {
              for (i = begin; i >= end; i--) ret.push(i);
            }
          }
        } else {
          utils.forEach(
            literal.value,
            function(exp) {
              ret.push(this.getLiteral(exp));
            },
            this
          );
        }

        return ret;
      },

      /**
       * 对双引号字符串进行eval求值，替换其中的变量，只支持最基本的变量类型替换
       */
      evalStr: function(str) {
        var asts = Velocity.Parser.parse(str);
        return this._render(asts);
      },
    });
  };
});
define('velocityjs/0.4.10/src/compile/references-debug', [], function(require, exports, module) {
  module.exports = function(Velocity, utils) {
    'use strict';

    function getSize(obj) {
      if (utils.isArray(obj)) {
        return obj.length;
      } else if (utils.isObject(obj)) {
        return utils.keys(obj).length;
      }

      return undefined;
    }

    /**
     * unicode转码
     */
    function convert(str) {
      if (typeof str !== 'string') return str;

      var result = '';
      var escape = false;
      var i, c, cstr;

      for (i = 0; i < str.length; i++) {
        c = str.charAt(i);
        if ((' ' <= c && c <= '~') || c == '\r' || c == '\n') {
          if (c == '&') {
            cstr = '&amp;';
            escape = true;
          } else if (c == '<') {
            cstr = '&lt;';
            escape = true;
          } else if (c == '>') {
            cstr = '&gt;';
            escape = true;
          } else {
            cstr = c.toString();
          }
        } else {
          cstr = '&#' + c.charCodeAt().toString() + ';';
        }

        result = result + cstr;
      }

      return escape ? result : str;
    }

    utils.mixin(Velocity.prototype, {
      //增加某些函数，不需要执行html转义
      addIgnoreEscpape: function(key) {
        if (!utils.isArray(key)) key = [key];

        utils.forEach(
          key,
          function(key) {
            this.config.unescape[key] = true;
          },
          this
        );
      },

      /**
       * 引用求值
       * @param {object} ast 结构来自velocity.yy
       * @param {bool} isVal 取值还是获取字符串，两者的区别在于，求值返回结果，求
       * 字符串，如果没有返回变量自身，比如$foo
       */
      getReferences: function(ast, isVal) {
        if (ast.prue) {
          var define = this.defines[ast.id];
          if (utils.isArray(define)) {
            return this._render(define);
          }
          if (ast.id in this.config.unescape) ast.prue = false;
        }
        var escape = this.config.escape;

        var isSilent = this.silence || ast.leader === '$!';
        var isfn = ast.args !== undefined;
        var context = this.context;
        var ret = context[ast.id];
        var local = this.getLocal(ast);

        var text = Velocity.Helper.getRefText(ast);

        if (text in context) {
          return ast.prue && escape ? convert(context[text]) : context[text];
        }

        if (ret !== undefined && isfn) {
          ret = this.getPropMethod(ast, context, ast);
        }

        if (local.isLocaled) ret = local['value'];

        if (ast.path && ret !== undefined) {
          utils.some(
            ast.path,
            function(property) {
              //第三个参数，返回后面的参数ast
              ret = this.getAttributes(property, ret, ast);
            },
            this
          );
        }

        if (isVal && ret === undefined) {
          ret = isSilent ? '' : Velocity.Helper.getRefText(ast);
        }

        ret = ast.prue && escape ? convert(ret) : ret;

        return ret;
      },

      /**
       * 获取局部变量，在macro和foreach循环中使用
       */
      getLocal: function(ast) {
        var id = ast.id;
        var local = this.local;
        var ret = false;

        var isLocaled = utils.some(
          this.conditions,
          function(contextId) {
            var _local = local[contextId];
            if (id in _local) {
              ret = _local[id];
              return true;
            }

            return false;
          },
          this
        );

        return {
          value: ret,
          isLocaled: isLocaled,
        };
      },
      /**
       * $foo.bar 属性求值，最后面两个参数在用户传递的函数中用到
       * @param {object} property 属性描述，一个对象，主要包括id，type等定义
       * @param {object} baseRef 当前执行链结果，比如$a.b.c，第一次baseRef是$a,
       * 第二次是$a.b返回值
       * @private
       */
      getAttributes: function(property, baseRef, ast) {
        /**
         * type对应着velocity.yy中的attribute，三种类型: method, index, property
         */
        var type = property.type;
        var ret;
        var id = property.id;
        if (type === 'method') {
          ret = this.getPropMethod(property, baseRef, ast);
        } else if (type === 'property') {
          ret = baseRef[id];
        } else {
          ret = this.getPropIndex(property, baseRef);
        }
        return ret;
      },

      /**
       * $foo.bar[1] index求值
       * @private
       */
      getPropIndex: function(property, baseRef) {
        var ast = property.id;
        var key;
        if (ast.type === 'references') {
          key = this.getReferences(ast);
        } else if (ast.type === 'integer') {
          key = ast.value;
        } else {
          key = ast.value;
        }

        return baseRef[key];
      },

      /**
       * $foo.bar()求值
       */
      getPropMethod: function(property, baseRef, ast) {
        var id = property.id;
        var ret = '';
        var _id = id.slice(3);

        // getter 处理
        if (id.indexOf('get') === 0 && !(id in baseRef)) {
          if (_id) {
            ret = baseRef[_id];
          } else {
            //map 对应的get方法
            _id = this.getLiteral(property.args[0]);
            ret = baseRef[_id];
          }

          return ret;

          // setter 处理
        } else if (id.indexOf('set') === 0 && !baseRef[id]) {
          baseRef[_id] = this.getLiteral(property.args[0]);
          // $page.setName(123)
          baseRef.toString = function() {
            return '';
          };
          return baseRef;
        } else if (id.indexOf('is') === 0 && !(id in baseRef)) {
          _id = id.slice(2);
          ret = baseRef[_id];
          return ret;
        } else if (id === 'keySet') {
          return utils.keys(baseRef);
        } else if (id === 'entrySet') {
          ret = [];
          utils.forEach(baseRef, function(value, key) {
            ret.push({ key: key, value: value });
          });

          return ret;
        } else if (id === 'size') {
          return getSize(baseRef);
        } else {
          ret = baseRef[id];
          var args = [];

          utils.forEach(
            property.args,
            function(exp) {
              args.push(this.getLiteral(exp));
            },
            this
          );

          if (ret && ret.call) {
            var that = this;

            baseRef.eval = function() {
              return that.eval.apply(that, arguments);
            };

            try {
              ret = ret.apply(baseRef, args);
            } catch (e) {
              var pos = ast.pos;
              var text = Velocity.Helper.getRefText(ast);
              var err = ' on ' + text + ' at L/N ' + pos.first_line + ':' + pos.first_column;
              e.name = '';
              e.message += err;
              throw new Error(e);
            }
          } else {
            ret = undefined;
          }
        }

        return ret;
      },
    });
  };
});
define('velocityjs/0.4.10/src/compile/set-debug', [], function(require, exports, module) {
  module.exports = function(Velocity, utils) {
    /**
     * 变量设置
     */
    utils.mixin(Velocity.prototype, {
      /**
       * 获取执行环境，对于macro中定义的变量，为局部变量，不贮存在全局中，执行后销毁
       */
      getContext: function() {
        var condition = this.condition;
        var local = this.local;
        if (condition) {
          return local[condition];
        } else {
          return this.context;
        }
      },
      /**
       * parse #set
       */
      setValue: function(ast) {
        var ref = ast.equal[0];
        var context = this.getContext();

        //see https://github.com/shepherdwind/velocity.js/issues/25
        if (this.condition && this.condition.indexOf('macro:') === 0) {
          context = this.context;
        } else if (this.context[ref.id] != null) {
          context = this.context;
        }

        var valAst = ast.equal[1];
        var val;

        if (valAst.type === 'math') {
          val = this.getExpression(valAst);
        } else {
          val = this.getLiteral(ast.equal[1]);
        }

        if (!ref.path) {
          context[ref.id] = val;
        } else {
          var baseRef = context[ref.id];
          if (typeof baseRef != 'object') {
            baseRef = {};
          }

          context[ref.id] = baseRef;
          var len = ref.path ? ref.path.length : 0;

          //console.log(val);
          utils.forEach(ref.path, function(exp, i) {
            var isEnd = len === i + 1;
            var key = exp.id;
            if (exp.type === 'index') key = key.value;
            baseRef[key] = isEnd ? val : {};
            baseRef = baseRef[key];
          });
        }
      },
    });
  };
});
define('velocityjs/0.4.10/src/compile/expression-debug', [], function(require, exports, module) {
  module.exports = function(Velocity, utils) {
    /**
     * expression运算
     */
    utils.mixin(Velocity.prototype, {
      /**
       * 表达式求值，表达式主要是数学表达式，逻辑运算和比较运算，到最底层数据结构，
       * 基本数据类型，使用 getLiteral求值，getLiteral遇到是引用的时候，使用
       * getReferences求值
       */
      getExpression: function(ast) {
        var exp = ast.expression;
        var ret;
        if (ast.type === 'math') {
          switch (ast.operator) {
            case '+':
              ret = this.getExpression(exp[0]) + this.getExpression(exp[1]);
              break;

            case '-':
              ret = this.getExpression(exp[0]) - this.getExpression(exp[1]);
              break;

            case '/':
              ret = this.getExpression(exp[0]) / this.getExpression(exp[1]);
              break;

            case '%':
              ret = this.getExpression(exp[0]) % this.getExpression(exp[1]);
              break;

            case '*':
              ret = this.getExpression(exp[0]) * this.getExpression(exp[1]);
              break;

            case '||':
              ret = this.getExpression(exp[0]) || this.getExpression(exp[1]);
              break;

            case '&&':
              ret = this.getExpression(exp[0]) && this.getExpression(exp[1]);
              break;

            case '>':
              ret = this.getExpression(exp[0]) > this.getExpression(exp[1]);
              break;

            case '<':
              ret = this.getExpression(exp[0]) < this.getExpression(exp[1]);
              break;

            case '==':
              ret = this.getExpression(exp[0]) == this.getExpression(exp[1]);
              break;

            case '>=':
              ret = this.getExpression(exp[0]) >= this.getExpression(exp[1]);
              break;

            case '<=':
              ret = this.getExpression(exp[0]) <= this.getExpression(exp[1]);
              break;

            case '!=':
              ret = this.getExpression(exp[0]) != this.getExpression(exp[1]);
              break;

            case 'minus':
              ret = -this.getExpression(exp[0]);
              break;

            case 'not':
              ret = !this.getExpression(exp[0]);
              break;

            case 'parenthesis':
              ret = this.getExpression(exp[0]);
              break;

            default:
              return;
            // code
          }

          return ret;
        } else {
          return this.getLiteral(ast);
        }
      },
    });
  };
});
define('velocityjs/0.4.10/src/compile/compile-debug', [], function(require, exports, module) {
  module.exports = function(Velocity, utils) {
    /**
     * compile
     */
    utils.mixin(Velocity.prototype, {
      init: function() {
        this.context = {};
        this.macros = {};
        this.defines = {};
        this.conditions = [];
        this.local = {};
        this.silence = false;
        this.unescape = {};
      },

      /**
       * @param context {object} 上下文环境，数据对象
       * @param macro   {object} self defined #macro
       * @param silent {bool} 如果是true，$foo变量将原样输出
       * @return str
       */
      render: function(context, macros, silence) {
        this.silence = !!silence;
        this.context = context || {};
        this.jsmacros = macros || {};
        var t1 = utils.now();
        var str = this._render();
        var t2 = utils.now();
        var cost = t2 - t1;

        this.cost = cost;

        return str;
      },

      /**
       * 解析入口函数
       * @param ast {array} 模板结构数组
       * @param contextId {number} 执行环境id，对于macro有局部作用域，变量的设置和
       * 取值，都放在一个this.local下，通过contextId查找
       * @return {string}解析后的字符串
       */
      _render: function(asts, contextId) {
        var str = '';
        asts = asts || this.asts;

        if (contextId) {
          if (contextId !== this.condition && utils.indexOf(contextId, this.conditions) === -1) {
            this.conditions.unshift(contextId);
          }

          this.condition = contextId;
        } else {
          this.condition = null;
        }

        utils.forEach(
          asts,
          function(ast) {
            switch (ast.type) {
              case 'references':
                str += this.getReferences(ast, true);
                break;

              case 'set':
                this.setValue(ast);
                break;

              case 'break':
                this.setBreak = true;
                break;

              case 'macro_call':
                str += this.getMacro(ast);
                break;

              case 'comment':
                break;

              default:
                str += typeof ast == 'string' ? ast : this.getBlock(ast);
                break;
            }
          },
          this
        );

        return str;
      },
    });
  };
});
