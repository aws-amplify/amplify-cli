// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`a primary key with a composite sort key is properly configured 1`] = `
Object {
  "Mutation.createTest.init.1.req.vtl": "## [Start] Initialization default values. **
$util.qr($ctx.stash.put(\\"defaultValues\\", $util.defaultIfNull($ctx.stash.defaultValues, {})))
#set( $createdAt = $util.time.nowISO8601() )
$util.qr($ctx.stash.defaultValues.put(\\"id\\", $util.autoId()))
$util.qr($ctx.stash.defaultValues.put(\\"createdAt\\", $createdAt))
$util.qr($ctx.stash.defaultValues.put(\\"updatedAt\\", $createdAt))
$util.toJson({
  \\"version\\": \\"2018-05-29\\",
  \\"payload\\": {}
})
## [End] Initialization default values. **",
  "Mutation.createTest.req.vtl": "## [Start] Set the primary key. **
#set( $modelObjectKey = {
  \\"email\\": $util.dynamodb.toDynamoDB($ctx.args.input.email),
  \\"kind#other\\": $util.dynamodb.toDynamoDB(\\"\${ctx.args.input.kind}#\${ctx.args.input.other}\\")
} )
## [End] Set the primary key. **
#if( $util.isNull($dynamodbNameOverrideMap) )
  #set( $dynamodbNameOverrideMap = {
  \\"kind#other\\": \\"kindOther\\"
} )
#else
  $util.qr($dynamodbNameOverrideMap.put(\\"kind#other\\", \\"kindOther\\"))
#end
$util.qr($ctx.args.input.put(\\"kind#other\\",\\"\${ctx.args.input.kind}#\${ctx.args.input.other}\\"))
## [Start] Create Request template. **
## Begin - KeyCondition **
#if( $ctx.stash.metadata.modelObjectKey )
  #set( $keyConditionExpr = {} )
  #foreach( $entry in $ctx.stash.metadata.modelObjectKey.entrySet() )
    $util.qr($keyConditionExpr.add(\\"$entry.key\\", {
  \\"attributeExists\\": true
}))
  #end
  $util.qr($ctx.stash.conditions.add($keyConditionExpr))
#else
  $util.qr($ctx.stash.conditions.add({
  \\"id\\": {
      \\"attributeExists\\": false
  }
}))
#end
## End - KeyCondition **
## Set the default values to put request **
#set( $mergedValues = $util.defaultIfNull($ctx.stash.defaultValues, {}) )
## copy the values from input **
$util.qr($mergedValues.putAll($util.defaultIfNull($ctx.args.input, {})))
## set the typename **
$util.qr($mergedValues.put(\\"__typename\\", \\"Test\\"))
#set( $PutObject = {
  \\"version\\": \\"2018-05-29\\",
  \\"operation\\": \\"PutItem\\",
  \\"attributeValues\\":   $util.dynamodb.toMapValues($mergedValues),
  \\"condition\\": $condition
} )
#if( $context.args.condition )
  $util.qr($ctx.stash.conditions.add($context.args.condition))
#end
## Begin - KeyCondition **
#if( $ctx.stash.metadata.modelObjectKey )
  #set( $keyConditionExpr = {} )
  #foreach( $entry in $ctx.stash.metadata.modelObjectKey.entrySet() )
    $util.qr($keyConditionExpr.put(\\"$entry.key\\", {
  \\"attributeExists\\": false
}))
  #end
  $util.qr($ctx.stash.conditions.add($keyConditionExpr))
#else
  $util.qr($ctx.stash.conditions.add({
  \\"id\\": {
      \\"attributeExists\\": false
  }
}))
#end
## End - KeyCondition **
## Start condition block **
#if( $ctx.stash.conditions && $ctx.stash.conditions.size() != 0 )
  #set( $mergedConditions = {
  \\"and\\": $ctx.stash.conditions
} )
  #set( $Conditions = $util.parseJson($util.transform.toDynamoDBConditionExpression($mergedConditions)) )
  #if( $Conditions.expressionValues && $Conditions.expressionValues.size() == 0 )
    #set( $Conditions = {
  \\"expression\\": $Conditions.expression,
  \\"expressionNames\\": $Conditions.expressionNames
} )
  #end
  ## End condition block **
#end
#if( $Conditions )
  $util.qr($PutObject.put(\\"condition\\", $Conditions))
#end
#if( $ctx.stash.metadata.modelObject )
  $PutObject.put(\\"id\\", $ctx.stash.metadata.modelObject)
#else
  #set( $Key = {
  \\"id\\":   $util.dynamodb.toDynamoDB($mergedValues.id)
} )
  $util.qr($PutObject.put(\\"key\\", $Key))
#end
$util.toJson($PutObject)
## [End] Create Request template. **",
  "Mutation.createTest.res.vtl": "## [Start] Get ResponseTemplate. **
#if( $ctx.error )
  $util.error($ctx.error.message, $ctx.error.type)
#else
  $util.toJson($ctx.result)
#end
## [End] Get ResponseTemplate. **",
  "Mutation.deleteTest.req.vtl": "## [Start] Set the primary key. **
#set( $modelObjectKey = {
  \\"email\\": $util.dynamodb.toDynamoDB($ctx.args.input.email),
  \\"kind#other\\": $util.dynamodb.toDynamoDB(\\"\${ctx.args.input.kind}#\${ctx.args.input.other}\\")
} )
## [End] Set the primary key. **
## [Start] Delete Request template. **
#set( $DeleteRequest = {
  \\"version\\": \\"2018-05-29\\",
  \\"operation\\": \\"DeleteItem\\"
} )
#if( $ctx.stash.metadata.modelObjectKey )
  #set( $Key = $ctx.stash.metadata.modelObjectKey )
#else
  #set( $Key = {
  \\"id\\":   $util.dynamodb.toDynamoDB($ctx.args.input.id)
} )
#end
$util.qr($DeleteRequest.put(\\"key\\", $Key))
## Begin - key condition **
#if( $ctx.stash.metadata.modelObjectKey )
  #set( $keyConditionExpr = {} )
  #foreach( $entry in $ctx.stash.metadata.modelObjectKey.entrySet() )
    $util.qr($keyConditionExpr.put(\\"$entry.key\\", {
  \\"attributeExists\\": true
}))
  #end
  $util.qr($ctx.stash.conditions.add($keyConditionExpr))
#else
  $util.qr($ctx.stash.conditions.add({
  \\"id\\": {
      \\"attributeExists\\": true
  }
}))
#end
## End - key condition **
#if( $context.args.condition )
  $util.qr($ctx.stash.conditions.add($context.args.condition))
#end
## Start condition block **
#if( $ctx.stash.conditions && $ctx.stash.conditions.size() != 0 )
  #set( $mergedConditions = {
  \\"and\\": $ctx.stash.conditions
} )
  #set( $Conditions = $util.parseJson($util.transform.toDynamoDBConditionExpression($mergedConditions)) )
  #if( $Conditions.expressionValues && $Conditions.expressionValues.size() == 0 )
    #set( $Conditions = {
  \\"expression\\": $Conditions.expression,
  \\"expressionNames\\": $Conditions.expressionNames
} )
  #end
  ## End condition block **
#end
#if( $Conditions )
  $util.qr($DeleteRequest.put(\\"condition\\", $Conditions))
#end
$util.toJson($DeleteRequest)
## [End] Delete Request template. **",
  "Mutation.deleteTest.res.vtl": "## [Start] Get ResponseTemplate. **
#if( $ctx.error )
  $util.error($ctx.error.message, $ctx.error.type)
#else
  $util.toJson($ctx.result)
#end
## [End] Get ResponseTemplate. **",
  "Mutation.updateTest.init.1.req.vtl": "## [Start] Initialization default values. **
$util.qr($ctx.stash.put(\\"defaultValues\\", $util.defaultIfNull($ctx.stash.defaultValues, {})))
#set( $updatedAt = $util.time.nowISO8601() )
$util.qr($ctx.stash.defaultValues.put(\\"updatedAt\\", $updatedAt))
$util.toJson({
  \\"version\\": \\"2018-05-29\\",
  \\"payload\\": {}
})
## [End] Initialization default values. **",
  "Mutation.updateTest.req.vtl": "## [Start] Set the primary key. **
#set( $modelObjectKey = {
  \\"email\\": $util.dynamodb.toDynamoDB($ctx.args.input.email),
  \\"kind#other\\": $util.dynamodb.toDynamoDB(\\"\${ctx.args.input.kind}#\${ctx.args.input.other}\\")
} )
## [End] Set the primary key. **
#if( $util.isNull($dynamodbNameOverrideMap) )
  #set( $dynamodbNameOverrideMap = {
  \\"kind#other\\": \\"kindOther\\"
} )
#else
  $util.qr($dynamodbNameOverrideMap.put(\\"kind#other\\", \\"kindOther\\"))
#end
$util.qr($ctx.args.input.put(\\"kind#other\\",\\"\${ctx.args.input.kind}#\${ctx.args.input.other}\\"))
## [Start] Mutation Update resolver. **
## Set the default values to put request **
#set( $mergedValues = $util.defaultIfNull($ctx.stash.defaultValues, {}) )
## copy the values from input **
$util.qr($mergedValues.putAll($util.defaultIfNull($ctx.args.input, {})))
## set the typename **
## Initialize the vars for creating ddb expression **
#set( $expNames = {} )
#set( $expValues = {} )
#set( $expSet = {} )
#set( $expAdd = {} )
#set( $expRemove = [] )
#if( $ctx.stash.metadata.modelObjetKey )
  #set( $Key = $util.dynamodb.toDynamoDB($ctx.stash.metadata.modelObjetKey) )
#else
  #set( $Key = {
  \\"id\\":   $util.dynamodb.toDynamoDB($ctx.args.input.id)
} )
#end
## Model key **
#if( $ctx.stash.metadata.modelObjetKey )
  #foreach( $entry in $ctx.stash.metadata.modelObjetKey.entrySet() )
    $util.qr($keyFields.add(\\"$entry.key\\"))
  #end
#else
  #set( $keyFields = [\\"id\\"] )
#end
#foreach( $entry in $util.map.copyAndRemoveAllKeys($mergedValues, $keyFields).entrySet() )
  #if( $util.isNull($entry.value) )
    #set( $discard = $expRemove.add(\\"#$entry.key\\") )
    $util.qr($expNames.put(\\"#$entry.key\\", \\"$entry.key\\"))
  #else
    $util.qr($expSet.put(\\"#$entry.key\\", \\":$entry.key\\"))
    $util.qr($expNames.put(\\"#$entry.key\\", \\"$entry.key\\"))
    $util.qr($expValues.put(\\":$entry.key\\", $util.dynamodb.toDynamoDB($entry.value)))
  #end
#end
#set( $expression = \\"\\" )
#if( !$expSet.isEmpty() )
  #set( $expression = \\"SET\\" )
  #foreach( $entry in $expSet.entrySet() )
    #set( $expression = \\"$expression $entry.key = $entry.value\\" )
    #if( $foreach.hasNext() )
      #set( $expression = \\"$expression,\\" )
    #end
  #end
#end
#if( !$expAdd.isEmpty() )
  #set( $expression = \\"$expression ADD\\" )
  #foreach( $entry in $expAdd.entrySet() )
    #set( $expression = \\"$expression $entry.key $entry.value\\" )
    #if( $foreach.hasNext() )
      #set( $expression = \\"$expression,\\" )
    #end
  #end
#end
#if( !$expRemove.isEmpty() )
  #set( $expression = \\"$expression REMOVE\\" )
  #foreach( $entry in $expRemove )
    #set( $expression = \\"$expression $entry\\" )
    #if( $foreach.hasNext() )
      #set( $expression = \\"$expression,\\" )
    #end
  #end
#end
#set( $update = {} )
$util.qr($update.put(\\"expression\\", \\"$expression\\"))
#if( !$expNames.isEmpty() )
  $util.qr($update.put(\\"expressionNames\\", $expNames))
#end
#if( !$expValues.isEmpty() )
  $util.qr($update.put(\\"expressionValues\\", $expValues))
#end
## Begin - key condition **
#if( $ctx.stash.metadata.modelObjectKey )
  #set( $keyConditionExpr = {} )
  #foreach( $entry in $ctx.stash.metadata.modelObjectKey.entrySet() )
    $util.qr($keyConditionExpr.put(\\"$entry.key\\", {
  \\"attributeExists\\": true
}))
  #end
  $util.qr($ctx.stash.conditions.add($keyConditionExpr))
#else
  $util.qr($ctx.stash.conditions.add({
  \\"id\\": {
      \\"attributeExists\\": true
  }
}))
#end
## End - key condition **
#if( $context.args.condition )
  $util.qr($ctx.stash.conditions.add($context.args.condition))
#end
## Start condition block **
#if( $ctx.stash.conditions && $ctx.stash.conditions.size() != 0 )
  #set( $mergedConditions = {
  \\"and\\": $ctx.stash.conditions
} )
  #set( $Conditions = $util.parseJson($util.transform.toDynamoDBConditionExpression($mergedConditions)) )
  #if( $Conditions.expressionValues && $Conditions.expressionValues.size() == 0 )
    #set( $Conditions = {
  \\"expression\\": $Conditions.expression,
  \\"expressionNames\\": $Conditions.expressionNames
} )
  #end
  ## End condition block **
#end
#set( $UpdateItem = {
  \\"version\\": \\"2018-05-29\\",
  \\"operation\\": \\"UpdateItem\\",
  \\"key\\": $Key,
  \\"update\\": $update
} )
#if( $Conditions )
  $util.qr($UpdateItem.put(\\"condition\\", $Conditions))
#end
$util.toJson($UpdateItem)
## [End] Mutation Update resolver. **",
  "Mutation.updateTest.res.vtl": "## [Start] Get ResponseTemplate. **
#if( $ctx.error )
  $util.error($ctx.error.message, $ctx.error.type)
#else
  $util.toJson($ctx.result)
#end
## [End] Get ResponseTemplate. **",
  "Query.getTest.req.vtl": "## [Start] Set the primary key. **
#set( $modelObjectKey = {
  \\"email\\": $util.dynamodb.toDynamoDB($ctx.args.email),
  \\"kind#other\\": $util.dynamodb.toDynamoDB(\\"\${ctx.args.kind}#\${ctx.args.other}\\")
} )
## [End] Set the primary key. **
## [Start] Get Request template. **
#set( $GetRequest = {
  \\"version\\": \\"2018-05-29\\",
  \\"operation\\": \\"GetItem\\"
} )
#if( $ctx.stash.metadata.modelKeyObject )
  #set( $Key = $ctx.stash.metadata.modelKeyObject )
#else
  #set( $key = {
  \\"id\\":   $util.dynamodb.toDynamoDB($ctx.args.id)
} )
#end
$util.qr($GetRequest.put(\\"key\\", $key))
$util.toJson($GetRequest)
## [End] Get Request template. **",
  "Query.getTest.res.vtl": "## [Start] Get ResponseTemplate. **
#if( $ctx.error )
  $util.error($ctx.error.message, $ctx.error.type)
#else
  $util.toJson($ctx.result)
#end
## [End] Get ResponseTemplate. **",
  "Query.listTests.req.vtl": "## [Start] Set query expression for key **
#if( $util.isNull($ctx.args.email) && !$util.isNull($ctx.args.sortDirection) )
  $util.error(\\"When providing argument 'sortDirection' you must also provide argument 'email'.\\", \\"InvalidArgumentsError\\")
#end
#set( $modelQueryExpression = {} )
## [Start] Validate key arguments. **
#if( !$util.isNull($ctx.args.kindOther) && $util.isNullOrBlank($ctx.args.email) )
  $util.error(\\"When providing argument 'kindOther' you must also provide 'email'.\\", \\"InvalidArgumentsError\\")
#end
#if( !$util.isNull($ctx.args.kindOther) )
  #set( $sortKeyArgumentOperations = $ctx.args.kindOther.keySet() )
  #if( $sortKeyArgumentOperations.size() > 1 )
    $util.error(\\"Argument kindOther must specify at most one key condition operation.\\", \\"InvalidArgumentsError\\")
  #end
  #foreach( $operation in $sortKeyArgumentOperations )
    #if( $operation == \\"between\\" )
      #if( $ctx.args.kindOther.between.size() != 2 )
        $util.error(\\"Argument 'kindOther.between' expects exactly two elements.\\", \\"InvalidArgumentsError\\")
      #end
      #if( !$util.isNullOrBlank($ctx.args.kindOther.between[0].other) && $util.isNullOrBlank($ctx.args.kindOther.between[0].kind) )
        $util.error(\\"When providing argument 'kindOther.between[0].other' you must also provide 'kindOther.between[0].kind'.\\", \\"InvalidArgumentsError\\")
      #end
      #if( !$util.isNullOrBlank($ctx.args.kindOther.between[1].other) && $util.isNullOrBlank($ctx.args.kindOther.between[1].kind) )
        $util.error(\\"When providing argument 'kindOther.between[1].other' you must also provide 'kindOther.between[1].kind'.\\", \\"InvalidArgumentsError\\")
      #end
    #else
      #if( !$util.isNullOrBlank($ctx.args.kindOther.get(\\"$operation\\").other) && $util.isNullOrBlank($ctx.args.kindOther.get(\\"$operation\\").kind) )
        $util.error(\\"When providing argument 'kindOther.$operation.other' you must also provide 'kindOther.$operation.kind'.\\", \\"InvalidArgumentsError\\")
      #end
    #end
  #end
#end
## [End] Validate key arguments. **
#if( !$util.isNull($ctx.args.email) )
  #set( $modelQueryExpression.expression = \\"#email = :email\\" )
  #set( $modelQueryExpression.expressionNames = {
  \\"#email\\": \\"email\\"
} )
  #set( $modelQueryExpression.expressionValues = {
  \\":email\\": {
      \\"S\\": \\"$ctx.args.email\\"
  }
} )
#end
## [Start] Applying Key Condition **
#set( $sortKeyValue = \\"\\" )
#set( $sortKeyValue2 = \\"\\" )
#if( !$util.isNull($ctx.args.kindOther) && !$util.isNull($ctx.args.kindOther.beginsWith) )
#if( !$util.isNull($ctx.args.kindOther.beginsWith.kind) ) #set( $sortKeyValue = \\"$ctx.args.kindOther.beginsWith.kind\\" ) #end
#if( !$util.isNull($ctx.args.kindOther.beginsWith.other) ) #set( $sortKeyValue = \\"$sortKeyValue#$ctx.args.kindOther.beginsWith.other\\" ) #end
  #set( $modelQueryExpression.expression = \\"$modelQueryExpression.expression AND begins_with(#sortKey, :sortKey)\\" )
  $util.qr($modelQueryExpression.expressionNames.put(\\"#sortKey\\", \\"kind#other\\"))
  $util.qr($modelQueryExpression.expressionValues.put(\\":sortKey\\", { \\"S\\": \\"$sortKeyValue\\" }))
#end
#if( !$util.isNull($ctx.args.kindOther) && !$util.isNull($ctx.args.kindOther.between) )
  #if( $ctx.args.kindOther.between.size() != 2 )
    $util.error(\\"Argument kindOther.between expects exactly 2 elements.\\")
  #end
#if( !$util.isNull($ctx.args.kindOther.between[0].kind) ) #set( $sortKeyValue = \\"$ctx.args.kindOther.between[0].kind\\" ) #end
#if( !$util.isNull($ctx.args.kindOther.between[0].other) ) #set( $sortKeyValue = \\"$sortKeyValue#$ctx.args.kindOther.between[0].other\\" ) #end
#if( !$util.isNull($ctx.args.kindOther.between[1].kind) ) #set( $sortKeyValue2 = \\"$ctx.args.kindOther.between[1].kind\\" ) #end
#if( !$util.isNull($ctx.args.kindOther.between[1].other) ) #set( $sortKeyValue2 = \\"$sortKeyValue2#$ctx.args.kindOther.between[1].other\\" ) #end
  #set( $modelQueryExpression.expression = \\"$modelQueryExpression.expression AND #sortKey BETWEEN :sortKey0 AND :sortKey1\\" )
  $util.qr($modelQueryExpression.expressionNames.put(\\"#sortKey\\", \\"kind#other\\"))
  $util.qr($modelQueryExpression.expressionValues.put(\\":sortKey0\\", { \\"S\\": \\"$sortKeyValue\\" }))
  $util.qr($modelQueryExpression.expressionValues.put(\\":sortKey1\\", { \\"S\\": \\"$sortKeyValue2\\" }))
#end
#if( !$util.isNull($ctx.args.kindOther) && !$util.isNull($ctx.args.kindOther.eq) )
#if( !$util.isNull($ctx.args.kindOther.eq.kind) ) #set( $sortKeyValue = \\"$ctx.args.kindOther.eq.kind\\" ) #end
#if( !$util.isNull($ctx.args.kindOther.eq.other) ) #set( $sortKeyValue = \\"$sortKeyValue#$ctx.args.kindOther.eq.other\\" ) #end
  #set( $modelQueryExpression.expression = \\"$modelQueryExpression.expression AND #sortKey = :sortKey\\" )
  $util.qr($modelQueryExpression.expressionNames.put(\\"#sortKey\\", \\"kind#other\\"))
  $util.qr($modelQueryExpression.expressionValues.put(\\":sortKey\\", { \\"S\\": \\"$sortKeyValue\\" }))
#end
#if( !$util.isNull($ctx.args.kindOther) && !$util.isNull($ctx.args.kindOther.lt) )
#if( !$util.isNull($ctx.args.kindOther.lt.kind) ) #set( $sortKeyValue = \\"$ctx.args.kindOther.lt.kind\\" ) #end
#if( !$util.isNull($ctx.args.kindOther.lt.other) ) #set( $sortKeyValue = \\"$sortKeyValue#$ctx.args.kindOther.lt.other\\" ) #end
  #set( $modelQueryExpression.expression = \\"$modelQueryExpression.expression AND #sortKey < :sortKey\\" )
  $util.qr($modelQueryExpression.expressionNames.put(\\"#sortKey\\", \\"kind#other\\"))
  $util.qr($modelQueryExpression.expressionValues.put(\\":sortKey\\", { \\"S\\": \\"$sortKeyValue\\" }))
#end
#if( !$util.isNull($ctx.args.kindOther) && !$util.isNull($ctx.args.kindOther.le) )
#if( !$util.isNull($ctx.args.kindOther.le.kind) ) #set( $sortKeyValue = \\"$ctx.args.kindOther.le.kind\\" ) #end
#if( !$util.isNull($ctx.args.kindOther.le.other) ) #set( $sortKeyValue = \\"$sortKeyValue#$ctx.args.kindOther.le.other\\" ) #end
  #set( $modelQueryExpression.expression = \\"$modelQueryExpression.expression AND #sortKey <= :sortKey\\" )
  $util.qr($modelQueryExpression.expressionNames.put(\\"#sortKey\\", \\"kind#other\\"))
  $util.qr($modelQueryExpression.expressionValues.put(\\":sortKey\\", { \\"S\\": \\"$sortKeyValue\\" }))
#end
#if( !$util.isNull($ctx.args.kindOther) && !$util.isNull($ctx.args.kindOther.gt) )
#if( !$util.isNull($ctx.args.kindOther.gt.kind) ) #set( $sortKeyValue = \\"$ctx.args.kindOther.gt.kind\\" ) #end
#if( !$util.isNull($ctx.args.kindOther.gt.other) ) #set( $sortKeyValue = \\"$sortKeyValue#$ctx.args.kindOther.gt.other\\" ) #end
  #set( $modelQueryExpression.expression = \\"$modelQueryExpression.expression AND #sortKey > :sortKey\\" )
  $util.qr($modelQueryExpression.expressionNames.put(\\"#sortKey\\", \\"kind#other\\"))
  $util.qr($modelQueryExpression.expressionValues.put(\\":sortKey\\", { \\"S\\": \\"$sortKeyValue\\" }))
#end
#if( !$util.isNull($ctx.args.kindOther) && !$util.isNull($ctx.args.kindOther.ge) )
#if( !$util.isNull($ctx.args.kindOther.ge.kind) ) #set( $sortKeyValue = \\"$ctx.args.kindOther.ge.kind\\" ) #end
#if( !$util.isNull($ctx.args.kindOther.ge.other) ) #set( $sortKeyValue = \\"$sortKeyValue#$ctx.args.kindOther.ge.other\\" ) #end
  #set( $modelQueryExpression.expression = \\"$modelQueryExpression.expression AND #sortKey >= :sortKey\\" )
  $util.qr($modelQueryExpression.expressionNames.put(\\"#sortKey\\", \\"kind#other\\"))
  $util.qr($modelQueryExpression.expressionValues.put(\\":sortKey\\", { \\"S\\": \\"$sortKeyValue\\" }))
#end


## [End] Applying Key Condition **
## [End] Set query expression for key **
## [Start] List Request. **
#set( $limit = $util.defaultIfNull($context.args.limit, 100) )
#set( $ListRequest = {
  \\"version\\": \\"2018-05-29\\",
  \\"limit\\": $limit
} )
#if( $context.args.nextToken )
  #set( $ListRequest.nextToken = $context.args.nextToken )
#end
#if( $context.args.filter )
  #set( $filterExpression = $util.parseJson($util.transform.toDynamoDBFilterExpression($ctx.args.filter)) )
  #if( !$util.isNullOrBlank($filterExpression.expression) )
    #if( $filterEpression.expressionValues.size() == 0 )
      $util.qr($filterEpression.remove(\\"expressionValues\\"))
    #end
    #set( $ListRequest.filter = $filterExpression )
  #end
#end
#if( !$util.isNull($ctx.stash.modelQuery) )
  #set( $Query = $util.parseJson($util.transform.toDynamoDBFilterExpression($ctx.stash.modelQuery)) )
  $util.qr($ListRequest.put(\\"operation\\", \\"Query\\"))
  $util.qr($ListRequest.put(\\"query\\", $Query))
  #if( !$util.isNull($ctx.args.sortDirection) && $ctx.args.sortDirection == \\"DESC\\" )
    #set( $ListRequest.scanIndexForward = false )
  #else
    #set( $ListRequest.scanIndexForward = true )
  #end
#else
  $util.qr($ListRequest.put(\\"operation\\", \\"Scan\\"))
#end
#if( !$util.isNull($ctx.stash.metadata.index) )
  #set( $ListRequest.IndexName = $ctx.stash.metadata.index )
#end
$util.toJson($ListRequest)
## [End] List Request. **",
  "Query.listTests.res.vtl": "## [Start] Get ResponseTemplate. **
#if( $ctx.error )
  $util.error($ctx.error.message, $ctx.error.type)
#else
  $util.toJson($ctx.result)
#end
## [End] Get ResponseTemplate. **",
  "Subscription.onCreateTest.req.vtl": "## [Start] Subscription Request template. **
$util.toJson({
  \\"version\\": \\"2018-05-29\\",
  \\"payload\\": {}
})
## [End] Subscription Request template. **",
  "Subscription.onCreateTest.res.vtl": "## [Start] Subscription Resonse template. **
$util.toJson(null)
## [End] Subscription Resonse template. **",
  "Subscription.onDeleteTest.req.vtl": "## [Start] Subscription Request template. **
$util.toJson({
  \\"version\\": \\"2018-05-29\\",
  \\"payload\\": {}
})
## [End] Subscription Request template. **",
  "Subscription.onDeleteTest.res.vtl": "## [Start] Subscription Resonse template. **
$util.toJson(null)
## [End] Subscription Resonse template. **",
  "Subscription.onUpdateTest.req.vtl": "## [Start] Subscription Request template. **
$util.toJson({
  \\"version\\": \\"2018-05-29\\",
  \\"payload\\": {}
})
## [End] Subscription Request template. **",
  "Subscription.onUpdateTest.res.vtl": "## [Start] Subscription Resonse template. **
$util.toJson(null)
## [End] Subscription Resonse template. **",
}
`;

exports[`a primary key with a single sort key field is properly configured 1`] = `
Object {
  "Mutation.createTest.init.1.req.vtl": "## [Start] Initialization default values. **
$util.qr($ctx.stash.put(\\"defaultValues\\", $util.defaultIfNull($ctx.stash.defaultValues, {})))
#set( $createdAt = $util.time.nowISO8601() )
$util.qr($ctx.stash.defaultValues.put(\\"id\\", $util.autoId()))
$util.qr($ctx.stash.defaultValues.put(\\"createdAt\\", $createdAt))
$util.qr($ctx.stash.defaultValues.put(\\"updatedAt\\", $createdAt))
$util.toJson({
  \\"version\\": \\"2018-05-29\\",
  \\"payload\\": {}
})
## [End] Initialization default values. **",
  "Mutation.createTest.req.vtl": "## [Start] Set the primary key. **
#set( $modelObjectKey = {
  \\"email\\": $util.dynamodb.toDynamoDB($ctx.args.input.email),
  \\"kind\\": $util.dynamodb.toDynamoDB($ctx.args.input.kind)
} )
## [End] Set the primary key. **

## [Start] Create Request template. **
## Begin - KeyCondition **
#if( $ctx.stash.metadata.modelObjectKey )
  #set( $keyConditionExpr = {} )
  #foreach( $entry in $ctx.stash.metadata.modelObjectKey.entrySet() )
    $util.qr($keyConditionExpr.add(\\"$entry.key\\", {
  \\"attributeExists\\": true
}))
  #end
  $util.qr($ctx.stash.conditions.add($keyConditionExpr))
#else
  $util.qr($ctx.stash.conditions.add({
  \\"id\\": {
      \\"attributeExists\\": false
  }
}))
#end
## End - KeyCondition **
## Set the default values to put request **
#set( $mergedValues = $util.defaultIfNull($ctx.stash.defaultValues, {}) )
## copy the values from input **
$util.qr($mergedValues.putAll($util.defaultIfNull($ctx.args.input, {})))
## set the typename **
$util.qr($mergedValues.put(\\"__typename\\", \\"Test\\"))
#set( $PutObject = {
  \\"version\\": \\"2018-05-29\\",
  \\"operation\\": \\"PutItem\\",
  \\"attributeValues\\":   $util.dynamodb.toMapValues($mergedValues),
  \\"condition\\": $condition
} )
#if( $context.args.condition )
  $util.qr($ctx.stash.conditions.add($context.args.condition))
#end
## Begin - KeyCondition **
#if( $ctx.stash.metadata.modelObjectKey )
  #set( $keyConditionExpr = {} )
  #foreach( $entry in $ctx.stash.metadata.modelObjectKey.entrySet() )
    $util.qr($keyConditionExpr.put(\\"$entry.key\\", {
  \\"attributeExists\\": false
}))
  #end
  $util.qr($ctx.stash.conditions.add($keyConditionExpr))
#else
  $util.qr($ctx.stash.conditions.add({
  \\"id\\": {
      \\"attributeExists\\": false
  }
}))
#end
## End - KeyCondition **
## Start condition block **
#if( $ctx.stash.conditions && $ctx.stash.conditions.size() != 0 )
  #set( $mergedConditions = {
  \\"and\\": $ctx.stash.conditions
} )
  #set( $Conditions = $util.parseJson($util.transform.toDynamoDBConditionExpression($mergedConditions)) )
  #if( $Conditions.expressionValues && $Conditions.expressionValues.size() == 0 )
    #set( $Conditions = {
  \\"expression\\": $Conditions.expression,
  \\"expressionNames\\": $Conditions.expressionNames
} )
  #end
  ## End condition block **
#end
#if( $Conditions )
  $util.qr($PutObject.put(\\"condition\\", $Conditions))
#end
#if( $ctx.stash.metadata.modelObject )
  $PutObject.put(\\"id\\", $ctx.stash.metadata.modelObject)
#else
  #set( $Key = {
  \\"id\\":   $util.dynamodb.toDynamoDB($mergedValues.id)
} )
  $util.qr($PutObject.put(\\"key\\", $Key))
#end
$util.toJson($PutObject)
## [End] Create Request template. **",
  "Mutation.createTest.res.vtl": "## [Start] Get ResponseTemplate. **
#if( $ctx.error )
  $util.error($ctx.error.message, $ctx.error.type)
#else
  $util.toJson($ctx.result)
#end
## [End] Get ResponseTemplate. **",
  "Mutation.deleteTest.req.vtl": "## [Start] Set the primary key. **
#set( $modelObjectKey = {
  \\"email\\": $util.dynamodb.toDynamoDB($ctx.args.input.email),
  \\"kind\\": $util.dynamodb.toDynamoDB($ctx.args.input.kind)
} )
## [End] Set the primary key. **
## [Start] Delete Request template. **
#set( $DeleteRequest = {
  \\"version\\": \\"2018-05-29\\",
  \\"operation\\": \\"DeleteItem\\"
} )
#if( $ctx.stash.metadata.modelObjectKey )
  #set( $Key = $ctx.stash.metadata.modelObjectKey )
#else
  #set( $Key = {
  \\"id\\":   $util.dynamodb.toDynamoDB($ctx.args.input.id)
} )
#end
$util.qr($DeleteRequest.put(\\"key\\", $Key))
## Begin - key condition **
#if( $ctx.stash.metadata.modelObjectKey )
  #set( $keyConditionExpr = {} )
  #foreach( $entry in $ctx.stash.metadata.modelObjectKey.entrySet() )
    $util.qr($keyConditionExpr.put(\\"$entry.key\\", {
  \\"attributeExists\\": true
}))
  #end
  $util.qr($ctx.stash.conditions.add($keyConditionExpr))
#else
  $util.qr($ctx.stash.conditions.add({
  \\"id\\": {
      \\"attributeExists\\": true
  }
}))
#end
## End - key condition **
#if( $context.args.condition )
  $util.qr($ctx.stash.conditions.add($context.args.condition))
#end
## Start condition block **
#if( $ctx.stash.conditions && $ctx.stash.conditions.size() != 0 )
  #set( $mergedConditions = {
  \\"and\\": $ctx.stash.conditions
} )
  #set( $Conditions = $util.parseJson($util.transform.toDynamoDBConditionExpression($mergedConditions)) )
  #if( $Conditions.expressionValues && $Conditions.expressionValues.size() == 0 )
    #set( $Conditions = {
  \\"expression\\": $Conditions.expression,
  \\"expressionNames\\": $Conditions.expressionNames
} )
  #end
  ## End condition block **
#end
#if( $Conditions )
  $util.qr($DeleteRequest.put(\\"condition\\", $Conditions))
#end
$util.toJson($DeleteRequest)
## [End] Delete Request template. **",
  "Mutation.deleteTest.res.vtl": "## [Start] Get ResponseTemplate. **
#if( $ctx.error )
  $util.error($ctx.error.message, $ctx.error.type)
#else
  $util.toJson($ctx.result)
#end
## [End] Get ResponseTemplate. **",
  "Mutation.updateTest.init.1.req.vtl": "## [Start] Initialization default values. **
$util.qr($ctx.stash.put(\\"defaultValues\\", $util.defaultIfNull($ctx.stash.defaultValues, {})))
#set( $updatedAt = $util.time.nowISO8601() )
$util.qr($ctx.stash.defaultValues.put(\\"updatedAt\\", $updatedAt))
$util.toJson({
  \\"version\\": \\"2018-05-29\\",
  \\"payload\\": {}
})
## [End] Initialization default values. **",
  "Mutation.updateTest.req.vtl": "## [Start] Set the primary key. **
#set( $modelObjectKey = {
  \\"email\\": $util.dynamodb.toDynamoDB($ctx.args.input.email),
  \\"kind\\": $util.dynamodb.toDynamoDB($ctx.args.input.kind)
} )
## [End] Set the primary key. **

## [Start] Mutation Update resolver. **
## Set the default values to put request **
#set( $mergedValues = $util.defaultIfNull($ctx.stash.defaultValues, {}) )
## copy the values from input **
$util.qr($mergedValues.putAll($util.defaultIfNull($ctx.args.input, {})))
## set the typename **
## Initialize the vars for creating ddb expression **
#set( $expNames = {} )
#set( $expValues = {} )
#set( $expSet = {} )
#set( $expAdd = {} )
#set( $expRemove = [] )
#if( $ctx.stash.metadata.modelObjetKey )
  #set( $Key = $util.dynamodb.toDynamoDB($ctx.stash.metadata.modelObjetKey) )
#else
  #set( $Key = {
  \\"id\\":   $util.dynamodb.toDynamoDB($ctx.args.input.id)
} )
#end
## Model key **
#if( $ctx.stash.metadata.modelObjetKey )
  #foreach( $entry in $ctx.stash.metadata.modelObjetKey.entrySet() )
    $util.qr($keyFields.add(\\"$entry.key\\"))
  #end
#else
  #set( $keyFields = [\\"id\\"] )
#end
#foreach( $entry in $util.map.copyAndRemoveAllKeys($mergedValues, $keyFields).entrySet() )
  #if( $util.isNull($entry.value) )
    #set( $discard = $expRemove.add(\\"#$entry.key\\") )
    $util.qr($expNames.put(\\"#$entry.key\\", \\"$entry.key\\"))
  #else
    $util.qr($expSet.put(\\"#$entry.key\\", \\":$entry.key\\"))
    $util.qr($expNames.put(\\"#$entry.key\\", \\"$entry.key\\"))
    $util.qr($expValues.put(\\":$entry.key\\", $util.dynamodb.toDynamoDB($entry.value)))
  #end
#end
#set( $expression = \\"\\" )
#if( !$expSet.isEmpty() )
  #set( $expression = \\"SET\\" )
  #foreach( $entry in $expSet.entrySet() )
    #set( $expression = \\"$expression $entry.key = $entry.value\\" )
    #if( $foreach.hasNext() )
      #set( $expression = \\"$expression,\\" )
    #end
  #end
#end
#if( !$expAdd.isEmpty() )
  #set( $expression = \\"$expression ADD\\" )
  #foreach( $entry in $expAdd.entrySet() )
    #set( $expression = \\"$expression $entry.key $entry.value\\" )
    #if( $foreach.hasNext() )
      #set( $expression = \\"$expression,\\" )
    #end
  #end
#end
#if( !$expRemove.isEmpty() )
  #set( $expression = \\"$expression REMOVE\\" )
  #foreach( $entry in $expRemove )
    #set( $expression = \\"$expression $entry\\" )
    #if( $foreach.hasNext() )
      #set( $expression = \\"$expression,\\" )
    #end
  #end
#end
#set( $update = {} )
$util.qr($update.put(\\"expression\\", \\"$expression\\"))
#if( !$expNames.isEmpty() )
  $util.qr($update.put(\\"expressionNames\\", $expNames))
#end
#if( !$expValues.isEmpty() )
  $util.qr($update.put(\\"expressionValues\\", $expValues))
#end
## Begin - key condition **
#if( $ctx.stash.metadata.modelObjectKey )
  #set( $keyConditionExpr = {} )
  #foreach( $entry in $ctx.stash.metadata.modelObjectKey.entrySet() )
    $util.qr($keyConditionExpr.put(\\"$entry.key\\", {
  \\"attributeExists\\": true
}))
  #end
  $util.qr($ctx.stash.conditions.add($keyConditionExpr))
#else
  $util.qr($ctx.stash.conditions.add({
  \\"id\\": {
      \\"attributeExists\\": true
  }
}))
#end
## End - key condition **
#if( $context.args.condition )
  $util.qr($ctx.stash.conditions.add($context.args.condition))
#end
## Start condition block **
#if( $ctx.stash.conditions && $ctx.stash.conditions.size() != 0 )
  #set( $mergedConditions = {
  \\"and\\": $ctx.stash.conditions
} )
  #set( $Conditions = $util.parseJson($util.transform.toDynamoDBConditionExpression($mergedConditions)) )
  #if( $Conditions.expressionValues && $Conditions.expressionValues.size() == 0 )
    #set( $Conditions = {
  \\"expression\\": $Conditions.expression,
  \\"expressionNames\\": $Conditions.expressionNames
} )
  #end
  ## End condition block **
#end
#set( $UpdateItem = {
  \\"version\\": \\"2018-05-29\\",
  \\"operation\\": \\"UpdateItem\\",
  \\"key\\": $Key,
  \\"update\\": $update
} )
#if( $Conditions )
  $util.qr($UpdateItem.put(\\"condition\\", $Conditions))
#end
$util.toJson($UpdateItem)
## [End] Mutation Update resolver. **",
  "Mutation.updateTest.res.vtl": "## [Start] Get ResponseTemplate. **
#if( $ctx.error )
  $util.error($ctx.error.message, $ctx.error.type)
#else
  $util.toJson($ctx.result)
#end
## [End] Get ResponseTemplate. **",
  "Query.getTest.req.vtl": "## [Start] Set the primary key. **
#set( $modelObjectKey = {
  \\"email\\": $util.dynamodb.toDynamoDB($ctx.args.email),
  \\"kind\\": $util.dynamodb.toDynamoDB($ctx.args.kind)
} )
## [End] Set the primary key. **
## [Start] Get Request template. **
#set( $GetRequest = {
  \\"version\\": \\"2018-05-29\\",
  \\"operation\\": \\"GetItem\\"
} )
#if( $ctx.stash.metadata.modelKeyObject )
  #set( $Key = $ctx.stash.metadata.modelKeyObject )
#else
  #set( $key = {
  \\"id\\":   $util.dynamodb.toDynamoDB($ctx.args.id)
} )
#end
$util.qr($GetRequest.put(\\"key\\", $key))
$util.toJson($GetRequest)
## [End] Get Request template. **",
  "Query.getTest.res.vtl": "## [Start] Get ResponseTemplate. **
#if( $ctx.error )
  $util.error($ctx.error.message, $ctx.error.type)
#else
  $util.toJson($ctx.result)
#end
## [End] Get ResponseTemplate. **",
  "Query.listTests.req.vtl": "## [Start] Set query expression for key **
#if( $util.isNull($ctx.args.email) && !$util.isNull($ctx.args.sortDirection) )
  $util.error(\\"When providing argument 'sortDirection' you must also provide argument 'email'.\\", \\"InvalidArgumentsError\\")
#end
#set( $modelQueryExpression = {} )
## [Start] Validate key arguments. **
#if( !$util.isNull($ctx.args.kind) && $util.isNull($ctx.args.email) )
  $util.error(\\"When providing argument 'kind' you must also provide arguments email\\", \\"InvalidArgumentsError\\")
#end
## [End] Validate key arguments. **
#if( !$util.isNull($ctx.args.email) )
  #set( $modelQueryExpression.expression = \\"#email = :email\\" )
  #set( $modelQueryExpression.expressionNames = {
  \\"#email\\": \\"email\\"
} )
  #set( $modelQueryExpression.expressionValues = {
  \\":email\\": {
      \\"S\\": \\"$ctx.args.email\\"
  }
} )
#end
## [Start] Applying Key Condition **
#if( !$util.isNull($ctx.args.kind) && !$util.isNull($ctx.args.kind.beginsWith) )
  #set( $modelQueryExpression.expression = \\"$modelQueryExpression.expression AND begins_with(#sortKey, :sortKey)\\" )
  $util.qr($modelQueryExpression.expressionNames.put(\\"#sortKey\\", \\"kind\\"))
  $util.qr($modelQueryExpression.expressionValues.put(\\":sortKey\\", { \\"N\\": \\"$ctx.args.kind.beginsWith\\" }))
#end
#if( !$util.isNull($ctx.args.kind) && !$util.isNull($ctx.args.kind.between) )
  #set( $modelQueryExpression.expression = \\"$modelQueryExpression.expression AND #sortKey BETWEEN :sortKey0 AND :sortKey1\\" )
  $util.qr($modelQueryExpression.expressionNames.put(\\"#sortKey\\", \\"kind\\"))
  $util.qr($modelQueryExpression.expressionValues.put(\\":sortKey0\\", { \\"N\\": \\"$ctx.args.kind.between[0]\\" }))
  $util.qr($modelQueryExpression.expressionValues.put(\\":sortKey1\\", { \\"N\\": \\"$ctx.args.kind.between[1]\\" }))
#end
#if( !$util.isNull($ctx.args.kind) && !$util.isNull($ctx.args.kind.eq) )
  #set( $modelQueryExpression.expression = \\"$modelQueryExpression.expression AND #sortKey = :sortKey\\" )
  $util.qr($modelQueryExpression.expressionNames.put(\\"#sortKey\\", \\"kind\\"))
  $util.qr($modelQueryExpression.expressionValues.put(\\":sortKey\\", { \\"N\\": \\"$ctx.args.kind.eq\\" }))
#end
#if( !$util.isNull($ctx.args.kind) && !$util.isNull($ctx.args.kind.lt) )
  #set( $modelQueryExpression.expression = \\"$modelQueryExpression.expression AND #sortKey < :sortKey\\" )
  $util.qr($modelQueryExpression.expressionNames.put(\\"#sortKey\\", \\"kind\\"))
  $util.qr($modelQueryExpression.expressionValues.put(\\":sortKey\\", { \\"N\\": \\"$ctx.args.kind.lt\\" }))
#end
#if( !$util.isNull($ctx.args.kind) && !$util.isNull($ctx.args.kind.le) )
  #set( $modelQueryExpression.expression = \\"$modelQueryExpression.expression AND #sortKey <= :sortKey\\" )
  $util.qr($modelQueryExpression.expressionNames.put(\\"#sortKey\\", \\"kind\\"))
  $util.qr($modelQueryExpression.expressionValues.put(\\":sortKey\\", { \\"N\\": \\"$ctx.args.kind.le\\" }))
#end
#if( !$util.isNull($ctx.args.kind) && !$util.isNull($ctx.args.kind.gt) )
  #set( $modelQueryExpression.expression = \\"$modelQueryExpression.expression AND #sortKey > :sortKey\\" )
  $util.qr($modelQueryExpression.expressionNames.put(\\"#sortKey\\", \\"kind\\"))
  $util.qr($modelQueryExpression.expressionValues.put(\\":sortKey\\", { \\"N\\": \\"$ctx.args.kind.gt\\" }))
#end
#if( !$util.isNull($ctx.args.kind) && !$util.isNull($ctx.args.kind.ge) )
  #set( $modelQueryExpression.expression = \\"$modelQueryExpression.expression AND #sortKey >= :sortKey\\" )
  $util.qr($modelQueryExpression.expressionNames.put(\\"#sortKey\\", \\"kind\\"))
  $util.qr($modelQueryExpression.expressionValues.put(\\":sortKey\\", { \\"N\\": \\"$ctx.args.kind.ge\\" }))
#end
## [End] Applying Key Condition **
## [End] Set query expression for key **
## [Start] List Request. **
#set( $limit = $util.defaultIfNull($context.args.limit, 100) )
#set( $ListRequest = {
  \\"version\\": \\"2018-05-29\\",
  \\"limit\\": $limit
} )
#if( $context.args.nextToken )
  #set( $ListRequest.nextToken = $context.args.nextToken )
#end
#if( $context.args.filter )
  #set( $filterExpression = $util.parseJson($util.transform.toDynamoDBFilterExpression($ctx.args.filter)) )
  #if( !$util.isNullOrBlank($filterExpression.expression) )
    #if( $filterEpression.expressionValues.size() == 0 )
      $util.qr($filterEpression.remove(\\"expressionValues\\"))
    #end
    #set( $ListRequest.filter = $filterExpression )
  #end
#end
#if( !$util.isNull($ctx.stash.modelQuery) )
  #set( $Query = $util.parseJson($util.transform.toDynamoDBFilterExpression($ctx.stash.modelQuery)) )
  $util.qr($ListRequest.put(\\"operation\\", \\"Query\\"))
  $util.qr($ListRequest.put(\\"query\\", $Query))
  #if( !$util.isNull($ctx.args.sortDirection) && $ctx.args.sortDirection == \\"DESC\\" )
    #set( $ListRequest.scanIndexForward = false )
  #else
    #set( $ListRequest.scanIndexForward = true )
  #end
#else
  $util.qr($ListRequest.put(\\"operation\\", \\"Scan\\"))
#end
#if( !$util.isNull($ctx.stash.metadata.index) )
  #set( $ListRequest.IndexName = $ctx.stash.metadata.index )
#end
$util.toJson($ListRequest)
## [End] List Request. **",
  "Query.listTests.res.vtl": "## [Start] Get ResponseTemplate. **
#if( $ctx.error )
  $util.error($ctx.error.message, $ctx.error.type)
#else
  $util.toJson($ctx.result)
#end
## [End] Get ResponseTemplate. **",
  "Subscription.onCreateTest.req.vtl": "## [Start] Subscription Request template. **
$util.toJson({
  \\"version\\": \\"2018-05-29\\",
  \\"payload\\": {}
})
## [End] Subscription Request template. **",
  "Subscription.onCreateTest.res.vtl": "## [Start] Subscription Resonse template. **
$util.toJson(null)
## [End] Subscription Resonse template. **",
  "Subscription.onDeleteTest.req.vtl": "## [Start] Subscription Request template. **
$util.toJson({
  \\"version\\": \\"2018-05-29\\",
  \\"payload\\": {}
})
## [End] Subscription Request template. **",
  "Subscription.onDeleteTest.res.vtl": "## [Start] Subscription Resonse template. **
$util.toJson(null)
## [End] Subscription Resonse template. **",
  "Subscription.onUpdateTest.req.vtl": "## [Start] Subscription Request template. **
$util.toJson({
  \\"version\\": \\"2018-05-29\\",
  \\"payload\\": {}
})
## [End] Subscription Request template. **",
  "Subscription.onUpdateTest.res.vtl": "## [Start] Subscription Resonse template. **
$util.toJson(null)
## [End] Subscription Resonse template. **",
}
`;

exports[`a primary key with no sort key is properly configured 1`] = `
Object {
  "Mutation.createTest.init.1.req.vtl": "## [Start] Initialization default values. **
$util.qr($ctx.stash.put(\\"defaultValues\\", $util.defaultIfNull($ctx.stash.defaultValues, {})))
#set( $createdAt = $util.time.nowISO8601() )
$util.qr($ctx.stash.defaultValues.put(\\"id\\", $util.autoId()))
$util.qr($ctx.stash.defaultValues.put(\\"createdAt\\", $createdAt))
$util.qr($ctx.stash.defaultValues.put(\\"updatedAt\\", $createdAt))
$util.toJson({
  \\"version\\": \\"2018-05-29\\",
  \\"payload\\": {}
})
## [End] Initialization default values. **",
  "Mutation.createTest.req.vtl": "## [Start] Set the primary key. **
#set( $modelObjectKey = {
  \\"email\\": $util.dynamodb.toDynamoDB($ctx.args.input.email)
} )
## [End] Set the primary key. **

## [Start] Create Request template. **
## Begin - KeyCondition **
#if( $ctx.stash.metadata.modelObjectKey )
  #set( $keyConditionExpr = {} )
  #foreach( $entry in $ctx.stash.metadata.modelObjectKey.entrySet() )
    $util.qr($keyConditionExpr.add(\\"$entry.key\\", {
  \\"attributeExists\\": true
}))
  #end
  $util.qr($ctx.stash.conditions.add($keyConditionExpr))
#else
  $util.qr($ctx.stash.conditions.add({
  \\"id\\": {
      \\"attributeExists\\": false
  }
}))
#end
## End - KeyCondition **
## Set the default values to put request **
#set( $mergedValues = $util.defaultIfNull($ctx.stash.defaultValues, {}) )
## copy the values from input **
$util.qr($mergedValues.putAll($util.defaultIfNull($ctx.args.input, {})))
## set the typename **
$util.qr($mergedValues.put(\\"__typename\\", \\"Test\\"))
#set( $PutObject = {
  \\"version\\": \\"2018-05-29\\",
  \\"operation\\": \\"PutItem\\",
  \\"attributeValues\\":   $util.dynamodb.toMapValues($mergedValues),
  \\"condition\\": $condition
} )
#if( $context.args.condition )
  $util.qr($ctx.stash.conditions.add($context.args.condition))
#end
## Begin - KeyCondition **
#if( $ctx.stash.metadata.modelObjectKey )
  #set( $keyConditionExpr = {} )
  #foreach( $entry in $ctx.stash.metadata.modelObjectKey.entrySet() )
    $util.qr($keyConditionExpr.put(\\"$entry.key\\", {
  \\"attributeExists\\": false
}))
  #end
  $util.qr($ctx.stash.conditions.add($keyConditionExpr))
#else
  $util.qr($ctx.stash.conditions.add({
  \\"id\\": {
      \\"attributeExists\\": false
  }
}))
#end
## End - KeyCondition **
## Start condition block **
#if( $ctx.stash.conditions && $ctx.stash.conditions.size() != 0 )
  #set( $mergedConditions = {
  \\"and\\": $ctx.stash.conditions
} )
  #set( $Conditions = $util.parseJson($util.transform.toDynamoDBConditionExpression($mergedConditions)) )
  #if( $Conditions.expressionValues && $Conditions.expressionValues.size() == 0 )
    #set( $Conditions = {
  \\"expression\\": $Conditions.expression,
  \\"expressionNames\\": $Conditions.expressionNames
} )
  #end
  ## End condition block **
#end
#if( $Conditions )
  $util.qr($PutObject.put(\\"condition\\", $Conditions))
#end
#if( $ctx.stash.metadata.modelObject )
  $PutObject.put(\\"id\\", $ctx.stash.metadata.modelObject)
#else
  #set( $Key = {
  \\"id\\":   $util.dynamodb.toDynamoDB($mergedValues.id)
} )
  $util.qr($PutObject.put(\\"key\\", $Key))
#end
$util.toJson($PutObject)
## [End] Create Request template. **",
  "Mutation.createTest.res.vtl": "## [Start] Get ResponseTemplate. **
#if( $ctx.error )
  $util.error($ctx.error.message, $ctx.error.type)
#else
  $util.toJson($ctx.result)
#end
## [End] Get ResponseTemplate. **",
  "Mutation.deleteTest.req.vtl": "## [Start] Set the primary key. **
#set( $modelObjectKey = {
  \\"email\\": $util.dynamodb.toDynamoDB($ctx.args.input.email)
} )
## [End] Set the primary key. **
## [Start] Delete Request template. **
#set( $DeleteRequest = {
  \\"version\\": \\"2018-05-29\\",
  \\"operation\\": \\"DeleteItem\\"
} )
#if( $ctx.stash.metadata.modelObjectKey )
  #set( $Key = $ctx.stash.metadata.modelObjectKey )
#else
  #set( $Key = {
  \\"id\\":   $util.dynamodb.toDynamoDB($ctx.args.input.id)
} )
#end
$util.qr($DeleteRequest.put(\\"key\\", $Key))
## Begin - key condition **
#if( $ctx.stash.metadata.modelObjectKey )
  #set( $keyConditionExpr = {} )
  #foreach( $entry in $ctx.stash.metadata.modelObjectKey.entrySet() )
    $util.qr($keyConditionExpr.put(\\"$entry.key\\", {
  \\"attributeExists\\": true
}))
  #end
  $util.qr($ctx.stash.conditions.add($keyConditionExpr))
#else
  $util.qr($ctx.stash.conditions.add({
  \\"id\\": {
      \\"attributeExists\\": true
  }
}))
#end
## End - key condition **
#if( $context.args.condition )
  $util.qr($ctx.stash.conditions.add($context.args.condition))
#end
## Start condition block **
#if( $ctx.stash.conditions && $ctx.stash.conditions.size() != 0 )
  #set( $mergedConditions = {
  \\"and\\": $ctx.stash.conditions
} )
  #set( $Conditions = $util.parseJson($util.transform.toDynamoDBConditionExpression($mergedConditions)) )
  #if( $Conditions.expressionValues && $Conditions.expressionValues.size() == 0 )
    #set( $Conditions = {
  \\"expression\\": $Conditions.expression,
  \\"expressionNames\\": $Conditions.expressionNames
} )
  #end
  ## End condition block **
#end
#if( $Conditions )
  $util.qr($DeleteRequest.put(\\"condition\\", $Conditions))
#end
$util.toJson($DeleteRequest)
## [End] Delete Request template. **",
  "Mutation.deleteTest.res.vtl": "## [Start] Get ResponseTemplate. **
#if( $ctx.error )
  $util.error($ctx.error.message, $ctx.error.type)
#else
  $util.toJson($ctx.result)
#end
## [End] Get ResponseTemplate. **",
  "Mutation.updateTest.init.1.req.vtl": "## [Start] Initialization default values. **
$util.qr($ctx.stash.put(\\"defaultValues\\", $util.defaultIfNull($ctx.stash.defaultValues, {})))
#set( $updatedAt = $util.time.nowISO8601() )
$util.qr($ctx.stash.defaultValues.put(\\"updatedAt\\", $updatedAt))
$util.toJson({
  \\"version\\": \\"2018-05-29\\",
  \\"payload\\": {}
})
## [End] Initialization default values. **",
  "Mutation.updateTest.req.vtl": "## [Start] Set the primary key. **
#set( $modelObjectKey = {
  \\"email\\": $util.dynamodb.toDynamoDB($ctx.args.input.email)
} )
## [End] Set the primary key. **

## [Start] Mutation Update resolver. **
## Set the default values to put request **
#set( $mergedValues = $util.defaultIfNull($ctx.stash.defaultValues, {}) )
## copy the values from input **
$util.qr($mergedValues.putAll($util.defaultIfNull($ctx.args.input, {})))
## set the typename **
## Initialize the vars for creating ddb expression **
#set( $expNames = {} )
#set( $expValues = {} )
#set( $expSet = {} )
#set( $expAdd = {} )
#set( $expRemove = [] )
#if( $ctx.stash.metadata.modelObjetKey )
  #set( $Key = $util.dynamodb.toDynamoDB($ctx.stash.metadata.modelObjetKey) )
#else
  #set( $Key = {
  \\"id\\":   $util.dynamodb.toDynamoDB($ctx.args.input.id)
} )
#end
## Model key **
#if( $ctx.stash.metadata.modelObjetKey )
  #foreach( $entry in $ctx.stash.metadata.modelObjetKey.entrySet() )
    $util.qr($keyFields.add(\\"$entry.key\\"))
  #end
#else
  #set( $keyFields = [\\"id\\"] )
#end
#foreach( $entry in $util.map.copyAndRemoveAllKeys($mergedValues, $keyFields).entrySet() )
  #if( $util.isNull($entry.value) )
    #set( $discard = $expRemove.add(\\"#$entry.key\\") )
    $util.qr($expNames.put(\\"#$entry.key\\", \\"$entry.key\\"))
  #else
    $util.qr($expSet.put(\\"#$entry.key\\", \\":$entry.key\\"))
    $util.qr($expNames.put(\\"#$entry.key\\", \\"$entry.key\\"))
    $util.qr($expValues.put(\\":$entry.key\\", $util.dynamodb.toDynamoDB($entry.value)))
  #end
#end
#set( $expression = \\"\\" )
#if( !$expSet.isEmpty() )
  #set( $expression = \\"SET\\" )
  #foreach( $entry in $expSet.entrySet() )
    #set( $expression = \\"$expression $entry.key = $entry.value\\" )
    #if( $foreach.hasNext() )
      #set( $expression = \\"$expression,\\" )
    #end
  #end
#end
#if( !$expAdd.isEmpty() )
  #set( $expression = \\"$expression ADD\\" )
  #foreach( $entry in $expAdd.entrySet() )
    #set( $expression = \\"$expression $entry.key $entry.value\\" )
    #if( $foreach.hasNext() )
      #set( $expression = \\"$expression,\\" )
    #end
  #end
#end
#if( !$expRemove.isEmpty() )
  #set( $expression = \\"$expression REMOVE\\" )
  #foreach( $entry in $expRemove )
    #set( $expression = \\"$expression $entry\\" )
    #if( $foreach.hasNext() )
      #set( $expression = \\"$expression,\\" )
    #end
  #end
#end
#set( $update = {} )
$util.qr($update.put(\\"expression\\", \\"$expression\\"))
#if( !$expNames.isEmpty() )
  $util.qr($update.put(\\"expressionNames\\", $expNames))
#end
#if( !$expValues.isEmpty() )
  $util.qr($update.put(\\"expressionValues\\", $expValues))
#end
## Begin - key condition **
#if( $ctx.stash.metadata.modelObjectKey )
  #set( $keyConditionExpr = {} )
  #foreach( $entry in $ctx.stash.metadata.modelObjectKey.entrySet() )
    $util.qr($keyConditionExpr.put(\\"$entry.key\\", {
  \\"attributeExists\\": true
}))
  #end
  $util.qr($ctx.stash.conditions.add($keyConditionExpr))
#else
  $util.qr($ctx.stash.conditions.add({
  \\"id\\": {
      \\"attributeExists\\": true
  }
}))
#end
## End - key condition **
#if( $context.args.condition )
  $util.qr($ctx.stash.conditions.add($context.args.condition))
#end
## Start condition block **
#if( $ctx.stash.conditions && $ctx.stash.conditions.size() != 0 )
  #set( $mergedConditions = {
  \\"and\\": $ctx.stash.conditions
} )
  #set( $Conditions = $util.parseJson($util.transform.toDynamoDBConditionExpression($mergedConditions)) )
  #if( $Conditions.expressionValues && $Conditions.expressionValues.size() == 0 )
    #set( $Conditions = {
  \\"expression\\": $Conditions.expression,
  \\"expressionNames\\": $Conditions.expressionNames
} )
  #end
  ## End condition block **
#end
#set( $UpdateItem = {
  \\"version\\": \\"2018-05-29\\",
  \\"operation\\": \\"UpdateItem\\",
  \\"key\\": $Key,
  \\"update\\": $update
} )
#if( $Conditions )
  $util.qr($UpdateItem.put(\\"condition\\", $Conditions))
#end
$util.toJson($UpdateItem)
## [End] Mutation Update resolver. **",
  "Mutation.updateTest.res.vtl": "## [Start] Get ResponseTemplate. **
#if( $ctx.error )
  $util.error($ctx.error.message, $ctx.error.type)
#else
  $util.toJson($ctx.result)
#end
## [End] Get ResponseTemplate. **",
  "Query.getTest.req.vtl": "## [Start] Set the primary key. **
#set( $modelObjectKey = {
  \\"email\\": $util.dynamodb.toDynamoDB($ctx.args.email)
} )
## [End] Set the primary key. **
## [Start] Get Request template. **
#set( $GetRequest = {
  \\"version\\": \\"2018-05-29\\",
  \\"operation\\": \\"GetItem\\"
} )
#if( $ctx.stash.metadata.modelKeyObject )
  #set( $Key = $ctx.stash.metadata.modelKeyObject )
#else
  #set( $key = {
  \\"id\\":   $util.dynamodb.toDynamoDB($ctx.args.id)
} )
#end
$util.qr($GetRequest.put(\\"key\\", $key))
$util.toJson($GetRequest)
## [End] Get Request template. **",
  "Query.getTest.res.vtl": "## [Start] Get ResponseTemplate. **
#if( $ctx.error )
  $util.error($ctx.error.message, $ctx.error.type)
#else
  $util.toJson($ctx.result)
#end
## [End] Get ResponseTemplate. **",
  "Query.listTests.req.vtl": "## [Start] Set query expression for key **
#if( !$util.isNull($ctx.args.sortDirection) )
  $util.error(\\"sortDirection is not supported for List operations without a Sort key defined.\\", \\"InvalidArgumentsError\\")
#end
#set( $modelQueryExpression = {} )
#if( !$util.isNull($ctx.args.email) )
  #set( $modelQueryExpression.expression = \\"#email = :email\\" )
  #set( $modelQueryExpression.expressionNames = {
  \\"#email\\": \\"email\\"
} )
  #set( $modelQueryExpression.expressionValues = {
  \\":email\\": {
      \\"S\\": \\"$ctx.args.email\\"
  }
} )
#end
## [End] Set query expression for key **
## [Start] List Request. **
#set( $limit = $util.defaultIfNull($context.args.limit, 100) )
#set( $ListRequest = {
  \\"version\\": \\"2018-05-29\\",
  \\"limit\\": $limit
} )
#if( $context.args.nextToken )
  #set( $ListRequest.nextToken = $context.args.nextToken )
#end
#if( $context.args.filter )
  #set( $filterExpression = $util.parseJson($util.transform.toDynamoDBFilterExpression($ctx.args.filter)) )
  #if( !$util.isNullOrBlank($filterExpression.expression) )
    #if( $filterEpression.expressionValues.size() == 0 )
      $util.qr($filterEpression.remove(\\"expressionValues\\"))
    #end
    #set( $ListRequest.filter = $filterExpression )
  #end
#end
#if( !$util.isNull($ctx.stash.modelQuery) )
  #set( $Query = $util.parseJson($util.transform.toDynamoDBFilterExpression($ctx.stash.modelQuery)) )
  $util.qr($ListRequest.put(\\"operation\\", \\"Query\\"))
  $util.qr($ListRequest.put(\\"query\\", $Query))
  #if( !$util.isNull($ctx.args.sortDirection) && $ctx.args.sortDirection == \\"DESC\\" )
    #set( $ListRequest.scanIndexForward = false )
  #else
    #set( $ListRequest.scanIndexForward = true )
  #end
#else
  $util.qr($ListRequest.put(\\"operation\\", \\"Scan\\"))
#end
#if( !$util.isNull($ctx.stash.metadata.index) )
  #set( $ListRequest.IndexName = $ctx.stash.metadata.index )
#end
$util.toJson($ListRequest)
## [End] List Request. **",
  "Query.listTests.res.vtl": "## [Start] Get ResponseTemplate. **
#if( $ctx.error )
  $util.error($ctx.error.message, $ctx.error.type)
#else
  $util.toJson($ctx.result)
#end
## [End] Get ResponseTemplate. **",
  "Subscription.onCreateTest.req.vtl": "## [Start] Subscription Request template. **
$util.toJson({
  \\"version\\": \\"2018-05-29\\",
  \\"payload\\": {}
})
## [End] Subscription Request template. **",
  "Subscription.onCreateTest.res.vtl": "## [Start] Subscription Resonse template. **
$util.toJson(null)
## [End] Subscription Resonse template. **",
  "Subscription.onDeleteTest.req.vtl": "## [Start] Subscription Request template. **
$util.toJson({
  \\"version\\": \\"2018-05-29\\",
  \\"payload\\": {}
})
## [End] Subscription Request template. **",
  "Subscription.onDeleteTest.res.vtl": "## [Start] Subscription Resonse template. **
$util.toJson(null)
## [End] Subscription Resonse template. **",
  "Subscription.onUpdateTest.req.vtl": "## [Start] Subscription Request template. **
$util.toJson({
  \\"version\\": \\"2018-05-29\\",
  \\"payload\\": {}
})
## [End] Subscription Request template. **",
  "Subscription.onUpdateTest.res.vtl": "## [Start] Subscription Resonse template. **
$util.toJson(null)
## [End] Subscription Resonse template. **",
}
`;

exports[`enums are supported in keys 1`] = `
Object {
  "Mutation.createTest.init.1.req.vtl": "## [Start] Initialization default values. **
$util.qr($ctx.stash.put(\\"defaultValues\\", $util.defaultIfNull($ctx.stash.defaultValues, {})))
#set( $createdAt = $util.time.nowISO8601() )
$util.qr($ctx.stash.defaultValues.put(\\"id\\", $util.autoId()))
$util.qr($ctx.stash.defaultValues.put(\\"createdAt\\", $createdAt))
$util.qr($ctx.stash.defaultValues.put(\\"updatedAt\\", $createdAt))
$util.toJson({
  \\"version\\": \\"2018-05-29\\",
  \\"payload\\": {}
})
## [End] Initialization default values. **",
  "Mutation.createTest.req.vtl": "## [Start] Set the primary key. **
#set( $modelObjectKey = {
  \\"status\\": $util.dynamodb.toDynamoDB($ctx.args.input.status),
  \\"lastStatus\\": $util.dynamodb.toDynamoDB($ctx.args.input.lastStatus)
} )
## [End] Set the primary key. **

## [Start] Create Request template. **
## Begin - KeyCondition **
#if( $ctx.stash.metadata.modelObjectKey )
  #set( $keyConditionExpr = {} )
  #foreach( $entry in $ctx.stash.metadata.modelObjectKey.entrySet() )
    $util.qr($keyConditionExpr.add(\\"$entry.key\\", {
  \\"attributeExists\\": true
}))
  #end
  $util.qr($ctx.stash.conditions.add($keyConditionExpr))
#else
  $util.qr($ctx.stash.conditions.add({
  \\"id\\": {
      \\"attributeExists\\": false
  }
}))
#end
## End - KeyCondition **
## Set the default values to put request **
#set( $mergedValues = $util.defaultIfNull($ctx.stash.defaultValues, {}) )
## copy the values from input **
$util.qr($mergedValues.putAll($util.defaultIfNull($ctx.args.input, {})))
## set the typename **
$util.qr($mergedValues.put(\\"__typename\\", \\"Test\\"))
#set( $PutObject = {
  \\"version\\": \\"2018-05-29\\",
  \\"operation\\": \\"PutItem\\",
  \\"attributeValues\\":   $util.dynamodb.toMapValues($mergedValues),
  \\"condition\\": $condition
} )
#if( $context.args.condition )
  $util.qr($ctx.stash.conditions.add($context.args.condition))
#end
## Begin - KeyCondition **
#if( $ctx.stash.metadata.modelObjectKey )
  #set( $keyConditionExpr = {} )
  #foreach( $entry in $ctx.stash.metadata.modelObjectKey.entrySet() )
    $util.qr($keyConditionExpr.put(\\"$entry.key\\", {
  \\"attributeExists\\": false
}))
  #end
  $util.qr($ctx.stash.conditions.add($keyConditionExpr))
#else
  $util.qr($ctx.stash.conditions.add({
  \\"id\\": {
      \\"attributeExists\\": false
  }
}))
#end
## End - KeyCondition **
## Start condition block **
#if( $ctx.stash.conditions && $ctx.stash.conditions.size() != 0 )
  #set( $mergedConditions = {
  \\"and\\": $ctx.stash.conditions
} )
  #set( $Conditions = $util.parseJson($util.transform.toDynamoDBConditionExpression($mergedConditions)) )
  #if( $Conditions.expressionValues && $Conditions.expressionValues.size() == 0 )
    #set( $Conditions = {
  \\"expression\\": $Conditions.expression,
  \\"expressionNames\\": $Conditions.expressionNames
} )
  #end
  ## End condition block **
#end
#if( $Conditions )
  $util.qr($PutObject.put(\\"condition\\", $Conditions))
#end
#if( $ctx.stash.metadata.modelObject )
  $PutObject.put(\\"id\\", $ctx.stash.metadata.modelObject)
#else
  #set( $Key = {
  \\"id\\":   $util.dynamodb.toDynamoDB($mergedValues.id)
} )
  $util.qr($PutObject.put(\\"key\\", $Key))
#end
$util.toJson($PutObject)
## [End] Create Request template. **",
  "Mutation.createTest.res.vtl": "## [Start] Get ResponseTemplate. **
#if( $ctx.error )
  $util.error($ctx.error.message, $ctx.error.type)
#else
  $util.toJson($ctx.result)
#end
## [End] Get ResponseTemplate. **",
  "Mutation.deleteTest.req.vtl": "## [Start] Set the primary key. **
#set( $modelObjectKey = {
  \\"status\\": $util.dynamodb.toDynamoDB($ctx.args.input.status),
  \\"lastStatus\\": $util.dynamodb.toDynamoDB($ctx.args.input.lastStatus)
} )
## [End] Set the primary key. **
## [Start] Delete Request template. **
#set( $DeleteRequest = {
  \\"version\\": \\"2018-05-29\\",
  \\"operation\\": \\"DeleteItem\\"
} )
#if( $ctx.stash.metadata.modelObjectKey )
  #set( $Key = $ctx.stash.metadata.modelObjectKey )
#else
  #set( $Key = {
  \\"id\\":   $util.dynamodb.toDynamoDB($ctx.args.input.id)
} )
#end
$util.qr($DeleteRequest.put(\\"key\\", $Key))
## Begin - key condition **
#if( $ctx.stash.metadata.modelObjectKey )
  #set( $keyConditionExpr = {} )
  #foreach( $entry in $ctx.stash.metadata.modelObjectKey.entrySet() )
    $util.qr($keyConditionExpr.put(\\"$entry.key\\", {
  \\"attributeExists\\": true
}))
  #end
  $util.qr($ctx.stash.conditions.add($keyConditionExpr))
#else
  $util.qr($ctx.stash.conditions.add({
  \\"id\\": {
      \\"attributeExists\\": true
  }
}))
#end
## End - key condition **
#if( $context.args.condition )
  $util.qr($ctx.stash.conditions.add($context.args.condition))
#end
## Start condition block **
#if( $ctx.stash.conditions && $ctx.stash.conditions.size() != 0 )
  #set( $mergedConditions = {
  \\"and\\": $ctx.stash.conditions
} )
  #set( $Conditions = $util.parseJson($util.transform.toDynamoDBConditionExpression($mergedConditions)) )
  #if( $Conditions.expressionValues && $Conditions.expressionValues.size() == 0 )
    #set( $Conditions = {
  \\"expression\\": $Conditions.expression,
  \\"expressionNames\\": $Conditions.expressionNames
} )
  #end
  ## End condition block **
#end
#if( $Conditions )
  $util.qr($DeleteRequest.put(\\"condition\\", $Conditions))
#end
$util.toJson($DeleteRequest)
## [End] Delete Request template. **",
  "Mutation.deleteTest.res.vtl": "## [Start] Get ResponseTemplate. **
#if( $ctx.error )
  $util.error($ctx.error.message, $ctx.error.type)
#else
  $util.toJson($ctx.result)
#end
## [End] Get ResponseTemplate. **",
  "Mutation.updateTest.init.1.req.vtl": "## [Start] Initialization default values. **
$util.qr($ctx.stash.put(\\"defaultValues\\", $util.defaultIfNull($ctx.stash.defaultValues, {})))
#set( $updatedAt = $util.time.nowISO8601() )
$util.qr($ctx.stash.defaultValues.put(\\"updatedAt\\", $updatedAt))
$util.toJson({
  \\"version\\": \\"2018-05-29\\",
  \\"payload\\": {}
})
## [End] Initialization default values. **",
  "Mutation.updateTest.req.vtl": "## [Start] Set the primary key. **
#set( $modelObjectKey = {
  \\"status\\": $util.dynamodb.toDynamoDB($ctx.args.input.status),
  \\"lastStatus\\": $util.dynamodb.toDynamoDB($ctx.args.input.lastStatus)
} )
## [End] Set the primary key. **

## [Start] Mutation Update resolver. **
## Set the default values to put request **
#set( $mergedValues = $util.defaultIfNull($ctx.stash.defaultValues, {}) )
## copy the values from input **
$util.qr($mergedValues.putAll($util.defaultIfNull($ctx.args.input, {})))
## set the typename **
## Initialize the vars for creating ddb expression **
#set( $expNames = {} )
#set( $expValues = {} )
#set( $expSet = {} )
#set( $expAdd = {} )
#set( $expRemove = [] )
#if( $ctx.stash.metadata.modelObjetKey )
  #set( $Key = $util.dynamodb.toDynamoDB($ctx.stash.metadata.modelObjetKey) )
#else
  #set( $Key = {
  \\"id\\":   $util.dynamodb.toDynamoDB($ctx.args.input.id)
} )
#end
## Model key **
#if( $ctx.stash.metadata.modelObjetKey )
  #foreach( $entry in $ctx.stash.metadata.modelObjetKey.entrySet() )
    $util.qr($keyFields.add(\\"$entry.key\\"))
  #end
#else
  #set( $keyFields = [\\"id\\"] )
#end
#foreach( $entry in $util.map.copyAndRemoveAllKeys($mergedValues, $keyFields).entrySet() )
  #if( $util.isNull($entry.value) )
    #set( $discard = $expRemove.add(\\"#$entry.key\\") )
    $util.qr($expNames.put(\\"#$entry.key\\", \\"$entry.key\\"))
  #else
    $util.qr($expSet.put(\\"#$entry.key\\", \\":$entry.key\\"))
    $util.qr($expNames.put(\\"#$entry.key\\", \\"$entry.key\\"))
    $util.qr($expValues.put(\\":$entry.key\\", $util.dynamodb.toDynamoDB($entry.value)))
  #end
#end
#set( $expression = \\"\\" )
#if( !$expSet.isEmpty() )
  #set( $expression = \\"SET\\" )
  #foreach( $entry in $expSet.entrySet() )
    #set( $expression = \\"$expression $entry.key = $entry.value\\" )
    #if( $foreach.hasNext() )
      #set( $expression = \\"$expression,\\" )
    #end
  #end
#end
#if( !$expAdd.isEmpty() )
  #set( $expression = \\"$expression ADD\\" )
  #foreach( $entry in $expAdd.entrySet() )
    #set( $expression = \\"$expression $entry.key $entry.value\\" )
    #if( $foreach.hasNext() )
      #set( $expression = \\"$expression,\\" )
    #end
  #end
#end
#if( !$expRemove.isEmpty() )
  #set( $expression = \\"$expression REMOVE\\" )
  #foreach( $entry in $expRemove )
    #set( $expression = \\"$expression $entry\\" )
    #if( $foreach.hasNext() )
      #set( $expression = \\"$expression,\\" )
    #end
  #end
#end
#set( $update = {} )
$util.qr($update.put(\\"expression\\", \\"$expression\\"))
#if( !$expNames.isEmpty() )
  $util.qr($update.put(\\"expressionNames\\", $expNames))
#end
#if( !$expValues.isEmpty() )
  $util.qr($update.put(\\"expressionValues\\", $expValues))
#end
## Begin - key condition **
#if( $ctx.stash.metadata.modelObjectKey )
  #set( $keyConditionExpr = {} )
  #foreach( $entry in $ctx.stash.metadata.modelObjectKey.entrySet() )
    $util.qr($keyConditionExpr.put(\\"$entry.key\\", {
  \\"attributeExists\\": true
}))
  #end
  $util.qr($ctx.stash.conditions.add($keyConditionExpr))
#else
  $util.qr($ctx.stash.conditions.add({
  \\"id\\": {
      \\"attributeExists\\": true
  }
}))
#end
## End - key condition **
#if( $context.args.condition )
  $util.qr($ctx.stash.conditions.add($context.args.condition))
#end
## Start condition block **
#if( $ctx.stash.conditions && $ctx.stash.conditions.size() != 0 )
  #set( $mergedConditions = {
  \\"and\\": $ctx.stash.conditions
} )
  #set( $Conditions = $util.parseJson($util.transform.toDynamoDBConditionExpression($mergedConditions)) )
  #if( $Conditions.expressionValues && $Conditions.expressionValues.size() == 0 )
    #set( $Conditions = {
  \\"expression\\": $Conditions.expression,
  \\"expressionNames\\": $Conditions.expressionNames
} )
  #end
  ## End condition block **
#end
#set( $UpdateItem = {
  \\"version\\": \\"2018-05-29\\",
  \\"operation\\": \\"UpdateItem\\",
  \\"key\\": $Key,
  \\"update\\": $update
} )
#if( $Conditions )
  $util.qr($UpdateItem.put(\\"condition\\", $Conditions))
#end
$util.toJson($UpdateItem)
## [End] Mutation Update resolver. **",
  "Mutation.updateTest.res.vtl": "## [Start] Get ResponseTemplate. **
#if( $ctx.error )
  $util.error($ctx.error.message, $ctx.error.type)
#else
  $util.toJson($ctx.result)
#end
## [End] Get ResponseTemplate. **",
  "Query.getTest.req.vtl": "## [Start] Set the primary key. **
#set( $modelObjectKey = {
  \\"status\\": $util.dynamodb.toDynamoDB($ctx.args.status),
  \\"lastStatus\\": $util.dynamodb.toDynamoDB($ctx.args.lastStatus)
} )
## [End] Set the primary key. **
## [Start] Get Request template. **
#set( $GetRequest = {
  \\"version\\": \\"2018-05-29\\",
  \\"operation\\": \\"GetItem\\"
} )
#if( $ctx.stash.metadata.modelKeyObject )
  #set( $Key = $ctx.stash.metadata.modelKeyObject )
#else
  #set( $key = {
  \\"id\\":   $util.dynamodb.toDynamoDB($ctx.args.id)
} )
#end
$util.qr($GetRequest.put(\\"key\\", $key))
$util.toJson($GetRequest)
## [End] Get Request template. **",
  "Query.getTest.res.vtl": "## [Start] Get ResponseTemplate. **
#if( $ctx.error )
  $util.error($ctx.error.message, $ctx.error.type)
#else
  $util.toJson($ctx.result)
#end
## [End] Get ResponseTemplate. **",
  "Query.listTests.req.vtl": "## [Start] Set query expression for key **
#if( $util.isNull($ctx.args.status) && !$util.isNull($ctx.args.sortDirection) )
  $util.error(\\"When providing argument 'sortDirection' you must also provide argument 'status'.\\", \\"InvalidArgumentsError\\")
#end
#set( $modelQueryExpression = {} )
## [Start] Validate key arguments. **
#if( !$util.isNull($ctx.args.lastStatus) && $util.isNull($ctx.args.status) )
  $util.error(\\"When providing argument 'lastStatus' you must also provide arguments status\\", \\"InvalidArgumentsError\\")
#end
## [End] Validate key arguments. **
#if( !$util.isNull($ctx.args.status) )
  #set( $modelQueryExpression.expression = \\"#status = :status\\" )
  #set( $modelQueryExpression.expressionNames = {
  \\"#status\\": \\"status\\"
} )
  #set( $modelQueryExpression.expressionValues = {
  \\":status\\": {
      \\"S\\": \\"$ctx.args.status\\"
  }
} )
#end
## [Start] Applying Key Condition **
#if( !$util.isNull($ctx.args.lastStatus) && !$util.isNull($ctx.args.lastStatus.beginsWith) )
  #set( $modelQueryExpression.expression = \\"$modelQueryExpression.expression AND begins_with(#sortKey, :sortKey)\\" )
  $util.qr($modelQueryExpression.expressionNames.put(\\"#sortKey\\", \\"lastStatus\\"))
  $util.qr($modelQueryExpression.expressionValues.put(\\":sortKey\\", { \\"S\\": \\"$ctx.args.lastStatus.beginsWith\\" }))
#end
#if( !$util.isNull($ctx.args.lastStatus) && !$util.isNull($ctx.args.lastStatus.between) )
  #set( $modelQueryExpression.expression = \\"$modelQueryExpression.expression AND #sortKey BETWEEN :sortKey0 AND :sortKey1\\" )
  $util.qr($modelQueryExpression.expressionNames.put(\\"#sortKey\\", \\"lastStatus\\"))
  $util.qr($modelQueryExpression.expressionValues.put(\\":sortKey0\\", { \\"S\\": \\"$ctx.args.lastStatus.between[0]\\" }))
  $util.qr($modelQueryExpression.expressionValues.put(\\":sortKey1\\", { \\"S\\": \\"$ctx.args.lastStatus.between[1]\\" }))
#end
#if( !$util.isNull($ctx.args.lastStatus) && !$util.isNull($ctx.args.lastStatus.eq) )
  #set( $modelQueryExpression.expression = \\"$modelQueryExpression.expression AND #sortKey = :sortKey\\" )
  $util.qr($modelQueryExpression.expressionNames.put(\\"#sortKey\\", \\"lastStatus\\"))
  $util.qr($modelQueryExpression.expressionValues.put(\\":sortKey\\", { \\"S\\": \\"$ctx.args.lastStatus.eq\\" }))
#end
#if( !$util.isNull($ctx.args.lastStatus) && !$util.isNull($ctx.args.lastStatus.lt) )
  #set( $modelQueryExpression.expression = \\"$modelQueryExpression.expression AND #sortKey < :sortKey\\" )
  $util.qr($modelQueryExpression.expressionNames.put(\\"#sortKey\\", \\"lastStatus\\"))
  $util.qr($modelQueryExpression.expressionValues.put(\\":sortKey\\", { \\"S\\": \\"$ctx.args.lastStatus.lt\\" }))
#end
#if( !$util.isNull($ctx.args.lastStatus) && !$util.isNull($ctx.args.lastStatus.le) )
  #set( $modelQueryExpression.expression = \\"$modelQueryExpression.expression AND #sortKey <= :sortKey\\" )
  $util.qr($modelQueryExpression.expressionNames.put(\\"#sortKey\\", \\"lastStatus\\"))
  $util.qr($modelQueryExpression.expressionValues.put(\\":sortKey\\", { \\"S\\": \\"$ctx.args.lastStatus.le\\" }))
#end
#if( !$util.isNull($ctx.args.lastStatus) && !$util.isNull($ctx.args.lastStatus.gt) )
  #set( $modelQueryExpression.expression = \\"$modelQueryExpression.expression AND #sortKey > :sortKey\\" )
  $util.qr($modelQueryExpression.expressionNames.put(\\"#sortKey\\", \\"lastStatus\\"))
  $util.qr($modelQueryExpression.expressionValues.put(\\":sortKey\\", { \\"S\\": \\"$ctx.args.lastStatus.gt\\" }))
#end
#if( !$util.isNull($ctx.args.lastStatus) && !$util.isNull($ctx.args.lastStatus.ge) )
  #set( $modelQueryExpression.expression = \\"$modelQueryExpression.expression AND #sortKey >= :sortKey\\" )
  $util.qr($modelQueryExpression.expressionNames.put(\\"#sortKey\\", \\"lastStatus\\"))
  $util.qr($modelQueryExpression.expressionValues.put(\\":sortKey\\", { \\"S\\": \\"$ctx.args.lastStatus.ge\\" }))
#end
## [End] Applying Key Condition **
## [End] Set query expression for key **
## [Start] List Request. **
#set( $limit = $util.defaultIfNull($context.args.limit, 100) )
#set( $ListRequest = {
  \\"version\\": \\"2018-05-29\\",
  \\"limit\\": $limit
} )
#if( $context.args.nextToken )
  #set( $ListRequest.nextToken = $context.args.nextToken )
#end
#if( $context.args.filter )
  #set( $filterExpression = $util.parseJson($util.transform.toDynamoDBFilterExpression($ctx.args.filter)) )
  #if( !$util.isNullOrBlank($filterExpression.expression) )
    #if( $filterEpression.expressionValues.size() == 0 )
      $util.qr($filterEpression.remove(\\"expressionValues\\"))
    #end
    #set( $ListRequest.filter = $filterExpression )
  #end
#end
#if( !$util.isNull($ctx.stash.modelQuery) )
  #set( $Query = $util.parseJson($util.transform.toDynamoDBFilterExpression($ctx.stash.modelQuery)) )
  $util.qr($ListRequest.put(\\"operation\\", \\"Query\\"))
  $util.qr($ListRequest.put(\\"query\\", $Query))
  #if( !$util.isNull($ctx.args.sortDirection) && $ctx.args.sortDirection == \\"DESC\\" )
    #set( $ListRequest.scanIndexForward = false )
  #else
    #set( $ListRequest.scanIndexForward = true )
  #end
#else
  $util.qr($ListRequest.put(\\"operation\\", \\"Scan\\"))
#end
#if( !$util.isNull($ctx.stash.metadata.index) )
  #set( $ListRequest.IndexName = $ctx.stash.metadata.index )
#end
$util.toJson($ListRequest)
## [End] List Request. **",
  "Query.listTests.res.vtl": "## [Start] Get ResponseTemplate. **
#if( $ctx.error )
  $util.error($ctx.error.message, $ctx.error.type)
#else
  $util.toJson($ctx.result)
#end
## [End] Get ResponseTemplate. **",
  "Subscription.onCreateTest.req.vtl": "## [Start] Subscription Request template. **
$util.toJson({
  \\"version\\": \\"2018-05-29\\",
  \\"payload\\": {}
})
## [End] Subscription Request template. **",
  "Subscription.onCreateTest.res.vtl": "## [Start] Subscription Resonse template. **
$util.toJson(null)
## [End] Subscription Resonse template. **",
  "Subscription.onDeleteTest.req.vtl": "## [Start] Subscription Request template. **
$util.toJson({
  \\"version\\": \\"2018-05-29\\",
  \\"payload\\": {}
})
## [End] Subscription Request template. **",
  "Subscription.onDeleteTest.res.vtl": "## [Start] Subscription Resonse template. **
$util.toJson(null)
## [End] Subscription Resonse template. **",
  "Subscription.onUpdateTest.req.vtl": "## [Start] Subscription Request template. **
$util.toJson({
  \\"version\\": \\"2018-05-29\\",
  \\"payload\\": {}
})
## [End] Subscription Request template. **",
  "Subscription.onUpdateTest.res.vtl": "## [Start] Subscription Resonse template. **
$util.toJson(null)
## [End] Subscription Resonse template. **",
}
`;

exports[`individual resolvers can be made null by @model 1`] = `
Object {
  "Mutation.createTest.init.1.req.vtl": "## [Start] Initialization default values. **
$util.qr($ctx.stash.put(\\"defaultValues\\", $util.defaultIfNull($ctx.stash.defaultValues, {})))
#set( $createdAt = $util.time.nowISO8601() )
$util.qr($ctx.stash.defaultValues.put(\\"id\\", $util.autoId()))
$util.qr($ctx.stash.defaultValues.put(\\"createdAt\\", $createdAt))
$util.qr($ctx.stash.defaultValues.put(\\"updatedAt\\", $createdAt))
$util.toJson({
  \\"version\\": \\"2018-05-29\\",
  \\"payload\\": {}
})
## [End] Initialization default values. **",
  "Mutation.createTest.req.vtl": "## [Start] Set the primary key. **
#set( $modelObjectKey = {
  \\"id\\": $util.dynamodb.toDynamoDB($ctx.args.input.id),
  \\"email\\": $util.dynamodb.toDynamoDB($ctx.args.input.email)
} )
## [End] Set the primary key. **

## [Start] Create Request template. **
## Begin - KeyCondition **
#if( $ctx.stash.metadata.modelObjectKey )
  #set( $keyConditionExpr = {} )
  #foreach( $entry in $ctx.stash.metadata.modelObjectKey.entrySet() )
    $util.qr($keyConditionExpr.add(\\"$entry.key\\", {
  \\"attributeExists\\": true
}))
  #end
  $util.qr($ctx.stash.conditions.add($keyConditionExpr))
#else
  $util.qr($ctx.stash.conditions.add({
  \\"id\\": {
      \\"attributeExists\\": false
  }
}))
#end
## End - KeyCondition **
## Set the default values to put request **
#set( $mergedValues = $util.defaultIfNull($ctx.stash.defaultValues, {}) )
## copy the values from input **
$util.qr($mergedValues.putAll($util.defaultIfNull($ctx.args.input, {})))
## set the typename **
$util.qr($mergedValues.put(\\"__typename\\", \\"Test\\"))
#set( $PutObject = {
  \\"version\\": \\"2018-05-29\\",
  \\"operation\\": \\"PutItem\\",
  \\"attributeValues\\":   $util.dynamodb.toMapValues($mergedValues),
  \\"condition\\": $condition
} )
#if( $context.args.condition )
  $util.qr($ctx.stash.conditions.add($context.args.condition))
#end
## Begin - KeyCondition **
#if( $ctx.stash.metadata.modelObjectKey )
  #set( $keyConditionExpr = {} )
  #foreach( $entry in $ctx.stash.metadata.modelObjectKey.entrySet() )
    $util.qr($keyConditionExpr.put(\\"$entry.key\\", {
  \\"attributeExists\\": false
}))
  #end
  $util.qr($ctx.stash.conditions.add($keyConditionExpr))
#else
  $util.qr($ctx.stash.conditions.add({
  \\"id\\": {
      \\"attributeExists\\": false
  }
}))
#end
## End - KeyCondition **
## Start condition block **
#if( $ctx.stash.conditions && $ctx.stash.conditions.size() != 0 )
  #set( $mergedConditions = {
  \\"and\\": $ctx.stash.conditions
} )
  #set( $Conditions = $util.parseJson($util.transform.toDynamoDBConditionExpression($mergedConditions)) )
  #if( $Conditions.expressionValues && $Conditions.expressionValues.size() == 0 )
    #set( $Conditions = {
  \\"expression\\": $Conditions.expression,
  \\"expressionNames\\": $Conditions.expressionNames
} )
  #end
  ## End condition block **
#end
#if( $Conditions )
  $util.qr($PutObject.put(\\"condition\\", $Conditions))
#end
#if( $ctx.stash.metadata.modelObject )
  $PutObject.put(\\"id\\", $ctx.stash.metadata.modelObject)
#else
  #set( $Key = {
  \\"id\\":   $util.dynamodb.toDynamoDB($mergedValues.id)
} )
  $util.qr($PutObject.put(\\"key\\", $Key))
#end
$util.toJson($PutObject)
## [End] Create Request template. **",
  "Mutation.createTest.res.vtl": "## [Start] Get ResponseTemplate. **
#if( $ctx.error )
  $util.error($ctx.error.message, $ctx.error.type)
#else
  $util.toJson($ctx.result)
#end
## [End] Get ResponseTemplate. **",
  "Mutation.deleteTest.req.vtl": "## [Start] Set the primary key. **
#set( $modelObjectKey = {
  \\"id\\": $util.dynamodb.toDynamoDB($ctx.args.input.id),
  \\"email\\": $util.dynamodb.toDynamoDB($ctx.args.input.email)
} )
## [End] Set the primary key. **
## [Start] Delete Request template. **
#set( $DeleteRequest = {
  \\"version\\": \\"2018-05-29\\",
  \\"operation\\": \\"DeleteItem\\"
} )
#if( $ctx.stash.metadata.modelObjectKey )
  #set( $Key = $ctx.stash.metadata.modelObjectKey )
#else
  #set( $Key = {
  \\"id\\":   $util.dynamodb.toDynamoDB($ctx.args.input.id)
} )
#end
$util.qr($DeleteRequest.put(\\"key\\", $Key))
## Begin - key condition **
#if( $ctx.stash.metadata.modelObjectKey )
  #set( $keyConditionExpr = {} )
  #foreach( $entry in $ctx.stash.metadata.modelObjectKey.entrySet() )
    $util.qr($keyConditionExpr.put(\\"$entry.key\\", {
  \\"attributeExists\\": true
}))
  #end
  $util.qr($ctx.stash.conditions.add($keyConditionExpr))
#else
  $util.qr($ctx.stash.conditions.add({
  \\"id\\": {
      \\"attributeExists\\": true
  }
}))
#end
## End - key condition **
#if( $context.args.condition )
  $util.qr($ctx.stash.conditions.add($context.args.condition))
#end
## Start condition block **
#if( $ctx.stash.conditions && $ctx.stash.conditions.size() != 0 )
  #set( $mergedConditions = {
  \\"and\\": $ctx.stash.conditions
} )
  #set( $Conditions = $util.parseJson($util.transform.toDynamoDBConditionExpression($mergedConditions)) )
  #if( $Conditions.expressionValues && $Conditions.expressionValues.size() == 0 )
    #set( $Conditions = {
  \\"expression\\": $Conditions.expression,
  \\"expressionNames\\": $Conditions.expressionNames
} )
  #end
  ## End condition block **
#end
#if( $Conditions )
  $util.qr($DeleteRequest.put(\\"condition\\", $Conditions))
#end
$util.toJson($DeleteRequest)
## [End] Delete Request template. **",
  "Mutation.deleteTest.res.vtl": "## [Start] Get ResponseTemplate. **
#if( $ctx.error )
  $util.error($ctx.error.message, $ctx.error.type)
#else
  $util.toJson($ctx.result)
#end
## [End] Get ResponseTemplate. **",
  "Mutation.testCreate.init.1.req.vtl": "## [Start] Initialization default values. **
$util.qr($ctx.stash.put(\\"defaultValues\\", $util.defaultIfNull($ctx.stash.defaultValues, {})))
#set( $createdAt = $util.time.nowISO8601() )
$util.qr($ctx.stash.defaultValues.put(\\"id\\", $util.autoId()))
$util.qr($ctx.stash.defaultValues.put(\\"createdAt\\", $createdAt))
$util.qr($ctx.stash.defaultValues.put(\\"updatedAt\\", $createdAt))
$util.toJson({
  \\"version\\": \\"2018-05-29\\",
  \\"payload\\": {}
})
## [End] Initialization default values. **",
  "Mutation.testCreate.req.vtl": "## [Start] Set the primary key. **
#set( $modelObjectKey = {
  \\"id\\": $util.dynamodb.toDynamoDB($ctx.args.input.id),
  \\"email\\": $util.dynamodb.toDynamoDB($ctx.args.input.email)
} )
## [End] Set the primary key. **

## [Start] Create Request template. **
## Begin - KeyCondition **
#if( $ctx.stash.metadata.modelObjectKey )
  #set( $keyConditionExpr = {} )
  #foreach( $entry in $ctx.stash.metadata.modelObjectKey.entrySet() )
    $util.qr($keyConditionExpr.add(\\"$entry.key\\", {
  \\"attributeExists\\": true
}))
  #end
  $util.qr($ctx.stash.conditions.add($keyConditionExpr))
#else
  $util.qr($ctx.stash.conditions.add({
  \\"id\\": {
      \\"attributeExists\\": false
  }
}))
#end
## End - KeyCondition **
## Set the default values to put request **
#set( $mergedValues = $util.defaultIfNull($ctx.stash.defaultValues, {}) )
## copy the values from input **
$util.qr($mergedValues.putAll($util.defaultIfNull($ctx.args.input, {})))
## set the typename **
$util.qr($mergedValues.put(\\"__typename\\", \\"Test\\"))
#set( $PutObject = {
  \\"version\\": \\"2018-05-29\\",
  \\"operation\\": \\"PutItem\\",
  \\"attributeValues\\":   $util.dynamodb.toMapValues($mergedValues),
  \\"condition\\": $condition
} )
#if( $context.args.condition )
  $util.qr($ctx.stash.conditions.add($context.args.condition))
#end
## Begin - KeyCondition **
#if( $ctx.stash.metadata.modelObjectKey )
  #set( $keyConditionExpr = {} )
  #foreach( $entry in $ctx.stash.metadata.modelObjectKey.entrySet() )
    $util.qr($keyConditionExpr.put(\\"$entry.key\\", {
  \\"attributeExists\\": false
}))
  #end
  $util.qr($ctx.stash.conditions.add($keyConditionExpr))
#else
  $util.qr($ctx.stash.conditions.add({
  \\"id\\": {
      \\"attributeExists\\": false
  }
}))
#end
## End - KeyCondition **
## Start condition block **
#if( $ctx.stash.conditions && $ctx.stash.conditions.size() != 0 )
  #set( $mergedConditions = {
  \\"and\\": $ctx.stash.conditions
} )
  #set( $Conditions = $util.parseJson($util.transform.toDynamoDBConditionExpression($mergedConditions)) )
  #if( $Conditions.expressionValues && $Conditions.expressionValues.size() == 0 )
    #set( $Conditions = {
  \\"expression\\": $Conditions.expression,
  \\"expressionNames\\": $Conditions.expressionNames
} )
  #end
  ## End condition block **
#end
#if( $Conditions )
  $util.qr($PutObject.put(\\"condition\\", $Conditions))
#end
#if( $ctx.stash.metadata.modelObject )
  $PutObject.put(\\"id\\", $ctx.stash.metadata.modelObject)
#else
  #set( $Key = {
  \\"id\\":   $util.dynamodb.toDynamoDB($mergedValues.id)
} )
  $util.qr($PutObject.put(\\"key\\", $Key))
#end
$util.toJson($PutObject)
## [End] Create Request template. **",
  "Mutation.testCreate.res.vtl": "## [Start] Get ResponseTemplate. **
#if( $ctx.error )
  $util.error($ctx.error.message, $ctx.error.type)
#else
  $util.toJson($ctx.result)
#end
## [End] Get ResponseTemplate. **",
  "Mutation.testDelete.req.vtl": "## [Start] Set the primary key. **
#set( $modelObjectKey = {
  \\"id\\": $util.dynamodb.toDynamoDB($ctx.args.input.id),
  \\"email\\": $util.dynamodb.toDynamoDB($ctx.args.input.email)
} )
## [End] Set the primary key. **
## [Start] Delete Request template. **
#set( $DeleteRequest = {
  \\"version\\": \\"2018-05-29\\",
  \\"operation\\": \\"DeleteItem\\"
} )
#if( $ctx.stash.metadata.modelObjectKey )
  #set( $Key = $ctx.stash.metadata.modelObjectKey )
#else
  #set( $Key = {
  \\"id\\":   $util.dynamodb.toDynamoDB($ctx.args.input.id)
} )
#end
$util.qr($DeleteRequest.put(\\"key\\", $Key))
## Begin - key condition **
#if( $ctx.stash.metadata.modelObjectKey )
  #set( $keyConditionExpr = {} )
  #foreach( $entry in $ctx.stash.metadata.modelObjectKey.entrySet() )
    $util.qr($keyConditionExpr.put(\\"$entry.key\\", {
  \\"attributeExists\\": true
}))
  #end
  $util.qr($ctx.stash.conditions.add($keyConditionExpr))
#else
  $util.qr($ctx.stash.conditions.add({
  \\"id\\": {
      \\"attributeExists\\": true
  }
}))
#end
## End - key condition **
#if( $context.args.condition )
  $util.qr($ctx.stash.conditions.add($context.args.condition))
#end
## Start condition block **
#if( $ctx.stash.conditions && $ctx.stash.conditions.size() != 0 )
  #set( $mergedConditions = {
  \\"and\\": $ctx.stash.conditions
} )
  #set( $Conditions = $util.parseJson($util.transform.toDynamoDBConditionExpression($mergedConditions)) )
  #if( $Conditions.expressionValues && $Conditions.expressionValues.size() == 0 )
    #set( $Conditions = {
  \\"expression\\": $Conditions.expression,
  \\"expressionNames\\": $Conditions.expressionNames
} )
  #end
  ## End condition block **
#end
#if( $Conditions )
  $util.qr($DeleteRequest.put(\\"condition\\", $Conditions))
#end
$util.toJson($DeleteRequest)
## [End] Delete Request template. **",
  "Mutation.testDelete.res.vtl": "## [Start] Get ResponseTemplate. **
#if( $ctx.error )
  $util.error($ctx.error.message, $ctx.error.type)
#else
  $util.toJson($ctx.result)
#end
## [End] Get ResponseTemplate. **",
  "Mutation.testUpdate.init.1.req.vtl": "## [Start] Initialization default values. **
$util.qr($ctx.stash.put(\\"defaultValues\\", $util.defaultIfNull($ctx.stash.defaultValues, {})))
#set( $updatedAt = $util.time.nowISO8601() )
$util.qr($ctx.stash.defaultValues.put(\\"updatedAt\\", $updatedAt))
$util.toJson({
  \\"version\\": \\"2018-05-29\\",
  \\"payload\\": {}
})
## [End] Initialization default values. **",
  "Mutation.testUpdate.req.vtl": "## [Start] Set the primary key. **
#set( $modelObjectKey = {
  \\"id\\": $util.dynamodb.toDynamoDB($ctx.args.input.id),
  \\"email\\": $util.dynamodb.toDynamoDB($ctx.args.input.email)
} )
## [End] Set the primary key. **

## [Start] Mutation Update resolver. **
## Set the default values to put request **
#set( $mergedValues = $util.defaultIfNull($ctx.stash.defaultValues, {}) )
## copy the values from input **
$util.qr($mergedValues.putAll($util.defaultIfNull($ctx.args.input, {})))
## set the typename **
## Initialize the vars for creating ddb expression **
#set( $expNames = {} )
#set( $expValues = {} )
#set( $expSet = {} )
#set( $expAdd = {} )
#set( $expRemove = [] )
#if( $ctx.stash.metadata.modelObjetKey )
  #set( $Key = $util.dynamodb.toDynamoDB($ctx.stash.metadata.modelObjetKey) )
#else
  #set( $Key = {
  \\"id\\":   $util.dynamodb.toDynamoDB($ctx.args.input.id)
} )
#end
## Model key **
#if( $ctx.stash.metadata.modelObjetKey )
  #foreach( $entry in $ctx.stash.metadata.modelObjetKey.entrySet() )
    $util.qr($keyFields.add(\\"$entry.key\\"))
  #end
#else
  #set( $keyFields = [\\"id\\"] )
#end
#foreach( $entry in $util.map.copyAndRemoveAllKeys($mergedValues, $keyFields).entrySet() )
  #if( $util.isNull($entry.value) )
    #set( $discard = $expRemove.add(\\"#$entry.key\\") )
    $util.qr($expNames.put(\\"#$entry.key\\", \\"$entry.key\\"))
  #else
    $util.qr($expSet.put(\\"#$entry.key\\", \\":$entry.key\\"))
    $util.qr($expNames.put(\\"#$entry.key\\", \\"$entry.key\\"))
    $util.qr($expValues.put(\\":$entry.key\\", $util.dynamodb.toDynamoDB($entry.value)))
  #end
#end
#set( $expression = \\"\\" )
#if( !$expSet.isEmpty() )
  #set( $expression = \\"SET\\" )
  #foreach( $entry in $expSet.entrySet() )
    #set( $expression = \\"$expression $entry.key = $entry.value\\" )
    #if( $foreach.hasNext() )
      #set( $expression = \\"$expression,\\" )
    #end
  #end
#end
#if( !$expAdd.isEmpty() )
  #set( $expression = \\"$expression ADD\\" )
  #foreach( $entry in $expAdd.entrySet() )
    #set( $expression = \\"$expression $entry.key $entry.value\\" )
    #if( $foreach.hasNext() )
      #set( $expression = \\"$expression,\\" )
    #end
  #end
#end
#if( !$expRemove.isEmpty() )
  #set( $expression = \\"$expression REMOVE\\" )
  #foreach( $entry in $expRemove )
    #set( $expression = \\"$expression $entry\\" )
    #if( $foreach.hasNext() )
      #set( $expression = \\"$expression,\\" )
    #end
  #end
#end
#set( $update = {} )
$util.qr($update.put(\\"expression\\", \\"$expression\\"))
#if( !$expNames.isEmpty() )
  $util.qr($update.put(\\"expressionNames\\", $expNames))
#end
#if( !$expValues.isEmpty() )
  $util.qr($update.put(\\"expressionValues\\", $expValues))
#end
## Begin - key condition **
#if( $ctx.stash.metadata.modelObjectKey )
  #set( $keyConditionExpr = {} )
  #foreach( $entry in $ctx.stash.metadata.modelObjectKey.entrySet() )
    $util.qr($keyConditionExpr.put(\\"$entry.key\\", {
  \\"attributeExists\\": true
}))
  #end
  $util.qr($ctx.stash.conditions.add($keyConditionExpr))
#else
  $util.qr($ctx.stash.conditions.add({
  \\"id\\": {
      \\"attributeExists\\": true
  }
}))
#end
## End - key condition **
#if( $context.args.condition )
  $util.qr($ctx.stash.conditions.add($context.args.condition))
#end
## Start condition block **
#if( $ctx.stash.conditions && $ctx.stash.conditions.size() != 0 )
  #set( $mergedConditions = {
  \\"and\\": $ctx.stash.conditions
} )
  #set( $Conditions = $util.parseJson($util.transform.toDynamoDBConditionExpression($mergedConditions)) )
  #if( $Conditions.expressionValues && $Conditions.expressionValues.size() == 0 )
    #set( $Conditions = {
  \\"expression\\": $Conditions.expression,
  \\"expressionNames\\": $Conditions.expressionNames
} )
  #end
  ## End condition block **
#end
#set( $UpdateItem = {
  \\"version\\": \\"2018-05-29\\",
  \\"operation\\": \\"UpdateItem\\",
  \\"key\\": $Key,
  \\"update\\": $update
} )
#if( $Conditions )
  $util.qr($UpdateItem.put(\\"condition\\", $Conditions))
#end
$util.toJson($UpdateItem)
## [End] Mutation Update resolver. **",
  "Mutation.testUpdate.res.vtl": "## [Start] Get ResponseTemplate. **
#if( $ctx.error )
  $util.error($ctx.error.message, $ctx.error.type)
#else
  $util.toJson($ctx.result)
#end
## [End] Get ResponseTemplate. **",
  "Mutation.updateTest.init.1.req.vtl": "## [Start] Initialization default values. **
$util.qr($ctx.stash.put(\\"defaultValues\\", $util.defaultIfNull($ctx.stash.defaultValues, {})))
#set( $updatedAt = $util.time.nowISO8601() )
$util.qr($ctx.stash.defaultValues.put(\\"updatedAt\\", $updatedAt))
$util.toJson({
  \\"version\\": \\"2018-05-29\\",
  \\"payload\\": {}
})
## [End] Initialization default values. **",
  "Mutation.updateTest.req.vtl": "## [Start] Set the primary key. **
#set( $modelObjectKey = {
  \\"id\\": $util.dynamodb.toDynamoDB($ctx.args.input.id),
  \\"email\\": $util.dynamodb.toDynamoDB($ctx.args.input.email)
} )
## [End] Set the primary key. **

## [Start] Mutation Update resolver. **
## Set the default values to put request **
#set( $mergedValues = $util.defaultIfNull($ctx.stash.defaultValues, {}) )
## copy the values from input **
$util.qr($mergedValues.putAll($util.defaultIfNull($ctx.args.input, {})))
## set the typename **
## Initialize the vars for creating ddb expression **
#set( $expNames = {} )
#set( $expValues = {} )
#set( $expSet = {} )
#set( $expAdd = {} )
#set( $expRemove = [] )
#if( $ctx.stash.metadata.modelObjetKey )
  #set( $Key = $util.dynamodb.toDynamoDB($ctx.stash.metadata.modelObjetKey) )
#else
  #set( $Key = {
  \\"id\\":   $util.dynamodb.toDynamoDB($ctx.args.input.id)
} )
#end
## Model key **
#if( $ctx.stash.metadata.modelObjetKey )
  #foreach( $entry in $ctx.stash.metadata.modelObjetKey.entrySet() )
    $util.qr($keyFields.add(\\"$entry.key\\"))
  #end
#else
  #set( $keyFields = [\\"id\\"] )
#end
#foreach( $entry in $util.map.copyAndRemoveAllKeys($mergedValues, $keyFields).entrySet() )
  #if( $util.isNull($entry.value) )
    #set( $discard = $expRemove.add(\\"#$entry.key\\") )
    $util.qr($expNames.put(\\"#$entry.key\\", \\"$entry.key\\"))
  #else
    $util.qr($expSet.put(\\"#$entry.key\\", \\":$entry.key\\"))
    $util.qr($expNames.put(\\"#$entry.key\\", \\"$entry.key\\"))
    $util.qr($expValues.put(\\":$entry.key\\", $util.dynamodb.toDynamoDB($entry.value)))
  #end
#end
#set( $expression = \\"\\" )
#if( !$expSet.isEmpty() )
  #set( $expression = \\"SET\\" )
  #foreach( $entry in $expSet.entrySet() )
    #set( $expression = \\"$expression $entry.key = $entry.value\\" )
    #if( $foreach.hasNext() )
      #set( $expression = \\"$expression,\\" )
    #end
  #end
#end
#if( !$expAdd.isEmpty() )
  #set( $expression = \\"$expression ADD\\" )
  #foreach( $entry in $expAdd.entrySet() )
    #set( $expression = \\"$expression $entry.key $entry.value\\" )
    #if( $foreach.hasNext() )
      #set( $expression = \\"$expression,\\" )
    #end
  #end
#end
#if( !$expRemove.isEmpty() )
  #set( $expression = \\"$expression REMOVE\\" )
  #foreach( $entry in $expRemove )
    #set( $expression = \\"$expression $entry\\" )
    #if( $foreach.hasNext() )
      #set( $expression = \\"$expression,\\" )
    #end
  #end
#end
#set( $update = {} )
$util.qr($update.put(\\"expression\\", \\"$expression\\"))
#if( !$expNames.isEmpty() )
  $util.qr($update.put(\\"expressionNames\\", $expNames))
#end
#if( !$expValues.isEmpty() )
  $util.qr($update.put(\\"expressionValues\\", $expValues))
#end
## Begin - key condition **
#if( $ctx.stash.metadata.modelObjectKey )
  #set( $keyConditionExpr = {} )
  #foreach( $entry in $ctx.stash.metadata.modelObjectKey.entrySet() )
    $util.qr($keyConditionExpr.put(\\"$entry.key\\", {
  \\"attributeExists\\": true
}))
  #end
  $util.qr($ctx.stash.conditions.add($keyConditionExpr))
#else
  $util.qr($ctx.stash.conditions.add({
  \\"id\\": {
      \\"attributeExists\\": true
  }
}))
#end
## End - key condition **
#if( $context.args.condition )
  $util.qr($ctx.stash.conditions.add($context.args.condition))
#end
## Start condition block **
#if( $ctx.stash.conditions && $ctx.stash.conditions.size() != 0 )
  #set( $mergedConditions = {
  \\"and\\": $ctx.stash.conditions
} )
  #set( $Conditions = $util.parseJson($util.transform.toDynamoDBConditionExpression($mergedConditions)) )
  #if( $Conditions.expressionValues && $Conditions.expressionValues.size() == 0 )
    #set( $Conditions = {
  \\"expression\\": $Conditions.expression,
  \\"expressionNames\\": $Conditions.expressionNames
} )
  #end
  ## End condition block **
#end
#set( $UpdateItem = {
  \\"version\\": \\"2018-05-29\\",
  \\"operation\\": \\"UpdateItem\\",
  \\"key\\": $Key,
  \\"update\\": $update
} )
#if( $Conditions )
  $util.qr($UpdateItem.put(\\"condition\\", $Conditions))
#end
$util.toJson($UpdateItem)
## [End] Mutation Update resolver. **",
  "Mutation.updateTest.res.vtl": "## [Start] Get ResponseTemplate. **
#if( $ctx.error )
  $util.error($ctx.error.message, $ctx.error.type)
#else
  $util.toJson($ctx.result)
#end
## [End] Get ResponseTemplate. **",
  "Query.getTest.req.vtl": "## [Start] Set the primary key. **
#set( $modelObjectKey = {
  \\"email\\": $util.dynamodb.toDynamoDB($ctx.args.email)
} )
## [End] Set the primary key. **
## [Start] Get Request template. **
#set( $GetRequest = {
  \\"version\\": \\"2018-05-29\\",
  \\"operation\\": \\"GetItem\\"
} )
#if( $ctx.stash.metadata.modelKeyObject )
  #set( $Key = $ctx.stash.metadata.modelKeyObject )
#else
  #set( $key = {
  \\"id\\":   $util.dynamodb.toDynamoDB($ctx.args.id)
} )
#end
$util.qr($GetRequest.put(\\"key\\", $key))
$util.toJson($GetRequest)
## [End] Get Request template. **",
  "Query.getTest.res.vtl": "## [Start] Get ResponseTemplate. **
#if( $ctx.error )
  $util.error($ctx.error.message, $ctx.error.type)
#else
  $util.toJson($ctx.result)
#end
## [End] Get ResponseTemplate. **",
  "Query.listTests.req.vtl": "## [Start] Set query expression for key **
#if( !$util.isNull($ctx.args.sortDirection) )
  $util.error(\\"sortDirection is not supported for List operations without a Sort key defined.\\", \\"InvalidArgumentsError\\")
#end
#set( $modelQueryExpression = {} )
#if( !$util.isNull($ctx.args.email) )
  #set( $modelQueryExpression.expression = \\"#email = :email\\" )
  #set( $modelQueryExpression.expressionNames = {
  \\"#email\\": \\"email\\"
} )
  #set( $modelQueryExpression.expressionValues = {
  \\":email\\": {
      \\"S\\": \\"$ctx.args.email\\"
  }
} )
#end
## [End] Set query expression for key **
## [Start] List Request. **
#set( $limit = $util.defaultIfNull($context.args.limit, 100) )
#set( $ListRequest = {
  \\"version\\": \\"2018-05-29\\",
  \\"limit\\": $limit
} )
#if( $context.args.nextToken )
  #set( $ListRequest.nextToken = $context.args.nextToken )
#end
#if( $context.args.filter )
  #set( $filterExpression = $util.parseJson($util.transform.toDynamoDBFilterExpression($ctx.args.filter)) )
  #if( !$util.isNullOrBlank($filterExpression.expression) )
    #if( $filterEpression.expressionValues.size() == 0 )
      $util.qr($filterEpression.remove(\\"expressionValues\\"))
    #end
    #set( $ListRequest.filter = $filterExpression )
  #end
#end
#if( !$util.isNull($ctx.stash.modelQuery) )
  #set( $Query = $util.parseJson($util.transform.toDynamoDBFilterExpression($ctx.stash.modelQuery)) )
  $util.qr($ListRequest.put(\\"operation\\", \\"Query\\"))
  $util.qr($ListRequest.put(\\"query\\", $Query))
  #if( !$util.isNull($ctx.args.sortDirection) && $ctx.args.sortDirection == \\"DESC\\" )
    #set( $ListRequest.scanIndexForward = false )
  #else
    #set( $ListRequest.scanIndexForward = true )
  #end
#else
  $util.qr($ListRequest.put(\\"operation\\", \\"Scan\\"))
#end
#if( !$util.isNull($ctx.stash.metadata.index) )
  #set( $ListRequest.IndexName = $ctx.stash.metadata.index )
#end
$util.toJson($ListRequest)
## [End] List Request. **",
  "Query.listTests.res.vtl": "## [Start] Get ResponseTemplate. **
#if( $ctx.error )
  $util.error($ctx.error.message, $ctx.error.type)
#else
  $util.toJson($ctx.result)
#end
## [End] Get ResponseTemplate. **",
  "Query.testGet.req.vtl": "## [Start] Set the primary key. **
#set( $modelObjectKey = {
  \\"id\\": $util.dynamodb.toDynamoDB($ctx.args.id),
  \\"email\\": $util.dynamodb.toDynamoDB($ctx.args.email)
} )
## [End] Set the primary key. **
## [Start] Get Request template. **
#set( $GetRequest = {
  \\"version\\": \\"2018-05-29\\",
  \\"operation\\": \\"GetItem\\"
} )
#if( $ctx.stash.metadata.modelKeyObject )
  #set( $Key = $ctx.stash.metadata.modelKeyObject )
#else
  #set( $key = {
  \\"id\\":   $util.dynamodb.toDynamoDB($ctx.args.id)
} )
#end
$util.qr($GetRequest.put(\\"key\\", $key))
$util.toJson($GetRequest)
## [End] Get Request template. **",
  "Query.testGet.res.vtl": "## [Start] Get ResponseTemplate. **
#if( $ctx.error )
  $util.error($ctx.error.message, $ctx.error.type)
#else
  $util.toJson($ctx.result)
#end
## [End] Get ResponseTemplate. **",
  "Query.testList.req.vtl": "## [Start] Set query expression for key **
#if( $util.isNull($ctx.args.id) && !$util.isNull($ctx.args.sortDirection) )
  $util.error(\\"When providing argument 'sortDirection' you must also provide argument 'id'.\\", \\"InvalidArgumentsError\\")
#end
#set( $modelQueryExpression = {} )
## [Start] Validate key arguments. **
#if( !$util.isNull($ctx.args.email) && $util.isNull($ctx.args.id) )
  $util.error(\\"When providing argument 'email' you must also provide arguments id\\", \\"InvalidArgumentsError\\")
#end
## [End] Validate key arguments. **
#if( !$util.isNull($ctx.args.id) )
  #set( $modelQueryExpression.expression = \\"#id = :id\\" )
  #set( $modelQueryExpression.expressionNames = {
  \\"#id\\": \\"id\\"
} )
  #set( $modelQueryExpression.expressionValues = {
  \\":id\\": {
      \\"S\\": \\"$ctx.args.id\\"
  }
} )
#end
## [Start] Applying Key Condition **
#if( !$util.isNull($ctx.args.email) && !$util.isNull($ctx.args.email.beginsWith) )
  #set( $modelQueryExpression.expression = \\"$modelQueryExpression.expression AND begins_with(#sortKey, :sortKey)\\" )
  $util.qr($modelQueryExpression.expressionNames.put(\\"#sortKey\\", \\"email\\"))
  $util.qr($modelQueryExpression.expressionValues.put(\\":sortKey\\", { \\"S\\": \\"$ctx.args.email.beginsWith\\" }))
#end
#if( !$util.isNull($ctx.args.email) && !$util.isNull($ctx.args.email.between) )
  #set( $modelQueryExpression.expression = \\"$modelQueryExpression.expression AND #sortKey BETWEEN :sortKey0 AND :sortKey1\\" )
  $util.qr($modelQueryExpression.expressionNames.put(\\"#sortKey\\", \\"email\\"))
  $util.qr($modelQueryExpression.expressionValues.put(\\":sortKey0\\", { \\"S\\": \\"$ctx.args.email.between[0]\\" }))
  $util.qr($modelQueryExpression.expressionValues.put(\\":sortKey1\\", { \\"S\\": \\"$ctx.args.email.between[1]\\" }))
#end
#if( !$util.isNull($ctx.args.email) && !$util.isNull($ctx.args.email.eq) )
  #set( $modelQueryExpression.expression = \\"$modelQueryExpression.expression AND #sortKey = :sortKey\\" )
  $util.qr($modelQueryExpression.expressionNames.put(\\"#sortKey\\", \\"email\\"))
  $util.qr($modelQueryExpression.expressionValues.put(\\":sortKey\\", { \\"S\\": \\"$ctx.args.email.eq\\" }))
#end
#if( !$util.isNull($ctx.args.email) && !$util.isNull($ctx.args.email.lt) )
  #set( $modelQueryExpression.expression = \\"$modelQueryExpression.expression AND #sortKey < :sortKey\\" )
  $util.qr($modelQueryExpression.expressionNames.put(\\"#sortKey\\", \\"email\\"))
  $util.qr($modelQueryExpression.expressionValues.put(\\":sortKey\\", { \\"S\\": \\"$ctx.args.email.lt\\" }))
#end
#if( !$util.isNull($ctx.args.email) && !$util.isNull($ctx.args.email.le) )
  #set( $modelQueryExpression.expression = \\"$modelQueryExpression.expression AND #sortKey <= :sortKey\\" )
  $util.qr($modelQueryExpression.expressionNames.put(\\"#sortKey\\", \\"email\\"))
  $util.qr($modelQueryExpression.expressionValues.put(\\":sortKey\\", { \\"S\\": \\"$ctx.args.email.le\\" }))
#end
#if( !$util.isNull($ctx.args.email) && !$util.isNull($ctx.args.email.gt) )
  #set( $modelQueryExpression.expression = \\"$modelQueryExpression.expression AND #sortKey > :sortKey\\" )
  $util.qr($modelQueryExpression.expressionNames.put(\\"#sortKey\\", \\"email\\"))
  $util.qr($modelQueryExpression.expressionValues.put(\\":sortKey\\", { \\"S\\": \\"$ctx.args.email.gt\\" }))
#end
#if( !$util.isNull($ctx.args.email) && !$util.isNull($ctx.args.email.ge) )
  #set( $modelQueryExpression.expression = \\"$modelQueryExpression.expression AND #sortKey >= :sortKey\\" )
  $util.qr($modelQueryExpression.expressionNames.put(\\"#sortKey\\", \\"email\\"))
  $util.qr($modelQueryExpression.expressionValues.put(\\":sortKey\\", { \\"S\\": \\"$ctx.args.email.ge\\" }))
#end
## [End] Applying Key Condition **
## [End] Set query expression for key **
## [Start] List Request. **
#set( $limit = $util.defaultIfNull($context.args.limit, 100) )
#set( $ListRequest = {
  \\"version\\": \\"2018-05-29\\",
  \\"limit\\": $limit
} )
#if( $context.args.nextToken )
  #set( $ListRequest.nextToken = $context.args.nextToken )
#end
#if( $context.args.filter )
  #set( $filterExpression = $util.parseJson($util.transform.toDynamoDBFilterExpression($ctx.args.filter)) )
  #if( !$util.isNullOrBlank($filterExpression.expression) )
    #if( $filterEpression.expressionValues.size() == 0 )
      $util.qr($filterEpression.remove(\\"expressionValues\\"))
    #end
    #set( $ListRequest.filter = $filterExpression )
  #end
#end
#if( !$util.isNull($ctx.stash.modelQuery) )
  #set( $Query = $util.parseJson($util.transform.toDynamoDBFilterExpression($ctx.stash.modelQuery)) )
  $util.qr($ListRequest.put(\\"operation\\", \\"Query\\"))
  $util.qr($ListRequest.put(\\"query\\", $Query))
  #if( !$util.isNull($ctx.args.sortDirection) && $ctx.args.sortDirection == \\"DESC\\" )
    #set( $ListRequest.scanIndexForward = false )
  #else
    #set( $ListRequest.scanIndexForward = true )
  #end
#else
  $util.qr($ListRequest.put(\\"operation\\", \\"Scan\\"))
#end
#if( !$util.isNull($ctx.stash.metadata.index) )
  #set( $ListRequest.IndexName = $ctx.stash.metadata.index )
#end
$util.toJson($ListRequest)
## [End] List Request. **",
  "Query.testList.res.vtl": "## [Start] Get ResponseTemplate. **
#if( $ctx.error )
  $util.error($ctx.error.message, $ctx.error.type)
#else
  $util.toJson($ctx.result)
#end
## [End] Get ResponseTemplate. **",
  "Subscription.onCreateTest.req.vtl": "## [Start] Subscription Request template. **
$util.toJson({
  \\"version\\": \\"2018-05-29\\",
  \\"payload\\": {}
})
## [End] Subscription Request template. **",
  "Subscription.onCreateTest.res.vtl": "## [Start] Subscription Resonse template. **
$util.toJson(null)
## [End] Subscription Resonse template. **",
  "Subscription.onDeleteTest.req.vtl": "## [Start] Subscription Request template. **
$util.toJson({
  \\"version\\": \\"2018-05-29\\",
  \\"payload\\": {}
})
## [End] Subscription Request template. **",
  "Subscription.onDeleteTest.res.vtl": "## [Start] Subscription Resonse template. **
$util.toJson(null)
## [End] Subscription Resonse template. **",
  "Subscription.onUpdateTest.req.vtl": "## [Start] Subscription Request template. **
$util.toJson({
  \\"version\\": \\"2018-05-29\\",
  \\"payload\\": {}
})
## [End] Subscription Request template. **",
  "Subscription.onUpdateTest.res.vtl": "## [Start] Subscription Resonse template. **
$util.toJson(null)
## [End] Subscription Resonse template. **",
}
`;

exports[`resolvers can be renamed by @model 1`] = `
Object {
  "Mutation.createTest.init.1.req.vtl": "## [Start] Initialization default values. **
$util.qr($ctx.stash.put(\\"defaultValues\\", $util.defaultIfNull($ctx.stash.defaultValues, {})))
#set( $createdAt = $util.time.nowISO8601() )
$util.qr($ctx.stash.defaultValues.put(\\"id\\", $util.autoId()))
$util.qr($ctx.stash.defaultValues.put(\\"createdAt\\", $createdAt))
$util.qr($ctx.stash.defaultValues.put(\\"updatedAt\\", $createdAt))
$util.toJson({
  \\"version\\": \\"2018-05-29\\",
  \\"payload\\": {}
})
## [End] Initialization default values. **",
  "Mutation.createTest.req.vtl": "## [Start] Set the primary key. **
#set( $modelObjectKey = {
  \\"email\\": $util.dynamodb.toDynamoDB($ctx.args.input.email)
} )
## [End] Set the primary key. **

## [Start] Create Request template. **
## Begin - KeyCondition **
#if( $ctx.stash.metadata.modelObjectKey )
  #set( $keyConditionExpr = {} )
  #foreach( $entry in $ctx.stash.metadata.modelObjectKey.entrySet() )
    $util.qr($keyConditionExpr.add(\\"$entry.key\\", {
  \\"attributeExists\\": true
}))
  #end
  $util.qr($ctx.stash.conditions.add($keyConditionExpr))
#else
  $util.qr($ctx.stash.conditions.add({
  \\"id\\": {
      \\"attributeExists\\": false
  }
}))
#end
## End - KeyCondition **
## Set the default values to put request **
#set( $mergedValues = $util.defaultIfNull($ctx.stash.defaultValues, {}) )
## copy the values from input **
$util.qr($mergedValues.putAll($util.defaultIfNull($ctx.args.input, {})))
## set the typename **
$util.qr($mergedValues.put(\\"__typename\\", \\"Test\\"))
#set( $PutObject = {
  \\"version\\": \\"2018-05-29\\",
  \\"operation\\": \\"PutItem\\",
  \\"attributeValues\\":   $util.dynamodb.toMapValues($mergedValues),
  \\"condition\\": $condition
} )
#if( $context.args.condition )
  $util.qr($ctx.stash.conditions.add($context.args.condition))
#end
## Begin - KeyCondition **
#if( $ctx.stash.metadata.modelObjectKey )
  #set( $keyConditionExpr = {} )
  #foreach( $entry in $ctx.stash.metadata.modelObjectKey.entrySet() )
    $util.qr($keyConditionExpr.put(\\"$entry.key\\", {
  \\"attributeExists\\": false
}))
  #end
  $util.qr($ctx.stash.conditions.add($keyConditionExpr))
#else
  $util.qr($ctx.stash.conditions.add({
  \\"id\\": {
      \\"attributeExists\\": false
  }
}))
#end
## End - KeyCondition **
## Start condition block **
#if( $ctx.stash.conditions && $ctx.stash.conditions.size() != 0 )
  #set( $mergedConditions = {
  \\"and\\": $ctx.stash.conditions
} )
  #set( $Conditions = $util.parseJson($util.transform.toDynamoDBConditionExpression($mergedConditions)) )
  #if( $Conditions.expressionValues && $Conditions.expressionValues.size() == 0 )
    #set( $Conditions = {
  \\"expression\\": $Conditions.expression,
  \\"expressionNames\\": $Conditions.expressionNames
} )
  #end
  ## End condition block **
#end
#if( $Conditions )
  $util.qr($PutObject.put(\\"condition\\", $Conditions))
#end
#if( $ctx.stash.metadata.modelObject )
  $PutObject.put(\\"id\\", $ctx.stash.metadata.modelObject)
#else
  #set( $Key = {
  \\"id\\":   $util.dynamodb.toDynamoDB($mergedValues.id)
} )
  $util.qr($PutObject.put(\\"key\\", $Key))
#end
$util.toJson($PutObject)
## [End] Create Request template. **",
  "Mutation.createTest.res.vtl": "## [Start] Get ResponseTemplate. **
#if( $ctx.error )
  $util.error($ctx.error.message, $ctx.error.type)
#else
  $util.toJson($ctx.result)
#end
## [End] Get ResponseTemplate. **",
  "Mutation.deleteTest.req.vtl": "## [Start] Set the primary key. **
#set( $modelObjectKey = {
  \\"email\\": $util.dynamodb.toDynamoDB($ctx.args.input.email)
} )
## [End] Set the primary key. **
## [Start] Delete Request template. **
#set( $DeleteRequest = {
  \\"version\\": \\"2018-05-29\\",
  \\"operation\\": \\"DeleteItem\\"
} )
#if( $ctx.stash.metadata.modelObjectKey )
  #set( $Key = $ctx.stash.metadata.modelObjectKey )
#else
  #set( $Key = {
  \\"id\\":   $util.dynamodb.toDynamoDB($ctx.args.input.id)
} )
#end
$util.qr($DeleteRequest.put(\\"key\\", $Key))
## Begin - key condition **
#if( $ctx.stash.metadata.modelObjectKey )
  #set( $keyConditionExpr = {} )
  #foreach( $entry in $ctx.stash.metadata.modelObjectKey.entrySet() )
    $util.qr($keyConditionExpr.put(\\"$entry.key\\", {
  \\"attributeExists\\": true
}))
  #end
  $util.qr($ctx.stash.conditions.add($keyConditionExpr))
#else
  $util.qr($ctx.stash.conditions.add({
  \\"id\\": {
      \\"attributeExists\\": true
  }
}))
#end
## End - key condition **
#if( $context.args.condition )
  $util.qr($ctx.stash.conditions.add($context.args.condition))
#end
## Start condition block **
#if( $ctx.stash.conditions && $ctx.stash.conditions.size() != 0 )
  #set( $mergedConditions = {
  \\"and\\": $ctx.stash.conditions
} )
  #set( $Conditions = $util.parseJson($util.transform.toDynamoDBConditionExpression($mergedConditions)) )
  #if( $Conditions.expressionValues && $Conditions.expressionValues.size() == 0 )
    #set( $Conditions = {
  \\"expression\\": $Conditions.expression,
  \\"expressionNames\\": $Conditions.expressionNames
} )
  #end
  ## End condition block **
#end
#if( $Conditions )
  $util.qr($DeleteRequest.put(\\"condition\\", $Conditions))
#end
$util.toJson($DeleteRequest)
## [End] Delete Request template. **",
  "Mutation.deleteTest.res.vtl": "## [Start] Get ResponseTemplate. **
#if( $ctx.error )
  $util.error($ctx.error.message, $ctx.error.type)
#else
  $util.toJson($ctx.result)
#end
## [End] Get ResponseTemplate. **",
  "Mutation.testCreate.init.1.req.vtl": "## [Start] Initialization default values. **
$util.qr($ctx.stash.put(\\"defaultValues\\", $util.defaultIfNull($ctx.stash.defaultValues, {})))
#set( $createdAt = $util.time.nowISO8601() )
$util.qr($ctx.stash.defaultValues.put(\\"id\\", $util.autoId()))
$util.qr($ctx.stash.defaultValues.put(\\"createdAt\\", $createdAt))
$util.qr($ctx.stash.defaultValues.put(\\"updatedAt\\", $createdAt))
$util.toJson({
  \\"version\\": \\"2018-05-29\\",
  \\"payload\\": {}
})
## [End] Initialization default values. **",
  "Mutation.testCreate.req.vtl": "## [Start] Set the primary key. **
#set( $modelObjectKey = {
  \\"id\\": $util.dynamodb.toDynamoDB($ctx.args.input.id),
  \\"email\\": $util.dynamodb.toDynamoDB($ctx.args.input.email)
} )
## [End] Set the primary key. **

## [Start] Create Request template. **
## Begin - KeyCondition **
#if( $ctx.stash.metadata.modelObjectKey )
  #set( $keyConditionExpr = {} )
  #foreach( $entry in $ctx.stash.metadata.modelObjectKey.entrySet() )
    $util.qr($keyConditionExpr.add(\\"$entry.key\\", {
  \\"attributeExists\\": true
}))
  #end
  $util.qr($ctx.stash.conditions.add($keyConditionExpr))
#else
  $util.qr($ctx.stash.conditions.add({
  \\"id\\": {
      \\"attributeExists\\": false
  }
}))
#end
## End - KeyCondition **
## Set the default values to put request **
#set( $mergedValues = $util.defaultIfNull($ctx.stash.defaultValues, {}) )
## copy the values from input **
$util.qr($mergedValues.putAll($util.defaultIfNull($ctx.args.input, {})))
## set the typename **
$util.qr($mergedValues.put(\\"__typename\\", \\"Test\\"))
#set( $PutObject = {
  \\"version\\": \\"2018-05-29\\",
  \\"operation\\": \\"PutItem\\",
  \\"attributeValues\\":   $util.dynamodb.toMapValues($mergedValues),
  \\"condition\\": $condition
} )
#if( $context.args.condition )
  $util.qr($ctx.stash.conditions.add($context.args.condition))
#end
## Begin - KeyCondition **
#if( $ctx.stash.metadata.modelObjectKey )
  #set( $keyConditionExpr = {} )
  #foreach( $entry in $ctx.stash.metadata.modelObjectKey.entrySet() )
    $util.qr($keyConditionExpr.put(\\"$entry.key\\", {
  \\"attributeExists\\": false
}))
  #end
  $util.qr($ctx.stash.conditions.add($keyConditionExpr))
#else
  $util.qr($ctx.stash.conditions.add({
  \\"id\\": {
      \\"attributeExists\\": false
  }
}))
#end
## End - KeyCondition **
## Start condition block **
#if( $ctx.stash.conditions && $ctx.stash.conditions.size() != 0 )
  #set( $mergedConditions = {
  \\"and\\": $ctx.stash.conditions
} )
  #set( $Conditions = $util.parseJson($util.transform.toDynamoDBConditionExpression($mergedConditions)) )
  #if( $Conditions.expressionValues && $Conditions.expressionValues.size() == 0 )
    #set( $Conditions = {
  \\"expression\\": $Conditions.expression,
  \\"expressionNames\\": $Conditions.expressionNames
} )
  #end
  ## End condition block **
#end
#if( $Conditions )
  $util.qr($PutObject.put(\\"condition\\", $Conditions))
#end
#if( $ctx.stash.metadata.modelObject )
  $PutObject.put(\\"id\\", $ctx.stash.metadata.modelObject)
#else
  #set( $Key = {
  \\"id\\":   $util.dynamodb.toDynamoDB($mergedValues.id)
} )
  $util.qr($PutObject.put(\\"key\\", $Key))
#end
$util.toJson($PutObject)
## [End] Create Request template. **",
  "Mutation.testCreate.res.vtl": "## [Start] Get ResponseTemplate. **
#if( $ctx.error )
  $util.error($ctx.error.message, $ctx.error.type)
#else
  $util.toJson($ctx.result)
#end
## [End] Get ResponseTemplate. **",
  "Mutation.testDelete.req.vtl": "## [Start] Set the primary key. **
#set( $modelObjectKey = {
  \\"id\\": $util.dynamodb.toDynamoDB($ctx.args.input.id),
  \\"email\\": $util.dynamodb.toDynamoDB($ctx.args.input.email)
} )
## [End] Set the primary key. **
## [Start] Delete Request template. **
#set( $DeleteRequest = {
  \\"version\\": \\"2018-05-29\\",
  \\"operation\\": \\"DeleteItem\\"
} )
#if( $ctx.stash.metadata.modelObjectKey )
  #set( $Key = $ctx.stash.metadata.modelObjectKey )
#else
  #set( $Key = {
  \\"id\\":   $util.dynamodb.toDynamoDB($ctx.args.input.id)
} )
#end
$util.qr($DeleteRequest.put(\\"key\\", $Key))
## Begin - key condition **
#if( $ctx.stash.metadata.modelObjectKey )
  #set( $keyConditionExpr = {} )
  #foreach( $entry in $ctx.stash.metadata.modelObjectKey.entrySet() )
    $util.qr($keyConditionExpr.put(\\"$entry.key\\", {
  \\"attributeExists\\": true
}))
  #end
  $util.qr($ctx.stash.conditions.add($keyConditionExpr))
#else
  $util.qr($ctx.stash.conditions.add({
  \\"id\\": {
      \\"attributeExists\\": true
  }
}))
#end
## End - key condition **
#if( $context.args.condition )
  $util.qr($ctx.stash.conditions.add($context.args.condition))
#end
## Start condition block **
#if( $ctx.stash.conditions && $ctx.stash.conditions.size() != 0 )
  #set( $mergedConditions = {
  \\"and\\": $ctx.stash.conditions
} )
  #set( $Conditions = $util.parseJson($util.transform.toDynamoDBConditionExpression($mergedConditions)) )
  #if( $Conditions.expressionValues && $Conditions.expressionValues.size() == 0 )
    #set( $Conditions = {
  \\"expression\\": $Conditions.expression,
  \\"expressionNames\\": $Conditions.expressionNames
} )
  #end
  ## End condition block **
#end
#if( $Conditions )
  $util.qr($DeleteRequest.put(\\"condition\\", $Conditions))
#end
$util.toJson($DeleteRequest)
## [End] Delete Request template. **",
  "Mutation.testDelete.res.vtl": "## [Start] Get ResponseTemplate. **
#if( $ctx.error )
  $util.error($ctx.error.message, $ctx.error.type)
#else
  $util.toJson($ctx.result)
#end
## [End] Get ResponseTemplate. **",
  "Mutation.testUpdate.init.1.req.vtl": "## [Start] Initialization default values. **
$util.qr($ctx.stash.put(\\"defaultValues\\", $util.defaultIfNull($ctx.stash.defaultValues, {})))
#set( $updatedAt = $util.time.nowISO8601() )
$util.qr($ctx.stash.defaultValues.put(\\"updatedAt\\", $updatedAt))
$util.toJson({
  \\"version\\": \\"2018-05-29\\",
  \\"payload\\": {}
})
## [End] Initialization default values. **",
  "Mutation.testUpdate.req.vtl": "## [Start] Set the primary key. **
#set( $modelObjectKey = {
  \\"id\\": $util.dynamodb.toDynamoDB($ctx.args.input.id),
  \\"email\\": $util.dynamodb.toDynamoDB($ctx.args.input.email)
} )
## [End] Set the primary key. **

## [Start] Mutation Update resolver. **
## Set the default values to put request **
#set( $mergedValues = $util.defaultIfNull($ctx.stash.defaultValues, {}) )
## copy the values from input **
$util.qr($mergedValues.putAll($util.defaultIfNull($ctx.args.input, {})))
## set the typename **
## Initialize the vars for creating ddb expression **
#set( $expNames = {} )
#set( $expValues = {} )
#set( $expSet = {} )
#set( $expAdd = {} )
#set( $expRemove = [] )
#if( $ctx.stash.metadata.modelObjetKey )
  #set( $Key = $util.dynamodb.toDynamoDB($ctx.stash.metadata.modelObjetKey) )
#else
  #set( $Key = {
  \\"id\\":   $util.dynamodb.toDynamoDB($ctx.args.input.id)
} )
#end
## Model key **
#if( $ctx.stash.metadata.modelObjetKey )
  #foreach( $entry in $ctx.stash.metadata.modelObjetKey.entrySet() )
    $util.qr($keyFields.add(\\"$entry.key\\"))
  #end
#else
  #set( $keyFields = [\\"id\\"] )
#end
#foreach( $entry in $util.map.copyAndRemoveAllKeys($mergedValues, $keyFields).entrySet() )
  #if( $util.isNull($entry.value) )
    #set( $discard = $expRemove.add(\\"#$entry.key\\") )
    $util.qr($expNames.put(\\"#$entry.key\\", \\"$entry.key\\"))
  #else
    $util.qr($expSet.put(\\"#$entry.key\\", \\":$entry.key\\"))
    $util.qr($expNames.put(\\"#$entry.key\\", \\"$entry.key\\"))
    $util.qr($expValues.put(\\":$entry.key\\", $util.dynamodb.toDynamoDB($entry.value)))
  #end
#end
#set( $expression = \\"\\" )
#if( !$expSet.isEmpty() )
  #set( $expression = \\"SET\\" )
  #foreach( $entry in $expSet.entrySet() )
    #set( $expression = \\"$expression $entry.key = $entry.value\\" )
    #if( $foreach.hasNext() )
      #set( $expression = \\"$expression,\\" )
    #end
  #end
#end
#if( !$expAdd.isEmpty() )
  #set( $expression = \\"$expression ADD\\" )
  #foreach( $entry in $expAdd.entrySet() )
    #set( $expression = \\"$expression $entry.key $entry.value\\" )
    #if( $foreach.hasNext() )
      #set( $expression = \\"$expression,\\" )
    #end
  #end
#end
#if( !$expRemove.isEmpty() )
  #set( $expression = \\"$expression REMOVE\\" )
  #foreach( $entry in $expRemove )
    #set( $expression = \\"$expression $entry\\" )
    #if( $foreach.hasNext() )
      #set( $expression = \\"$expression,\\" )
    #end
  #end
#end
#set( $update = {} )
$util.qr($update.put(\\"expression\\", \\"$expression\\"))
#if( !$expNames.isEmpty() )
  $util.qr($update.put(\\"expressionNames\\", $expNames))
#end
#if( !$expValues.isEmpty() )
  $util.qr($update.put(\\"expressionValues\\", $expValues))
#end
## Begin - key condition **
#if( $ctx.stash.metadata.modelObjectKey )
  #set( $keyConditionExpr = {} )
  #foreach( $entry in $ctx.stash.metadata.modelObjectKey.entrySet() )
    $util.qr($keyConditionExpr.put(\\"$entry.key\\", {
  \\"attributeExists\\": true
}))
  #end
  $util.qr($ctx.stash.conditions.add($keyConditionExpr))
#else
  $util.qr($ctx.stash.conditions.add({
  \\"id\\": {
      \\"attributeExists\\": true
  }
}))
#end
## End - key condition **
#if( $context.args.condition )
  $util.qr($ctx.stash.conditions.add($context.args.condition))
#end
## Start condition block **
#if( $ctx.stash.conditions && $ctx.stash.conditions.size() != 0 )
  #set( $mergedConditions = {
  \\"and\\": $ctx.stash.conditions
} )
  #set( $Conditions = $util.parseJson($util.transform.toDynamoDBConditionExpression($mergedConditions)) )
  #if( $Conditions.expressionValues && $Conditions.expressionValues.size() == 0 )
    #set( $Conditions = {
  \\"expression\\": $Conditions.expression,
  \\"expressionNames\\": $Conditions.expressionNames
} )
  #end
  ## End condition block **
#end
#set( $UpdateItem = {
  \\"version\\": \\"2018-05-29\\",
  \\"operation\\": \\"UpdateItem\\",
  \\"key\\": $Key,
  \\"update\\": $update
} )
#if( $Conditions )
  $util.qr($UpdateItem.put(\\"condition\\", $Conditions))
#end
$util.toJson($UpdateItem)
## [End] Mutation Update resolver. **",
  "Mutation.testUpdate.res.vtl": "## [Start] Get ResponseTemplate. **
#if( $ctx.error )
  $util.error($ctx.error.message, $ctx.error.type)
#else
  $util.toJson($ctx.result)
#end
## [End] Get ResponseTemplate. **",
  "Mutation.updateTest.init.1.req.vtl": "## [Start] Initialization default values. **
$util.qr($ctx.stash.put(\\"defaultValues\\", $util.defaultIfNull($ctx.stash.defaultValues, {})))
#set( $updatedAt = $util.time.nowISO8601() )
$util.qr($ctx.stash.defaultValues.put(\\"updatedAt\\", $updatedAt))
$util.toJson({
  \\"version\\": \\"2018-05-29\\",
  \\"payload\\": {}
})
## [End] Initialization default values. **",
  "Mutation.updateTest.req.vtl": "## [Start] Set the primary key. **
#set( $modelObjectKey = {
  \\"email\\": $util.dynamodb.toDynamoDB($ctx.args.input.email)
} )
## [End] Set the primary key. **

## [Start] Mutation Update resolver. **
## Set the default values to put request **
#set( $mergedValues = $util.defaultIfNull($ctx.stash.defaultValues, {}) )
## copy the values from input **
$util.qr($mergedValues.putAll($util.defaultIfNull($ctx.args.input, {})))
## set the typename **
## Initialize the vars for creating ddb expression **
#set( $expNames = {} )
#set( $expValues = {} )
#set( $expSet = {} )
#set( $expAdd = {} )
#set( $expRemove = [] )
#if( $ctx.stash.metadata.modelObjetKey )
  #set( $Key = $util.dynamodb.toDynamoDB($ctx.stash.metadata.modelObjetKey) )
#else
  #set( $Key = {
  \\"id\\":   $util.dynamodb.toDynamoDB($ctx.args.input.id)
} )
#end
## Model key **
#if( $ctx.stash.metadata.modelObjetKey )
  #foreach( $entry in $ctx.stash.metadata.modelObjetKey.entrySet() )
    $util.qr($keyFields.add(\\"$entry.key\\"))
  #end
#else
  #set( $keyFields = [\\"id\\"] )
#end
#foreach( $entry in $util.map.copyAndRemoveAllKeys($mergedValues, $keyFields).entrySet() )
  #if( $util.isNull($entry.value) )
    #set( $discard = $expRemove.add(\\"#$entry.key\\") )
    $util.qr($expNames.put(\\"#$entry.key\\", \\"$entry.key\\"))
  #else
    $util.qr($expSet.put(\\"#$entry.key\\", \\":$entry.key\\"))
    $util.qr($expNames.put(\\"#$entry.key\\", \\"$entry.key\\"))
    $util.qr($expValues.put(\\":$entry.key\\", $util.dynamodb.toDynamoDB($entry.value)))
  #end
#end
#set( $expression = \\"\\" )
#if( !$expSet.isEmpty() )
  #set( $expression = \\"SET\\" )
  #foreach( $entry in $expSet.entrySet() )
    #set( $expression = \\"$expression $entry.key = $entry.value\\" )
    #if( $foreach.hasNext() )
      #set( $expression = \\"$expression,\\" )
    #end
  #end
#end
#if( !$expAdd.isEmpty() )
  #set( $expression = \\"$expression ADD\\" )
  #foreach( $entry in $expAdd.entrySet() )
    #set( $expression = \\"$expression $entry.key $entry.value\\" )
    #if( $foreach.hasNext() )
      #set( $expression = \\"$expression,\\" )
    #end
  #end
#end
#if( !$expRemove.isEmpty() )
  #set( $expression = \\"$expression REMOVE\\" )
  #foreach( $entry in $expRemove )
    #set( $expression = \\"$expression $entry\\" )
    #if( $foreach.hasNext() )
      #set( $expression = \\"$expression,\\" )
    #end
  #end
#end
#set( $update = {} )
$util.qr($update.put(\\"expression\\", \\"$expression\\"))
#if( !$expNames.isEmpty() )
  $util.qr($update.put(\\"expressionNames\\", $expNames))
#end
#if( !$expValues.isEmpty() )
  $util.qr($update.put(\\"expressionValues\\", $expValues))
#end
## Begin - key condition **
#if( $ctx.stash.metadata.modelObjectKey )
  #set( $keyConditionExpr = {} )
  #foreach( $entry in $ctx.stash.metadata.modelObjectKey.entrySet() )
    $util.qr($keyConditionExpr.put(\\"$entry.key\\", {
  \\"attributeExists\\": true
}))
  #end
  $util.qr($ctx.stash.conditions.add($keyConditionExpr))
#else
  $util.qr($ctx.stash.conditions.add({
  \\"id\\": {
      \\"attributeExists\\": true
  }
}))
#end
## End - key condition **
#if( $context.args.condition )
  $util.qr($ctx.stash.conditions.add($context.args.condition))
#end
## Start condition block **
#if( $ctx.stash.conditions && $ctx.stash.conditions.size() != 0 )
  #set( $mergedConditions = {
  \\"and\\": $ctx.stash.conditions
} )
  #set( $Conditions = $util.parseJson($util.transform.toDynamoDBConditionExpression($mergedConditions)) )
  #if( $Conditions.expressionValues && $Conditions.expressionValues.size() == 0 )
    #set( $Conditions = {
  \\"expression\\": $Conditions.expression,
  \\"expressionNames\\": $Conditions.expressionNames
} )
  #end
  ## End condition block **
#end
#set( $UpdateItem = {
  \\"version\\": \\"2018-05-29\\",
  \\"operation\\": \\"UpdateItem\\",
  \\"key\\": $Key,
  \\"update\\": $update
} )
#if( $Conditions )
  $util.qr($UpdateItem.put(\\"condition\\", $Conditions))
#end
$util.toJson($UpdateItem)
## [End] Mutation Update resolver. **",
  "Mutation.updateTest.res.vtl": "## [Start] Get ResponseTemplate. **
#if( $ctx.error )
  $util.error($ctx.error.message, $ctx.error.type)
#else
  $util.toJson($ctx.result)
#end
## [End] Get ResponseTemplate. **",
  "Query.getTest.req.vtl": "## [Start] Set the primary key. **
#set( $modelObjectKey = {
  \\"email\\": $util.dynamodb.toDynamoDB($ctx.args.email)
} )
## [End] Set the primary key. **
## [Start] Get Request template. **
#set( $GetRequest = {
  \\"version\\": \\"2018-05-29\\",
  \\"operation\\": \\"GetItem\\"
} )
#if( $ctx.stash.metadata.modelKeyObject )
  #set( $Key = $ctx.stash.metadata.modelKeyObject )
#else
  #set( $key = {
  \\"id\\":   $util.dynamodb.toDynamoDB($ctx.args.id)
} )
#end
$util.qr($GetRequest.put(\\"key\\", $key))
$util.toJson($GetRequest)
## [End] Get Request template. **",
  "Query.getTest.res.vtl": "## [Start] Get ResponseTemplate. **
#if( $ctx.error )
  $util.error($ctx.error.message, $ctx.error.type)
#else
  $util.toJson($ctx.result)
#end
## [End] Get ResponseTemplate. **",
  "Query.listTests.req.vtl": "## [Start] Set query expression for key **
#if( !$util.isNull($ctx.args.sortDirection) )
  $util.error(\\"sortDirection is not supported for List operations without a Sort key defined.\\", \\"InvalidArgumentsError\\")
#end
#set( $modelQueryExpression = {} )
#if( !$util.isNull($ctx.args.email) )
  #set( $modelQueryExpression.expression = \\"#email = :email\\" )
  #set( $modelQueryExpression.expressionNames = {
  \\"#email\\": \\"email\\"
} )
  #set( $modelQueryExpression.expressionValues = {
  \\":email\\": {
      \\"S\\": \\"$ctx.args.email\\"
  }
} )
#end
## [End] Set query expression for key **
## [Start] List Request. **
#set( $limit = $util.defaultIfNull($context.args.limit, 100) )
#set( $ListRequest = {
  \\"version\\": \\"2018-05-29\\",
  \\"limit\\": $limit
} )
#if( $context.args.nextToken )
  #set( $ListRequest.nextToken = $context.args.nextToken )
#end
#if( $context.args.filter )
  #set( $filterExpression = $util.parseJson($util.transform.toDynamoDBFilterExpression($ctx.args.filter)) )
  #if( !$util.isNullOrBlank($filterExpression.expression) )
    #if( $filterEpression.expressionValues.size() == 0 )
      $util.qr($filterEpression.remove(\\"expressionValues\\"))
    #end
    #set( $ListRequest.filter = $filterExpression )
  #end
#end
#if( !$util.isNull($ctx.stash.modelQuery) )
  #set( $Query = $util.parseJson($util.transform.toDynamoDBFilterExpression($ctx.stash.modelQuery)) )
  $util.qr($ListRequest.put(\\"operation\\", \\"Query\\"))
  $util.qr($ListRequest.put(\\"query\\", $Query))
  #if( !$util.isNull($ctx.args.sortDirection) && $ctx.args.sortDirection == \\"DESC\\" )
    #set( $ListRequest.scanIndexForward = false )
  #else
    #set( $ListRequest.scanIndexForward = true )
  #end
#else
  $util.qr($ListRequest.put(\\"operation\\", \\"Scan\\"))
#end
#if( !$util.isNull($ctx.stash.metadata.index) )
  #set( $ListRequest.IndexName = $ctx.stash.metadata.index )
#end
$util.toJson($ListRequest)
## [End] List Request. **",
  "Query.listTests.res.vtl": "## [Start] Get ResponseTemplate. **
#if( $ctx.error )
  $util.error($ctx.error.message, $ctx.error.type)
#else
  $util.toJson($ctx.result)
#end
## [End] Get ResponseTemplate. **",
  "Query.testGet.req.vtl": "## [Start] Set the primary key. **
#set( $modelObjectKey = {
  \\"id\\": $util.dynamodb.toDynamoDB($ctx.args.id),
  \\"email\\": $util.dynamodb.toDynamoDB($ctx.args.email)
} )
## [End] Set the primary key. **
## [Start] Get Request template. **
#set( $GetRequest = {
  \\"version\\": \\"2018-05-29\\",
  \\"operation\\": \\"GetItem\\"
} )
#if( $ctx.stash.metadata.modelKeyObject )
  #set( $Key = $ctx.stash.metadata.modelKeyObject )
#else
  #set( $key = {
  \\"id\\":   $util.dynamodb.toDynamoDB($ctx.args.id)
} )
#end
$util.qr($GetRequest.put(\\"key\\", $key))
$util.toJson($GetRequest)
## [End] Get Request template. **",
  "Query.testGet.res.vtl": "## [Start] Get ResponseTemplate. **
#if( $ctx.error )
  $util.error($ctx.error.message, $ctx.error.type)
#else
  $util.toJson($ctx.result)
#end
## [End] Get ResponseTemplate. **",
  "Query.testList.req.vtl": "## [Start] Set query expression for key **
#if( $util.isNull($ctx.args.id) && !$util.isNull($ctx.args.sortDirection) )
  $util.error(\\"When providing argument 'sortDirection' you must also provide argument 'id'.\\", \\"InvalidArgumentsError\\")
#end
#set( $modelQueryExpression = {} )
## [Start] Validate key arguments. **
#if( !$util.isNull($ctx.args.email) && $util.isNull($ctx.args.id) )
  $util.error(\\"When providing argument 'email' you must also provide arguments id\\", \\"InvalidArgumentsError\\")
#end
## [End] Validate key arguments. **
#if( !$util.isNull($ctx.args.id) )
  #set( $modelQueryExpression.expression = \\"#id = :id\\" )
  #set( $modelQueryExpression.expressionNames = {
  \\"#id\\": \\"id\\"
} )
  #set( $modelQueryExpression.expressionValues = {
  \\":id\\": {
      \\"S\\": \\"$ctx.args.id\\"
  }
} )
#end
## [Start] Applying Key Condition **
#if( !$util.isNull($ctx.args.email) && !$util.isNull($ctx.args.email.beginsWith) )
  #set( $modelQueryExpression.expression = \\"$modelQueryExpression.expression AND begins_with(#sortKey, :sortKey)\\" )
  $util.qr($modelQueryExpression.expressionNames.put(\\"#sortKey\\", \\"email\\"))
  $util.qr($modelQueryExpression.expressionValues.put(\\":sortKey\\", { \\"S\\": \\"$ctx.args.email.beginsWith\\" }))
#end
#if( !$util.isNull($ctx.args.email) && !$util.isNull($ctx.args.email.between) )
  #set( $modelQueryExpression.expression = \\"$modelQueryExpression.expression AND #sortKey BETWEEN :sortKey0 AND :sortKey1\\" )
  $util.qr($modelQueryExpression.expressionNames.put(\\"#sortKey\\", \\"email\\"))
  $util.qr($modelQueryExpression.expressionValues.put(\\":sortKey0\\", { \\"S\\": \\"$ctx.args.email.between[0]\\" }))
  $util.qr($modelQueryExpression.expressionValues.put(\\":sortKey1\\", { \\"S\\": \\"$ctx.args.email.between[1]\\" }))
#end
#if( !$util.isNull($ctx.args.email) && !$util.isNull($ctx.args.email.eq) )
  #set( $modelQueryExpression.expression = \\"$modelQueryExpression.expression AND #sortKey = :sortKey\\" )
  $util.qr($modelQueryExpression.expressionNames.put(\\"#sortKey\\", \\"email\\"))
  $util.qr($modelQueryExpression.expressionValues.put(\\":sortKey\\", { \\"S\\": \\"$ctx.args.email.eq\\" }))
#end
#if( !$util.isNull($ctx.args.email) && !$util.isNull($ctx.args.email.lt) )
  #set( $modelQueryExpression.expression = \\"$modelQueryExpression.expression AND #sortKey < :sortKey\\" )
  $util.qr($modelQueryExpression.expressionNames.put(\\"#sortKey\\", \\"email\\"))
  $util.qr($modelQueryExpression.expressionValues.put(\\":sortKey\\", { \\"S\\": \\"$ctx.args.email.lt\\" }))
#end
#if( !$util.isNull($ctx.args.email) && !$util.isNull($ctx.args.email.le) )
  #set( $modelQueryExpression.expression = \\"$modelQueryExpression.expression AND #sortKey <= :sortKey\\" )
  $util.qr($modelQueryExpression.expressionNames.put(\\"#sortKey\\", \\"email\\"))
  $util.qr($modelQueryExpression.expressionValues.put(\\":sortKey\\", { \\"S\\": \\"$ctx.args.email.le\\" }))
#end
#if( !$util.isNull($ctx.args.email) && !$util.isNull($ctx.args.email.gt) )
  #set( $modelQueryExpression.expression = \\"$modelQueryExpression.expression AND #sortKey > :sortKey\\" )
  $util.qr($modelQueryExpression.expressionNames.put(\\"#sortKey\\", \\"email\\"))
  $util.qr($modelQueryExpression.expressionValues.put(\\":sortKey\\", { \\"S\\": \\"$ctx.args.email.gt\\" }))
#end
#if( !$util.isNull($ctx.args.email) && !$util.isNull($ctx.args.email.ge) )
  #set( $modelQueryExpression.expression = \\"$modelQueryExpression.expression AND #sortKey >= :sortKey\\" )
  $util.qr($modelQueryExpression.expressionNames.put(\\"#sortKey\\", \\"email\\"))
  $util.qr($modelQueryExpression.expressionValues.put(\\":sortKey\\", { \\"S\\": \\"$ctx.args.email.ge\\" }))
#end
## [End] Applying Key Condition **
## [End] Set query expression for key **
## [Start] List Request. **
#set( $limit = $util.defaultIfNull($context.args.limit, 100) )
#set( $ListRequest = {
  \\"version\\": \\"2018-05-29\\",
  \\"limit\\": $limit
} )
#if( $context.args.nextToken )
  #set( $ListRequest.nextToken = $context.args.nextToken )
#end
#if( $context.args.filter )
  #set( $filterExpression = $util.parseJson($util.transform.toDynamoDBFilterExpression($ctx.args.filter)) )
  #if( !$util.isNullOrBlank($filterExpression.expression) )
    #if( $filterEpression.expressionValues.size() == 0 )
      $util.qr($filterEpression.remove(\\"expressionValues\\"))
    #end
    #set( $ListRequest.filter = $filterExpression )
  #end
#end
#if( !$util.isNull($ctx.stash.modelQuery) )
  #set( $Query = $util.parseJson($util.transform.toDynamoDBFilterExpression($ctx.stash.modelQuery)) )
  $util.qr($ListRequest.put(\\"operation\\", \\"Query\\"))
  $util.qr($ListRequest.put(\\"query\\", $Query))
  #if( !$util.isNull($ctx.args.sortDirection) && $ctx.args.sortDirection == \\"DESC\\" )
    #set( $ListRequest.scanIndexForward = false )
  #else
    #set( $ListRequest.scanIndexForward = true )
  #end
#else
  $util.qr($ListRequest.put(\\"operation\\", \\"Scan\\"))
#end
#if( !$util.isNull($ctx.stash.metadata.index) )
  #set( $ListRequest.IndexName = $ctx.stash.metadata.index )
#end
$util.toJson($ListRequest)
## [End] List Request. **",
  "Query.testList.res.vtl": "## [Start] Get ResponseTemplate. **
#if( $ctx.error )
  $util.error($ctx.error.message, $ctx.error.type)
#else
  $util.toJson($ctx.result)
#end
## [End] Get ResponseTemplate. **",
  "Subscription.onCreateTest.req.vtl": "## [Start] Subscription Request template. **
$util.toJson({
  \\"version\\": \\"2018-05-29\\",
  \\"payload\\": {}
})
## [End] Subscription Request template. **",
  "Subscription.onCreateTest.res.vtl": "## [Start] Subscription Resonse template. **
$util.toJson(null)
## [End] Subscription Resonse template. **",
  "Subscription.onDeleteTest.req.vtl": "## [Start] Subscription Request template. **
$util.toJson({
  \\"version\\": \\"2018-05-29\\",
  \\"payload\\": {}
})
## [End] Subscription Request template. **",
  "Subscription.onDeleteTest.res.vtl": "## [Start] Subscription Resonse template. **
$util.toJson(null)
## [End] Subscription Resonse template. **",
  "Subscription.onUpdateTest.req.vtl": "## [Start] Subscription Request template. **
$util.toJson({
  \\"version\\": \\"2018-05-29\\",
  \\"payload\\": {}
})
## [End] Subscription Request template. **",
  "Subscription.onUpdateTest.res.vtl": "## [Start] Subscription Resonse template. **
$util.toJson(null)
## [End] Subscription Resonse template. **",
}
`;
