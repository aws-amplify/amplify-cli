// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`Test SearchableModelTransformer enum type generates StringFilterInput 1`] = `
"
type Employee {
  id: ID!
  firstName: String!
  lastName: String!
  type: EmploymentType!
  createdAt: AWSDateTime!
  updatedAt: AWSDateTime!
}

enum EmploymentType {
  FULLTIME
  HOURLY
}

type SearchableEmployeeConnection {
  items: [Employee]!
  nextToken: String
  total: Int
  aggregateItems: [SearchableAggregateResult]!
}

type SearchableAggregateResult {
  name: String!
  result: SearchableAggregateGenericResult
}

type SearchableAggregateScalarResult {
  value: Float!
}

type SearchableAggregateBucketResult {
  buckets: [SearchableAggregateBucketResultItem]
}

type SearchableAggregateBucketResultItem {
  key: String!
  doc_count: Int!
}

union SearchableAggregateGenericResult = SearchableAggregateScalarResult | SearchableAggregateBucketResult

type Query {
  searchEmployees(filter: SearchableEmployeeFilterInput, sort: [SearchableEmployeeSortInput], limit: Int, nextToken: String, from: Int, aggregates: [SearchableEmployeeAggregationInput]): SearchableEmployeeConnection
  getEmployee(id: ID!): Employee
  listEmployees(filter: ModelEmployeeFilterInput, limit: Int, nextToken: String): ModelEmployeeConnection
}

input ModelStringInput {
  ne: String
  eq: String
  le: String
  lt: String
  ge: String
  gt: String
  contains: String
  notContains: String
  between: [String]
  beginsWith: String
  attributeExists: Boolean
  attributeType: ModelAttributeTypes
  size: ModelSizeInput
}

input ModelIntInput {
  ne: Int
  eq: Int
  le: Int
  lt: Int
  ge: Int
  gt: Int
  between: [Int]
  attributeExists: Boolean
  attributeType: ModelAttributeTypes
}

input ModelFloatInput {
  ne: Float
  eq: Float
  le: Float
  lt: Float
  ge: Float
  gt: Float
  between: [Float]
  attributeExists: Boolean
  attributeType: ModelAttributeTypes
}

input ModelBooleanInput {
  ne: Boolean
  eq: Boolean
  attributeExists: Boolean
  attributeType: ModelAttributeTypes
}

input ModelIDInput {
  ne: ID
  eq: ID
  le: ID
  lt: ID
  ge: ID
  gt: ID
  contains: ID
  notContains: ID
  between: [ID]
  beginsWith: ID
  attributeExists: Boolean
  attributeType: ModelAttributeTypes
  size: ModelSizeInput
}

enum ModelAttributeTypes {
  binary
  binarySet
  bool
  list
  map
  number
  numberSet
  string
  stringSet
  _null
}

input ModelSizeInput {
  ne: Int
  eq: Int
  le: Int
  lt: Int
  ge: Int
  gt: Int
  between: [Int]
}

enum ModelSortDirection {
  ASC
  DESC
}

type ModelEmployeeConnection {
  items: [Employee]!
  nextToken: String
}

input ModelEmploymentTypeInput {
  eq: EmploymentType
  ne: EmploymentType
}

input ModelEmployeeFilterInput {
  id: ModelIDInput
  firstName: ModelStringInput
  lastName: ModelStringInput
  type: ModelEmploymentTypeInput
  and: [ModelEmployeeFilterInput]
  or: [ModelEmployeeFilterInput]
  not: ModelEmployeeFilterInput
}

input ModelEmployeeConditionInput {
  firstName: ModelStringInput
  lastName: ModelStringInput
  type: ModelEmploymentTypeInput
  and: [ModelEmployeeConditionInput]
  or: [ModelEmployeeConditionInput]
  not: ModelEmployeeConditionInput
}

input CreateEmployeeInput {
  id: ID
  firstName: String!
  lastName: String!
  type: EmploymentType!
}

input UpdateEmployeeInput {
  id: ID!
  firstName: String
  lastName: String
  type: EmploymentType
}

input DeleteEmployeeInput {
  id: ID!
}

type Mutation {
  createEmployee(input: CreateEmployeeInput!, condition: ModelEmployeeConditionInput): Employee
  updateEmployee(input: UpdateEmployeeInput!, condition: ModelEmployeeConditionInput): Employee
  deleteEmployee(input: DeleteEmployeeInput!, condition: ModelEmployeeConditionInput): Employee
}

type Subscription {
  onCreateEmployee: Employee @aws_subscribe(mutations: [\\"createEmployee\\"])
  onUpdateEmployee: Employee @aws_subscribe(mutations: [\\"updateEmployee\\"])
  onDeleteEmployee: Employee @aws_subscribe(mutations: [\\"deleteEmployee\\"])
}

input SearchableStringFilterInput {
  ne: String
  gt: String
  lt: String
  gte: String
  lte: String
  eq: String
  match: String
  matchPhrase: String
  matchPhrasePrefix: String
  multiMatch: String
  exists: Boolean
  wildcard: String
  regexp: String
  range: [String]
}

input SearchableIntFilterInput {
  ne: Int
  gt: Int
  lt: Int
  gte: Int
  lte: Int
  eq: Int
  range: [Int]
}

input SearchableFloatFilterInput {
  ne: Float
  gt: Float
  lt: Float
  gte: Float
  lte: Float
  eq: Float
  range: [Float]
}

input SearchableBooleanFilterInput {
  eq: Boolean
  ne: Boolean
}

input SearchableIDFilterInput {
  ne: ID
  gt: ID
  lt: ID
  gte: ID
  lte: ID
  eq: ID
  match: ID
  matchPhrase: ID
  matchPhrasePrefix: ID
  multiMatch: ID
  exists: Boolean
  wildcard: ID
  regexp: ID
  range: [ID]
}

input SearchableEmployeeFilterInput {
  id: SearchableIDFilterInput
  firstName: SearchableStringFilterInput
  lastName: SearchableStringFilterInput
  createdAt: SearchableStringFilterInput
  updatedAt: SearchableStringFilterInput
  type: SearchableStringFilterInput
  and: [SearchableEmployeeFilterInput]
  or: [SearchableEmployeeFilterInput]
  not: SearchableEmployeeFilterInput
}

enum SearchableSortDirection {
  asc
  desc
}

enum SearchableEmployeeSortableFields {
  id
  firstName
  lastName
  createdAt
  updatedAt
}

input SearchableEmployeeSortInput {
  field: SearchableEmployeeSortableFields
  direction: SearchableSortDirection
}

enum SearchableAggregateType {
  terms
  avg
  min
  max
  sum
}

enum SearchableEmployeeAggregateField {
  id
  firstName
  lastName
  type
  createdAt
  updatedAt
}

input SearchableEmployeeAggregationInput {
  name: String!
  type: SearchableAggregateType!
  field: SearchableEmployeeAggregateField!
}

"
`;

exports[`Test SearchableModelTransformer validation happy case 1`] = `
"
type Post {
  id: ID!
  title: String!
  createdAt: String
  updatedAt: String
}

type SearchablePostConnection {
  items: [Post]!
  nextToken: String
  total: Int
  aggregateItems: [SearchableAggregateResult]!
}

type SearchableAggregateResult {
  name: String!
  result: SearchableAggregateGenericResult
}

type SearchableAggregateScalarResult {
  value: Float!
}

type SearchableAggregateBucketResult {
  buckets: [SearchableAggregateBucketResultItem]
}

type SearchableAggregateBucketResultItem {
  key: String!
  doc_count: Int!
}

union SearchableAggregateGenericResult = SearchableAggregateScalarResult | SearchableAggregateBucketResult

type Query {
  searchPosts(filter: SearchablePostFilterInput, sort: [SearchablePostSortInput], limit: Int, nextToken: String, from: Int, aggregates: [SearchablePostAggregationInput]): SearchablePostConnection
  getPost(id: ID!): Post
  listPosts(filter: ModelPostFilterInput, limit: Int, nextToken: String): ModelPostConnection
}

input ModelStringInput {
  ne: String
  eq: String
  le: String
  lt: String
  ge: String
  gt: String
  contains: String
  notContains: String
  between: [String]
  beginsWith: String
  attributeExists: Boolean
  attributeType: ModelAttributeTypes
  size: ModelSizeInput
}

input ModelIntInput {
  ne: Int
  eq: Int
  le: Int
  lt: Int
  ge: Int
  gt: Int
  between: [Int]
  attributeExists: Boolean
  attributeType: ModelAttributeTypes
}

input ModelFloatInput {
  ne: Float
  eq: Float
  le: Float
  lt: Float
  ge: Float
  gt: Float
  between: [Float]
  attributeExists: Boolean
  attributeType: ModelAttributeTypes
}

input ModelBooleanInput {
  ne: Boolean
  eq: Boolean
  attributeExists: Boolean
  attributeType: ModelAttributeTypes
}

input ModelIDInput {
  ne: ID
  eq: ID
  le: ID
  lt: ID
  ge: ID
  gt: ID
  contains: ID
  notContains: ID
  between: [ID]
  beginsWith: ID
  attributeExists: Boolean
  attributeType: ModelAttributeTypes
  size: ModelSizeInput
}

enum ModelAttributeTypes {
  binary
  binarySet
  bool
  list
  map
  number
  numberSet
  string
  stringSet
  _null
}

input ModelSizeInput {
  ne: Int
  eq: Int
  le: Int
  lt: Int
  ge: Int
  gt: Int
  between: [Int]
}

enum ModelSortDirection {
  ASC
  DESC
}

type ModelPostConnection {
  items: [Post]!
  nextToken: String
}

input ModelPostFilterInput {
  id: ModelIDInput
  title: ModelStringInput
  createdAt: ModelStringInput
  updatedAt: ModelStringInput
  and: [ModelPostFilterInput]
  or: [ModelPostFilterInput]
  not: ModelPostFilterInput
}

input ModelPostConditionInput {
  title: ModelStringInput
  createdAt: ModelStringInput
  updatedAt: ModelStringInput
  and: [ModelPostConditionInput]
  or: [ModelPostConditionInput]
  not: ModelPostConditionInput
}

input CreatePostInput {
  id: ID
  title: String!
  createdAt: String
  updatedAt: String
}

input UpdatePostInput {
  id: ID!
  title: String
  createdAt: String
  updatedAt: String
}

input DeletePostInput {
  id: ID!
}

type Mutation {
  createPost(input: CreatePostInput!, condition: ModelPostConditionInput): Post
  updatePost(input: UpdatePostInput!, condition: ModelPostConditionInput): Post
  deletePost(input: DeletePostInput!, condition: ModelPostConditionInput): Post
}

type Subscription {
  onCreatePost: Post @aws_subscribe(mutations: [\\"createPost\\"])
  onUpdatePost: Post @aws_subscribe(mutations: [\\"updatePost\\"])
  onDeletePost: Post @aws_subscribe(mutations: [\\"deletePost\\"])
}

input SearchableStringFilterInput {
  ne: String
  gt: String
  lt: String
  gte: String
  lte: String
  eq: String
  match: String
  matchPhrase: String
  matchPhrasePrefix: String
  multiMatch: String
  exists: Boolean
  wildcard: String
  regexp: String
  range: [String]
}

input SearchableIntFilterInput {
  ne: Int
  gt: Int
  lt: Int
  gte: Int
  lte: Int
  eq: Int
  range: [Int]
}

input SearchableFloatFilterInput {
  ne: Float
  gt: Float
  lt: Float
  gte: Float
  lte: Float
  eq: Float
  range: [Float]
}

input SearchableBooleanFilterInput {
  eq: Boolean
  ne: Boolean
}

input SearchableIDFilterInput {
  ne: ID
  gt: ID
  lt: ID
  gte: ID
  lte: ID
  eq: ID
  match: ID
  matchPhrase: ID
  matchPhrasePrefix: ID
  multiMatch: ID
  exists: Boolean
  wildcard: ID
  regexp: ID
  range: [ID]
}

input SearchablePostFilterInput {
  id: SearchableIDFilterInput
  title: SearchableStringFilterInput
  createdAt: SearchableStringFilterInput
  updatedAt: SearchableStringFilterInput
  and: [SearchablePostFilterInput]
  or: [SearchablePostFilterInput]
  not: SearchablePostFilterInput
}

enum SearchableSortDirection {
  asc
  desc
}

enum SearchablePostSortableFields {
  id
  title
  createdAt
  updatedAt
}

input SearchablePostSortInput {
  field: SearchablePostSortableFields
  direction: SearchableSortDirection
}

enum SearchableAggregateType {
  terms
  avg
  min
  max
  sum
}

enum SearchablePostAggregateField {
  id
  title
  createdAt
  updatedAt
}

input SearchablePostAggregationInput {
  name: String!
  type: SearchableAggregateType!
  field: SearchablePostAggregateField!
}

"
`;

exports[`Test SearchableModelTransformer vtl 1`] = `
Object {
  "Mutation.createPost.init.1.req.vtl": "## [Start] Initialization default values. **
$util.qr($ctx.stash.put(\\"defaultValues\\", $util.defaultIfNull($ctx.stash.defaultValues, {})))
#set( $createdAt = $util.time.nowISO8601() )
$util.qr($ctx.stash.defaultValues.put(\\"id\\", $util.autoId()))
$util.qr($ctx.stash.defaultValues.put(\\"createdAt\\", $createdAt))
$util.qr($ctx.stash.defaultValues.put(\\"updatedAt\\", $createdAt))
$util.toJson({
  \\"version\\": \\"2018-05-29\\",
  \\"payload\\": {}
})
## [End] Initialization default values. **",
  "Mutation.createPost.postAuth.1.req.vtl": "## [Start] Sandbox Mode Disabled. **
#if( !$ctx.stash.get(\\"hasAuth\\") )
  $util.unauthorized()
#end
$util.toJson({})
## [End] Sandbox Mode Disabled. **",
  "Mutation.createPost.req.vtl": "## [Start] Create Request template. **
#set( $args = $util.defaultIfNull($ctx.stash.transformedArgs, $ctx.args) )
## Set the default values to put request **
#set( $mergedValues = $util.defaultIfNull($ctx.stash.defaultValues, {}) )
## copy the values from input **
$util.qr($mergedValues.putAll($util.defaultIfNull($args.input, {})))
## set the typename **
$util.qr($mergedValues.put(\\"__typename\\", \\"Post\\"))
#set( $PutObject = {
  \\"version\\": \\"2018-05-29\\",
  \\"operation\\": \\"PutItem\\",
  \\"attributeValues\\":   $util.dynamodb.toMapValues($mergedValues),
  \\"condition\\": $condition
} )
#if( $args.condition )
  $util.qr($ctx.stash.conditions.add($args.condition))
#end
## Begin - key condition **
#if( $ctx.stash.metadata.modelObjectKey )
  #set( $keyConditionExpr = {} )
  #set( $keyConditionExprNames = {} )
  #foreach( $entry in $ctx.stash.metadata.modelObjectKey.entrySet() )
    $util.qr($keyConditionExpr.put(\\"keyCondition$velocityCount\\", {
  \\"attributeExists\\": false
}))
    $util.qr($keyConditionExprNames.put(\\"#keyCondition$velocityCount\\", \\"$entry.key\\"))
  #end
  $util.qr($ctx.stash.conditions.add($keyConditionExpr))
#else
  $util.qr($ctx.stash.conditions.add({
  \\"id\\": {
      \\"attributeExists\\": false
  }
}))
#end
## End - key condition **
## Start condition block **
#if( $ctx.stash.conditions && $ctx.stash.conditions.size() != 0 )
  #set( $mergedConditions = {
  \\"and\\": $ctx.stash.conditions
} )
  #set( $Conditions = $util.parseJson($util.transform.toDynamoDBConditionExpression($mergedConditions)) )
  #if( $Conditions.expressionValues && $Conditions.expressionValues.size() == 0 )
    #set( $Conditions = {
  \\"expression\\": $Conditions.expression,
  \\"expressionNames\\": $Conditions.expressionNames
} )
  #end
  ## End condition block **
#end
#if( $Conditions )
  #if( $keyConditionExprNames )
    $util.qr($Conditions.expressionNames.putAll($keyConditionExprNames))
  #end
  $util.qr($PutObject.put(\\"condition\\", $Conditions))
#end
#if( $ctx.stash.metadata.modelObjectKey )
  $util.qr($PutObject.put(\\"key\\", $ctx.stash.metadata.modelObjectKey))
#else
  #set( $Key = {
  \\"id\\":   $util.dynamodb.toDynamoDB($mergedValues.id)
} )
  $util.qr($PutObject.put(\\"key\\", $Key))
#end
$util.toJson($PutObject)
## [End] Create Request template. **",
  "Mutation.createPost.res.vtl": "## [Start] ResponseTemplate. **
$util.qr($ctx.result.put(\\"__operation\\", \\"Mutation\\"))
#if( $ctx.error )
  $util.error($ctx.error.message, $ctx.error.type)
#else
  $util.toJson($ctx.result)
#end
## [End] ResponseTemplate. **",
  "Mutation.deletePost.postAuth.1.req.vtl": "## [Start] Sandbox Mode Disabled. **
#if( !$ctx.stash.get(\\"hasAuth\\") )
  $util.unauthorized()
#end
$util.toJson({})
## [End] Sandbox Mode Disabled. **",
  "Mutation.deletePost.req.vtl": "## [Start] Delete Request template. **
#set( $args = $util.defaultIfNull($ctx.stash.transformedArgs, $ctx.args) )
#set( $DeleteRequest = {
  \\"version\\": \\"2018-05-29\\",
  \\"operation\\": \\"DeleteItem\\"
} )
#if( $ctx.stash.metadata.modelObjectKey )
  #set( $Key = $ctx.stash.metadata.modelObjectKey )
#else
  #set( $Key = {
  \\"id\\":   $util.dynamodb.toDynamoDB($args.input.id)
} )
#end
$util.qr($DeleteRequest.put(\\"key\\", $Key))
## Begin - key condition **
#if( $ctx.stash.metadata.modelObjectKey )
  #set( $keyConditionExpr = {} )
  #set( $keyConditionExprNames = {} )
  #foreach( $entry in $ctx.stash.metadata.modelObjectKey.entrySet() )
    $util.qr($keyConditionExpr.put(\\"keyCondition$velocityCount\\", {
  \\"attributeExists\\": true
}))
    $util.qr($keyConditionExprNames.put(\\"#keyCondition$velocityCount\\", \\"$entry.key\\"))
  #end
  $util.qr($ctx.stash.conditions.add($keyConditionExpr))
#else
  $util.qr($ctx.stash.conditions.add({
  \\"id\\": {
      \\"attributeExists\\": true
  }
}))
#end
## End - key condition **
#if( $args.condition )
  $util.qr($ctx.stash.conditions.add($args.condition))
#end
## Start condition block **
#if( $ctx.stash.conditions && $ctx.stash.conditions.size() != 0 )
  #set( $mergedConditions = {
  \\"and\\": $ctx.stash.conditions
} )
  #set( $Conditions = $util.parseJson($util.transform.toDynamoDBConditionExpression($mergedConditions)) )
  #if( $Conditions.expressionValues && $Conditions.expressionValues.size() == 0 )
    #set( $Conditions = {
  \\"expression\\": $Conditions.expression,
  \\"expressionNames\\": $Conditions.expressionNames
} )
  #end
  ## End condition block **
#end
#if( $Conditions )
  #if( $keyConditionExprNames )
    $util.qr($Conditions.expressionNames.putAll($keyConditionExprNames))
  #end
  $util.qr($DeleteRequest.put(\\"condition\\", $Conditions))
#end
$util.toJson($DeleteRequest)
## [End] Delete Request template. **",
  "Mutation.deletePost.res.vtl": "## [Start] ResponseTemplate. **
$util.qr($ctx.result.put(\\"__operation\\", \\"Mutation\\"))
#if( $ctx.error )
  $util.error($ctx.error.message, $ctx.error.type)
#else
  $util.toJson($ctx.result)
#end
## [End] ResponseTemplate. **",
  "Mutation.updatePost.init.1.req.vtl": "## [Start] Initialization default values. **
$util.qr($ctx.stash.put(\\"defaultValues\\", $util.defaultIfNull($ctx.stash.defaultValues, {})))
#set( $updatedAt = $util.time.nowISO8601() )
$util.qr($ctx.stash.defaultValues.put(\\"updatedAt\\", $updatedAt))
$util.toJson({
  \\"version\\": \\"2018-05-29\\",
  \\"payload\\": {}
})
## [End] Initialization default values. **",
  "Mutation.updatePost.postAuth.1.req.vtl": "## [Start] Sandbox Mode Disabled. **
#if( !$ctx.stash.get(\\"hasAuth\\") )
  $util.unauthorized()
#end
$util.toJson({})
## [End] Sandbox Mode Disabled. **",
  "Mutation.updatePost.req.vtl": "## [Start] Mutation Update resolver. **
#set( $args = $util.defaultIfNull($ctx.stash.transformedArgs, $ctx.args) )
## Set the default values to put request **
#set( $mergedValues = $util.defaultIfNull($ctx.stash.defaultValues, {}) )
## copy the values from input **
$util.qr($mergedValues.putAll($util.defaultIfNull($args.input, {})))
## set the typename **
## Initialize the vars for creating ddb expression **
#set( $expNames = {} )
#set( $expValues = {} )
#set( $expSet = {} )
#set( $expAdd = {} )
#set( $expRemove = [] )
#if( $ctx.stash.metadata.modelObjectKey )
  #set( $Key = $ctx.stash.metadata.modelObjectKey )
#else
  #set( $Key = {
  \\"id\\":   $util.dynamodb.toDynamoDB($args.input.id)
} )
#end
## Model key **
#if( $ctx.stash.metadata.modelObjectKey )
  #set( $keyFields = [] )
  #foreach( $entry in $ctx.stash.metadata.modelObjectKey.entrySet() )
    $util.qr($keyFields.add(\\"$entry.key\\"))
  #end
#else
  #set( $keyFields = [\\"id\\"] )
#end
#foreach( $entry in $util.map.copyAndRemoveAllKeys($mergedValues, $keyFields).entrySet() )
  #if( !$util.isNull($ctx.stash.metadata.dynamodbNameOverrideMap) && $ctx.stash.metadata.dynamodbNameOverrideMap.containsKey(\\"$entry.key\\") )
    #set( $entryKeyAttributeName = $ctx.stash.metadata.dynamodbNameOverrideMap.get(\\"$entry.key\\") )
  #else
    #set( $entryKeyAttributeName = $entry.key )
  #end
  #if( $util.isNull($entry.value) )
    #set( $discard = $expRemove.add(\\"#$entryKeyAttributeName\\") )
    $util.qr($expNames.put(\\"#$entryKeyAttributeName\\", \\"$entry.key\\"))
  #else
    $util.qr($expSet.put(\\"#$entryKeyAttributeName\\", \\":$entryKeyAttributeName\\"))
    $util.qr($expNames.put(\\"#$entryKeyAttributeName\\", \\"$entry.key\\"))
    $util.qr($expValues.put(\\":$entryKeyAttributeName\\", $util.dynamodb.toDynamoDB($entry.value)))
  #end
#end
#set( $expression = \\"\\" )
#if( !$expSet.isEmpty() )
  #set( $expression = \\"SET\\" )
  #foreach( $entry in $expSet.entrySet() )
    #set( $expression = \\"$expression $entry.key = $entry.value\\" )
    #if( $foreach.hasNext() )
      #set( $expression = \\"$expression,\\" )
    #end
  #end
#end
#if( !$expAdd.isEmpty() )
  #set( $expression = \\"$expression ADD\\" )
  #foreach( $entry in $expAdd.entrySet() )
    #set( $expression = \\"$expression $entry.key $entry.value\\" )
    #if( $foreach.hasNext() )
      #set( $expression = \\"$expression,\\" )
    #end
  #end
#end
#if( !$expRemove.isEmpty() )
  #set( $expression = \\"$expression REMOVE\\" )
  #foreach( $entry in $expRemove )
    #set( $expression = \\"$expression $entry\\" )
    #if( $foreach.hasNext() )
      #set( $expression = \\"$expression,\\" )
    #end
  #end
#end
#set( $update = {} )
$util.qr($update.put(\\"expression\\", \\"$expression\\"))
#if( !$expNames.isEmpty() )
  $util.qr($update.put(\\"expressionNames\\", $expNames))
#end
#if( !$expValues.isEmpty() )
  $util.qr($update.put(\\"expressionValues\\", $expValues))
#end
## Begin - key condition **
#if( $ctx.stash.metadata.modelObjectKey )
  #set( $keyConditionExpr = {} )
  #set( $keyConditionExprNames = {} )
  #foreach( $entry in $ctx.stash.metadata.modelObjectKey.entrySet() )
    $util.qr($keyConditionExpr.put(\\"keyCondition$velocityCount\\", {
  \\"attributeExists\\": true
}))
    $util.qr($keyConditionExprNames.put(\\"#keyCondition$velocityCount\\", \\"$entry.key\\"))
  #end
  $util.qr($ctx.stash.conditions.add($keyConditionExpr))
#else
  $util.qr($ctx.stash.conditions.add({
  \\"id\\": {
      \\"attributeExists\\": true
  }
}))
#end
## End - key condition **
#if( $args.condition )
  $util.qr($ctx.stash.conditions.add($args.condition))
#end
## Start condition block **
#if( $ctx.stash.conditions && $ctx.stash.conditions.size() != 0 )
  #set( $mergedConditions = {
  \\"and\\": $ctx.stash.conditions
} )
  #set( $Conditions = $util.parseJson($util.transform.toDynamoDBConditionExpression($mergedConditions)) )
  #if( $Conditions.expressionValues && $Conditions.expressionValues.size() == 0 )
    #set( $Conditions = {
  \\"expression\\": $Conditions.expression,
  \\"expressionNames\\": $Conditions.expressionNames
} )
  #end
  ## End condition block **
#end
#set( $UpdateItem = {
  \\"version\\": \\"2018-05-29\\",
  \\"operation\\": \\"UpdateItem\\",
  \\"key\\": $Key,
  \\"update\\": $update
} )
#if( $Conditions )
  #if( $keyConditionExprNames )
    $util.qr($Conditions.expressionNames.putAll($keyConditionExprNames))
  #end
  $util.qr($UpdateItem.put(\\"condition\\", $Conditions))
#end
$util.toJson($UpdateItem)
## [End] Mutation Update resolver. **",
  "Mutation.updatePost.res.vtl": "## [Start] ResponseTemplate. **
$util.qr($ctx.result.put(\\"__operation\\", \\"Mutation\\"))
#if( $ctx.error )
  $util.error($ctx.error.message, $ctx.error.type)
#else
  $util.toJson($ctx.result)
#end
## [End] ResponseTemplate. **",
  "Query.getPost.postAuth.1.req.vtl": "## [Start] Sandbox Mode Disabled. **
#if( !$ctx.stash.get(\\"hasAuth\\") )
  $util.unauthorized()
#end
$util.toJson({})
## [End] Sandbox Mode Disabled. **",
  "Query.getPost.req.vtl": "## [Start] Get Request template. **
#set( $GetRequest = {
  \\"version\\": \\"2018-05-29\\",
  \\"operation\\": \\"Query\\"
} )
#if( $ctx.stash.metadata.modelObjectKey )
  #set( $expression = \\"\\" )
  #set( $expressionNames = {} )
  #set( $expressionValues = {} )
  #foreach( $item in $ctx.stash.metadata.modelObjectKey.entrySet() )
    #set( $expression = \\"$expression#keyCount$velocityCount = :valueCount$velocityCount AND \\" )
    $util.qr($expressionNames.put(\\"#keyCount$velocityCount\\", $item.key))
    $util.qr($expressionValues.put(\\":valueCount$velocityCount\\", $item.value))
  #end
  #set( $expression = $expression.replaceAll(\\"AND $\\", \\"\\") )
  #set( $query = {
  \\"expression\\": $expression,
  \\"expressionNames\\": $expressionNames,
  \\"expressionValues\\": $expressionValues
} )
#else
  #set( $query = {
  \\"expression\\": \\"id = :id\\",
  \\"expressionValues\\": {
      \\":id\\":     $util.parseJson($util.dynamodb.toDynamoDBJson($ctx.args.id))
  }
} )
#end
$util.qr($GetRequest.put(\\"query\\", $query))
#if( !$util.isNullOrEmpty($ctx.stash.authFilter) )
  $util.qr($GetRequest.put(\\"filter\\", $util.parseJson($util.transform.toDynamoDBFilterExpression($ctx.stash.authFilter))))
#end
$util.toJson($GetRequest)
## [End] Get Request template. **",
  "Query.getPost.res.vtl": "## [Start] Get Response template. **
#if( $ctx.error )
  $util.error($ctx.error.message, $ctx.error.type)
#end
#if( !$ctx.result.items.isEmpty() && $ctx.result.scannedCount == 1 )
  $util.toJson($ctx.result.items[0])
#else
  #if( $ctx.result.items.isEmpty() && $ctx.result.scannedCount == 1 )
$util.unauthorized()
  #end
  $util.toJson(null)
#end
## [End] Get Response template. **",
  "Query.listPosts.postAuth.1.req.vtl": "## [Start] Sandbox Mode Disabled. **
#if( !$ctx.stash.get(\\"hasAuth\\") )
  $util.unauthorized()
#end
$util.toJson({})
## [End] Sandbox Mode Disabled. **",
  "Query.listPosts.req.vtl": "## [Start] List Request. **
#set( $args = $util.defaultIfNull($ctx.stash.transformedArgs, $ctx.args) )
#set( $limit = $util.defaultIfNull($args.limit, 100) )
#set( $ListRequest = {
  \\"version\\": \\"2018-05-29\\",
  \\"limit\\": $limit
} )
#if( $args.nextToken )
  #set( $ListRequest.nextToken = $args.nextToken )
#end
#if( !$util.isNullOrEmpty($ctx.stash.authFilter) )
  #set( $filter = $ctx.stash.authFilter )
  #if( !$util.isNullOrEmpty($args.filter) )
    #set( $filter = {
  \\"and\\":   [$filter, $args.filter]
} )
  #end
#else
  #if( !$util.isNullOrEmpty($args.filter) )
    #set( $filter = $args.filter )
  #end
#end
#if( !$util.isNullOrEmpty($filter) )
  #set( $filterExpression = $util.parseJson($util.transform.toDynamoDBFilterExpression($filter)) )
  #if( !$util.isNullOrBlank($filterExpression.expression) )
    #if( $filterExpression.expressionValues.size() == 0 )
      $util.qr($filterExpression.remove(\\"expressionValues\\"))
    #end
    #set( $ListRequest.filter = $filterExpression )
  #end
#end
#if( !$util.isNull($ctx.stash.modelQueryExpression) && !$util.isNullOrEmpty($ctx.stash.modelQueryExpression.expression) )
  $util.qr($ListRequest.put(\\"operation\\", \\"Query\\"))
  $util.qr($ListRequest.put(\\"query\\", $ctx.stash.modelQueryExpression))
  #if( !$util.isNull($args.sortDirection) && $args.sortDirection == \\"DESC\\" )
    #set( $ListRequest.scanIndexForward = false )
  #else
    #set( $ListRequest.scanIndexForward = true )
  #end
#else
  $util.qr($ListRequest.put(\\"operation\\", \\"Scan\\"))
#end
#if( !$util.isNull($ctx.stash.metadata.index) )
  #set( $ListRequest.IndexName = $ctx.stash.metadata.index )
#end
$util.toJson($ListRequest)
## [End] List Request. **",
  "Query.listPosts.res.vtl": "## [Start] ResponseTemplate. **
#if( $ctx.error )
  $util.error($ctx.error.message, $ctx.error.type)
#else
  $util.toJson($ctx.result)
#end
## [End] ResponseTemplate. **",
  "Query.searchPosts.postAuth.1.res.vtl": "## [Start] Sandbox Mode Disabled. **
#if( !$ctx.stash.get(\\"hasAuth\\") )
  $util.unauthorized()
#end
$util.toJson({})
## [End] Sandbox Mode Disabled. **",
  "Query.searchPosts.req.vtl": "#set( $args = $util.defaultIfNull($ctx.stash.transformedArgs, $ctx.args) )
#set( $indexPath = \\"/post/doc/_search\\" )
#set( $allowedAggFields = $util.defaultIfNull($ctx.stash.allowedAggFields, []) )
#set( $aggFieldsFilterMap = $util.defaultIfNull($ctx.stash.aggFieldsFilterMap, {}) )
#set( $nonKeywordFields = [] )
#set( $keyFields = [\\"id\\"] )
#set( $sortValues = [] )
#set( $sortFields = [] )
#set( $aggregateValues = {} )
#set( $primaryKey = \\"id\\" )
#if( !$util.isNullOrEmpty($args.sort) )
  #foreach( $sortItem in $args.sort )
    #if( $util.isNullOrEmpty($sortItem.field) )
      $util.qr($sortFields.add($primaryKey))
    #else
      $util.qr($sortFields.add($sortItem.field))
    #end
    #if( $util.isNullOrEmpty($sortItem.field) )
      #if( $nonKeywordFields.contains($primaryKey) )
        #set( $sortField = $util.toJson($primaryKey) )
      #else
        #set( $sortField = $util.toJson(\\"\${primaryKey}.keyword\\") )
      #end
    #else
      #if( $nonKeywordFields.contains($sortItem.field) )
        #set( $sortField = $util.toJson($sortItem.field) )
      #else
        #set( $sortField = $util.toJson(\\"\${sortItem.field}.keyword\\") )
      #end
    #end
    #if( $util.isNullOrEmpty($sortItem.direction) )
      #set( $sortDirection = $util.toJson({\\"order\\": \\"desc\\"}) )
    #else
      #set( $sortDirection = $util.toJson({\\"order\\": $sortItem.direction}) )
    #end
    $util.qr($sortValues.add(\\"{$sortField: $sortDirection}\\"))
  #end
#end
#foreach( $keyItem in $keyFields )
  #if( !$sortFields.contains($keyItem) )
    #if( $nonKeywordFields.contains($keyItem) )
      #set( $sortField = $util.toJson($keyItem) )
    #else
      #set( $sortField = $util.toJson(\\"\${keyItem}.keyword\\") )
    #end
    #set( $sortDirection = $util.toJson({\\"order\\": \\"desc\\"}) )
    $util.qr($sortValues.add(\\"{$sortField: $sortDirection}\\"))
  #end
#end
#foreach( $aggItem in $args.aggregates )
  #if( $allowedAggFields.contains($aggItem.field) )
    #set( $aggFilter = { \\"match_all\\": {} } )
  #elseif( $aggFieldsFilterMap.containsKey($aggItem.field) )
    #set( $aggFilter = { \\"bool\\": { \\"should\\": $aggFieldsFilterMap.get($aggItem.field) } } )
  #else
    $util.error(\\"Unauthorized to run aggregation on field: \${aggItem.field}\\", \\"Unauthorized\\")
  #end
  #if( $nonKeywordFields.contains($aggItem.field) )
    $util.qr($aggregateValues.put(\\"$aggItem.name\\", { \\"filter\\": $aggFilter, \\"aggs\\": { \\"$aggItem.name\\": { \\"$aggItem.type\\": { \\"field\\": \\"$aggItem.field\\" }}} }))
  #else
    $util.qr($aggregateValues.put(\\"$aggItem.name\\", { \\"filter\\": $aggFilter, \\"aggs\\": { \\"$aggItem.name\\": { \\"$aggItem.type\\": { \\"field\\": \\"\${aggItem.field}.keyword\\" }}} }))
  #end
#end
#if( !$util.isNullOrEmpty($ctx.stash.authFilter) )
  #set( $filter = $ctx.stash.authFilter )
  #if( !$util.isNullOrEmpty($args.filter) )
    #set( $filter = {
  \\"bool\\": {
      \\"must\\":     [$ctx.stash.authFilter, $util.parseJson($util.transform.toElasticsearchQueryDSL($args.filter))]
  }
} )
  #end
#else
  #if( !$util.isNullOrEmpty($args.filter) )
    #set( $filter = $util.parseJson($util.transform.toElasticsearchQueryDSL($args.filter)) )
  #end
#end
#if( $util.isNullOrEmpty($filter) )
  #set( $filter = {
  \\"match_all\\": {}
} )
#end
{
  \\"version\\": \\"2018-05-29\\",
  \\"operation\\": \\"GET\\",
  \\"path\\": \\"$indexPath\\",
  \\"params\\": {
      \\"body\\":     {
                #if( $context.args.nextToken )\\"search_after\\": $util.base64Decode($args.nextToken), #end
                #if( $context.args.from )\\"from\\": $args.from, #end
                \\"size\\": #if( $args.limit ) $args.limit #else 100 #end,
                \\"sort\\": $sortValues,
                \\"version\\": false,
                \\"query\\": $util.toJson($filter),
                \\"aggs\\": $util.toJson($aggregateValues)
                }
  }
}",
  "Query.searchPosts.res.vtl": "#set( $es_items = [] )
#set( $aggregateValues = [] )
#foreach( $entry in $context.result.hits.hits )
  #if( !$foreach.hasNext )
    #set( $nextToken = $util.base64Encode($util.toJson($entry.sort)) )
  #end
  $util.qr($es_items.add($entry.get(\\"_source\\")))
#end
#foreach( $aggItem in $context.result.aggregations.keySet() )
  #set( $aggResult = {} )
  #set( $aggResultValue = {} )
  #set( $currentAggItem = $ctx.result.aggregations.get($aggItem) )
  $util.qr($aggResult.put(\\"name\\", $aggItem))
  #if( !$util.isNullOrEmpty($currentAggItem) )
    #if( !$util.isNullOrEmpty($currentAggItem.get($aggItem).buckets) )
      $util.qr($aggResultValue.put(\\"__typename\\", \\"SearchableAggregateBucketResult\\"))
      $util.qr($aggResultValue.put(\\"buckets\\", $currentAggItem.get($aggItem).buckets))
    #end
    #if( !$util.isNullOrEmpty($currentAggItem.get($aggItem).value) )
      $util.qr($aggResultValue.put(\\"__typename\\", \\"SearchableAggregateScalarResult\\"))
      $util.qr($aggResultValue.put(\\"value\\", $currentAggItem.get($aggItem).value))
    #end
  #end
  $util.qr($aggResult.put(\\"result\\", $aggResultValue))
  $util.qr($aggregateValues.add($aggResult))
#end
$util.toJson({
  \\"items\\": $es_items,
  \\"total\\": $ctx.result.hits.total.value,
  \\"nextToken\\": $nextToken,
  \\"aggregateItems\\": $aggregateValues
})",
  "Subscription.onCreatePost.postAuth.1.req.vtl": "## [Start] Sandbox Mode Disabled. **
#if( !$ctx.stash.get(\\"hasAuth\\") )
  $util.unauthorized()
#end
$util.toJson({})
## [End] Sandbox Mode Disabled. **",
  "Subscription.onCreatePost.req.vtl": "## [Start] Subscription Request template. **
$util.toJson({
  \\"version\\": \\"2018-05-29\\",
  \\"payload\\": {}
})
## [End] Subscription Request template. **",
  "Subscription.onCreatePost.res.vtl": "## [Start] Subscription Response template. **
$util.toJson(null)
## [End] Subscription Response template. **",
  "Subscription.onDeletePost.postAuth.1.req.vtl": "## [Start] Sandbox Mode Disabled. **
#if( !$ctx.stash.get(\\"hasAuth\\") )
  $util.unauthorized()
#end
$util.toJson({})
## [End] Sandbox Mode Disabled. **",
  "Subscription.onDeletePost.req.vtl": "## [Start] Subscription Request template. **
$util.toJson({
  \\"version\\": \\"2018-05-29\\",
  \\"payload\\": {}
})
## [End] Subscription Request template. **",
  "Subscription.onDeletePost.res.vtl": "## [Start] Subscription Response template. **
$util.toJson(null)
## [End] Subscription Response template. **",
  "Subscription.onUpdatePost.postAuth.1.req.vtl": "## [Start] Sandbox Mode Disabled. **
#if( !$ctx.stash.get(\\"hasAuth\\") )
  $util.unauthorized()
#end
$util.toJson({})
## [End] Sandbox Mode Disabled. **",
  "Subscription.onUpdatePost.req.vtl": "## [Start] Subscription Request template. **
$util.toJson({
  \\"version\\": \\"2018-05-29\\",
  \\"payload\\": {}
})
## [End] Subscription Request template. **",
  "Subscription.onUpdatePost.res.vtl": "## [Start] Subscription Response template. **
$util.toJson(null)
## [End] Subscription Response template. **",
}
`;

exports[`Test SearchableModelTransformer with datastore enabled vtl 1`] = `
"#set( $args = $util.defaultIfNull($ctx.stash.transformedArgs, $ctx.args) )
#set( $indexPath = \\"/post/doc/_search\\" )
#set( $allowedAggFields = $util.defaultIfNull($ctx.stash.allowedAggFields, []) )
#set( $aggFieldsFilterMap = $util.defaultIfNull($ctx.stash.aggFieldsFilterMap, {}) )
#set( $nonKeywordFields = [] )
#set( $keyFields = [\\"id\\"] )
#set( $sortValues = [] )
#set( $sortFields = [] )
#set( $aggregateValues = {} )
#set( $primaryKey = \\"id\\" )
#if( !$util.isNullOrEmpty($args.sort) )
  #foreach( $sortItem in $args.sort )
    #if( $util.isNullOrEmpty($sortItem.field) )
      $util.qr($sortFields.add($primaryKey))
    #else
      $util.qr($sortFields.add($sortItem.field))
    #end
    #if( $util.isNullOrEmpty($sortItem.field) )
      #if( $nonKeywordFields.contains($primaryKey) )
        #set( $sortField = $util.toJson($primaryKey) )
      #else
        #set( $sortField = $util.toJson(\\"\${primaryKey}.keyword\\") )
      #end
    #else
      #if( $nonKeywordFields.contains($sortItem.field) )
        #set( $sortField = $util.toJson($sortItem.field) )
      #else
        #set( $sortField = $util.toJson(\\"\${sortItem.field}.keyword\\") )
      #end
    #end
    #if( $util.isNullOrEmpty($sortItem.direction) )
      #set( $sortDirection = $util.toJson({\\"order\\": \\"desc\\"}) )
    #else
      #set( $sortDirection = $util.toJson({\\"order\\": $sortItem.direction}) )
    #end
    $util.qr($sortValues.add(\\"{$sortField: $sortDirection}\\"))
  #end
#end
#foreach( $keyItem in $keyFields )
  #if( !$sortFields.contains($keyItem) )
    #if( $nonKeywordFields.contains($keyItem) )
      #set( $sortField = $util.toJson($keyItem) )
    #else
      #set( $sortField = $util.toJson(\\"\${keyItem}.keyword\\") )
    #end
    #set( $sortDirection = $util.toJson({\\"order\\": \\"desc\\"}) )
    $util.qr($sortValues.add(\\"{$sortField: $sortDirection}\\"))
  #end
#end
#foreach( $aggItem in $args.aggregates )
  #if( $allowedAggFields.contains($aggItem.field) )
    #set( $aggFilter = { \\"match_all\\": {} } )
  #elseif( $aggFieldsFilterMap.containsKey($aggItem.field) )
    #set( $aggFilter = { \\"bool\\": { \\"should\\": $aggFieldsFilterMap.get($aggItem.field) } } )
  #else
    $util.error(\\"Unauthorized to run aggregation on field: \${aggItem.field}\\", \\"Unauthorized\\")
  #end
  #if( $nonKeywordFields.contains($aggItem.field) )
    $util.qr($aggregateValues.put(\\"$aggItem.name\\", { \\"filter\\": $aggFilter, \\"aggs\\": { \\"$aggItem.name\\": { \\"$aggItem.type\\": { \\"field\\": \\"$aggItem.field\\" }}} }))
  #else
    $util.qr($aggregateValues.put(\\"$aggItem.name\\", { \\"filter\\": $aggFilter, \\"aggs\\": { \\"$aggItem.name\\": { \\"$aggItem.type\\": { \\"field\\": \\"\${aggItem.field}.keyword\\" }}} }))
  #end
#end
#if( !$util.isNullOrEmpty($ctx.stash.authFilter) )
  #set( $filter = $ctx.stash.authFilter )
  #if( !$util.isNullOrEmpty($args.filter) )
    #set( $filter = {
  \\"bool\\": {
      \\"must\\":     [$ctx.stash.authFilter, $util.parseJson($util.transform.toElasticsearchQueryDSL($args.filter))]
  }
} )
  #end
#else
  #if( !$util.isNullOrEmpty($args.filter) )
    #set( $filter = $util.parseJson($util.transform.toElasticsearchQueryDSL($args.filter)) )
  #end
#end
#if( $util.isNullOrEmpty($filter) )
  #set( $filter = {
  \\"match_all\\": {}
} )
#end
{
  \\"version\\": \\"2018-05-29\\",
  \\"operation\\": \\"GET\\",
  \\"path\\": \\"$indexPath\\",
  \\"params\\": {
      \\"body\\":     {
                #if( $context.args.nextToken )\\"search_after\\": $util.base64Decode($args.nextToken), #end
                #if( $context.args.from )\\"from\\": $args.from, #end
                \\"size\\": #if( $args.limit ) $args.limit #else 100 #end,
                \\"sort\\": $sortValues,
                \\"version\\": true,
                \\"query\\": $util.toJson($filter),
                \\"aggs\\": $util.toJson($aggregateValues)
                }
  }
}"
`;

exports[`Test SearchableModelTransformer with datastore enabled vtl 2`] = `
"#set( $es_items = [] )
#set( $aggregateValues = [] )
#foreach( $entry in $context.result.hits.hits )
  #if( !$foreach.hasNext )
    #set( $nextToken = $util.base64Encode($util.toJson($entry.sort)) )
  #end
  #set( $row = $entry.get(\\"_source\\") )
  $util.qr($row.put(\\"_version\\", $entry.get(\\"_version\\")))
  $util.qr($es_items.add($row))
#end
#foreach( $aggItem in $context.result.aggregations.keySet() )
  #set( $aggResult = {} )
  #set( $aggResultValue = {} )
  #set( $currentAggItem = $ctx.result.aggregations.get($aggItem) )
  $util.qr($aggResult.put(\\"name\\", $aggItem))
  #if( !$util.isNullOrEmpty($currentAggItem) )
    #if( !$util.isNullOrEmpty($currentAggItem.get($aggItem).buckets) )
      $util.qr($aggResultValue.put(\\"__typename\\", \\"SearchableAggregateBucketResult\\"))
      $util.qr($aggResultValue.put(\\"buckets\\", $currentAggItem.get($aggItem).buckets))
    #end
    #if( !$util.isNullOrEmpty($currentAggItem.get($aggItem).value) )
      $util.qr($aggResultValue.put(\\"__typename\\", \\"SearchableAggregateScalarResult\\"))
      $util.qr($aggResultValue.put(\\"value\\", $currentAggItem.get($aggItem).value))
    #end
  #end
  $util.qr($aggResult.put(\\"result\\", $aggResultValue))
  $util.qr($aggregateValues.add($aggResult))
#end
$util.toJson({
  \\"items\\": $es_items,
  \\"total\\": $ctx.result.hits.total.value,
  \\"nextToken\\": $nextToken,
  \\"aggregateItems\\": $aggregateValues
})"
`;

exports[`Test SearchableModelTransformer with multiple model searchable directives 1`] = `
"
type Post {
  id: ID!
  title: String!
  createdAt: String
  updatedAt: String
}

type User {
  id: ID!
  name: String!
  createdAt: AWSDateTime!
  updatedAt: AWSDateTime!
}

type SearchablePostConnection {
  items: [Post]!
  nextToken: String
  total: Int
  aggregateItems: [SearchableAggregateResult]!
}

type SearchableAggregateResult {
  name: String!
  result: SearchableAggregateGenericResult
}

type SearchableAggregateScalarResult {
  value: Float!
}

type SearchableAggregateBucketResult {
  buckets: [SearchableAggregateBucketResultItem]
}

type SearchableAggregateBucketResultItem {
  key: String!
  doc_count: Int!
}

union SearchableAggregateGenericResult = SearchableAggregateScalarResult | SearchableAggregateBucketResult

type Query {
  searchPosts(filter: SearchablePostFilterInput, sort: [SearchablePostSortInput], limit: Int, nextToken: String, from: Int, aggregates: [SearchablePostAggregationInput]): SearchablePostConnection
  searchUsers(filter: SearchableUserFilterInput, sort: [SearchableUserSortInput], limit: Int, nextToken: String, from: Int, aggregates: [SearchableUserAggregationInput]): SearchableUserConnection
  getPost(id: ID!): Post
  listPosts(filter: ModelPostFilterInput, limit: Int, nextToken: String): ModelPostConnection
  getUser(id: ID!): User
  listUsers(filter: ModelUserFilterInput, limit: Int, nextToken: String): ModelUserConnection
}

type SearchableUserConnection {
  items: [User]!
  nextToken: String
  total: Int
  aggregateItems: [SearchableAggregateResult]!
}

input ModelStringInput {
  ne: String
  eq: String
  le: String
  lt: String
  ge: String
  gt: String
  contains: String
  notContains: String
  between: [String]
  beginsWith: String
  attributeExists: Boolean
  attributeType: ModelAttributeTypes
  size: ModelSizeInput
}

input ModelIntInput {
  ne: Int
  eq: Int
  le: Int
  lt: Int
  ge: Int
  gt: Int
  between: [Int]
  attributeExists: Boolean
  attributeType: ModelAttributeTypes
}

input ModelFloatInput {
  ne: Float
  eq: Float
  le: Float
  lt: Float
  ge: Float
  gt: Float
  between: [Float]
  attributeExists: Boolean
  attributeType: ModelAttributeTypes
}

input ModelBooleanInput {
  ne: Boolean
  eq: Boolean
  attributeExists: Boolean
  attributeType: ModelAttributeTypes
}

input ModelIDInput {
  ne: ID
  eq: ID
  le: ID
  lt: ID
  ge: ID
  gt: ID
  contains: ID
  notContains: ID
  between: [ID]
  beginsWith: ID
  attributeExists: Boolean
  attributeType: ModelAttributeTypes
  size: ModelSizeInput
}

enum ModelAttributeTypes {
  binary
  binarySet
  bool
  list
  map
  number
  numberSet
  string
  stringSet
  _null
}

input ModelSizeInput {
  ne: Int
  eq: Int
  le: Int
  lt: Int
  ge: Int
  gt: Int
  between: [Int]
}

enum ModelSortDirection {
  ASC
  DESC
}

type ModelPostConnection {
  items: [Post]!
  nextToken: String
}

input ModelPostFilterInput {
  id: ModelIDInput
  title: ModelStringInput
  createdAt: ModelStringInput
  updatedAt: ModelStringInput
  and: [ModelPostFilterInput]
  or: [ModelPostFilterInput]
  not: ModelPostFilterInput
}

input ModelPostConditionInput {
  title: ModelStringInput
  createdAt: ModelStringInput
  updatedAt: ModelStringInput
  and: [ModelPostConditionInput]
  or: [ModelPostConditionInput]
  not: ModelPostConditionInput
}

input CreatePostInput {
  id: ID
  title: String!
  createdAt: String
  updatedAt: String
}

input UpdatePostInput {
  id: ID!
  title: String
  createdAt: String
  updatedAt: String
}

input DeletePostInput {
  id: ID!
}

type Mutation {
  createPost(input: CreatePostInput!, condition: ModelPostConditionInput): Post
  updatePost(input: UpdatePostInput!, condition: ModelPostConditionInput): Post
  deletePost(input: DeletePostInput!, condition: ModelPostConditionInput): Post
  createUser(input: CreateUserInput!, condition: ModelUserConditionInput): User
  updateUser(input: UpdateUserInput!, condition: ModelUserConditionInput): User
  deleteUser(input: DeleteUserInput!, condition: ModelUserConditionInput): User
}

type Subscription {
  onCreatePost: Post @aws_subscribe(mutations: [\\"createPost\\"])
  onUpdatePost: Post @aws_subscribe(mutations: [\\"updatePost\\"])
  onDeletePost: Post @aws_subscribe(mutations: [\\"deletePost\\"])
  onCreateUser: User @aws_subscribe(mutations: [\\"createUser\\"])
  onUpdateUser: User @aws_subscribe(mutations: [\\"updateUser\\"])
  onDeleteUser: User @aws_subscribe(mutations: [\\"deleteUser\\"])
}

type ModelUserConnection {
  items: [User]!
  nextToken: String
}

input ModelUserFilterInput {
  id: ModelIDInput
  name: ModelStringInput
  and: [ModelUserFilterInput]
  or: [ModelUserFilterInput]
  not: ModelUserFilterInput
}

input ModelUserConditionInput {
  name: ModelStringInput
  and: [ModelUserConditionInput]
  or: [ModelUserConditionInput]
  not: ModelUserConditionInput
}

input CreateUserInput {
  id: ID
  name: String!
}

input UpdateUserInput {
  id: ID!
  name: String
}

input DeleteUserInput {
  id: ID!
}

input SearchableStringFilterInput {
  ne: String
  gt: String
  lt: String
  gte: String
  lte: String
  eq: String
  match: String
  matchPhrase: String
  matchPhrasePrefix: String
  multiMatch: String
  exists: Boolean
  wildcard: String
  regexp: String
  range: [String]
}

input SearchableIntFilterInput {
  ne: Int
  gt: Int
  lt: Int
  gte: Int
  lte: Int
  eq: Int
  range: [Int]
}

input SearchableFloatFilterInput {
  ne: Float
  gt: Float
  lt: Float
  gte: Float
  lte: Float
  eq: Float
  range: [Float]
}

input SearchableBooleanFilterInput {
  eq: Boolean
  ne: Boolean
}

input SearchableIDFilterInput {
  ne: ID
  gt: ID
  lt: ID
  gte: ID
  lte: ID
  eq: ID
  match: ID
  matchPhrase: ID
  matchPhrasePrefix: ID
  multiMatch: ID
  exists: Boolean
  wildcard: ID
  regexp: ID
  range: [ID]
}

input SearchablePostFilterInput {
  id: SearchableIDFilterInput
  title: SearchableStringFilterInput
  createdAt: SearchableStringFilterInput
  updatedAt: SearchableStringFilterInput
  and: [SearchablePostFilterInput]
  or: [SearchablePostFilterInput]
  not: SearchablePostFilterInput
}

enum SearchableSortDirection {
  asc
  desc
}

enum SearchablePostSortableFields {
  id
  title
  createdAt
  updatedAt
}

input SearchablePostSortInput {
  field: SearchablePostSortableFields
  direction: SearchableSortDirection
}

enum SearchableAggregateType {
  terms
  avg
  min
  max
  sum
}

enum SearchablePostAggregateField {
  id
  title
  createdAt
  updatedAt
}

input SearchablePostAggregationInput {
  name: String!
  type: SearchableAggregateType!
  field: SearchablePostAggregateField!
}

input SearchableUserFilterInput {
  id: SearchableIDFilterInput
  name: SearchableStringFilterInput
  createdAt: SearchableStringFilterInput
  updatedAt: SearchableStringFilterInput
  and: [SearchableUserFilterInput]
  or: [SearchableUserFilterInput]
  not: SearchableUserFilterInput
}

enum SearchableUserSortableFields {
  id
  name
  createdAt
  updatedAt
}

input SearchableUserSortInput {
  field: SearchableUserSortableFields
  direction: SearchableSortDirection
}

enum SearchableUserAggregateField {
  id
  name
  createdAt
  updatedAt
}

input SearchableUserAggregationInput {
  name: String!
  type: SearchableAggregateType!
  field: SearchableUserAggregateField!
}

"
`;

exports[`Test SearchableModelTransformer with only create mutations 1`] = `
"
type Post {
  id: ID!
  title: String!
  createdAt: String
  updatedAt: String
}

type SearchablePostConnection {
  items: [Post]!
  nextToken: String
  total: Int
  aggregateItems: [SearchableAggregateResult]!
}

type SearchableAggregateResult {
  name: String!
  result: SearchableAggregateGenericResult
}

type SearchableAggregateScalarResult {
  value: Float!
}

type SearchableAggregateBucketResult {
  buckets: [SearchableAggregateBucketResultItem]
}

type SearchableAggregateBucketResultItem {
  key: String!
  doc_count: Int!
}

union SearchableAggregateGenericResult = SearchableAggregateScalarResult | SearchableAggregateBucketResult

type Query {
  searchPosts(filter: SearchablePostFilterInput, sort: [SearchablePostSortInput], limit: Int, nextToken: String, from: Int, aggregates: [SearchablePostAggregationInput]): SearchablePostConnection
  getPost(id: ID!): Post
  listPosts(filter: ModelPostFilterInput, limit: Int, nextToken: String): ModelPostConnection
}

input ModelStringInput {
  ne: String
  eq: String
  le: String
  lt: String
  ge: String
  gt: String
  contains: String
  notContains: String
  between: [String]
  beginsWith: String
  attributeExists: Boolean
  attributeType: ModelAttributeTypes
  size: ModelSizeInput
}

input ModelIntInput {
  ne: Int
  eq: Int
  le: Int
  lt: Int
  ge: Int
  gt: Int
  between: [Int]
  attributeExists: Boolean
  attributeType: ModelAttributeTypes
}

input ModelFloatInput {
  ne: Float
  eq: Float
  le: Float
  lt: Float
  ge: Float
  gt: Float
  between: [Float]
  attributeExists: Boolean
  attributeType: ModelAttributeTypes
}

input ModelBooleanInput {
  ne: Boolean
  eq: Boolean
  attributeExists: Boolean
  attributeType: ModelAttributeTypes
}

input ModelIDInput {
  ne: ID
  eq: ID
  le: ID
  lt: ID
  ge: ID
  gt: ID
  contains: ID
  notContains: ID
  between: [ID]
  beginsWith: ID
  attributeExists: Boolean
  attributeType: ModelAttributeTypes
  size: ModelSizeInput
}

enum ModelAttributeTypes {
  binary
  binarySet
  bool
  list
  map
  number
  numberSet
  string
  stringSet
  _null
}

input ModelSizeInput {
  ne: Int
  eq: Int
  le: Int
  lt: Int
  ge: Int
  gt: Int
  between: [Int]
}

enum ModelSortDirection {
  ASC
  DESC
}

type ModelPostConnection {
  items: [Post]!
  nextToken: String
}

input ModelPostFilterInput {
  id: ModelIDInput
  title: ModelStringInput
  createdAt: ModelStringInput
  updatedAt: ModelStringInput
  and: [ModelPostFilterInput]
  or: [ModelPostFilterInput]
  not: ModelPostFilterInput
}

input ModelPostConditionInput {
  title: ModelStringInput
  createdAt: ModelStringInput
  updatedAt: ModelStringInput
  and: [ModelPostConditionInput]
  or: [ModelPostConditionInput]
  not: ModelPostConditionInput
}

input CreatePostInput {
  id: ID
  title: String!
  createdAt: String
  updatedAt: String
}

type Mutation {
  customCreatePost(input: CreatePostInput!, condition: ModelPostConditionInput): Post
}

type Subscription {
  onCreatePost: Post @aws_subscribe(mutations: [\\"customCreatePost\\"])
}

input SearchableStringFilterInput {
  ne: String
  gt: String
  lt: String
  gte: String
  lte: String
  eq: String
  match: String
  matchPhrase: String
  matchPhrasePrefix: String
  multiMatch: String
  exists: Boolean
  wildcard: String
  regexp: String
  range: [String]
}

input SearchableIntFilterInput {
  ne: Int
  gt: Int
  lt: Int
  gte: Int
  lte: Int
  eq: Int
  range: [Int]
}

input SearchableFloatFilterInput {
  ne: Float
  gt: Float
  lt: Float
  gte: Float
  lte: Float
  eq: Float
  range: [Float]
}

input SearchableBooleanFilterInput {
  eq: Boolean
  ne: Boolean
}

input SearchableIDFilterInput {
  ne: ID
  gt: ID
  lt: ID
  gte: ID
  lte: ID
  eq: ID
  match: ID
  matchPhrase: ID
  matchPhrasePrefix: ID
  multiMatch: ID
  exists: Boolean
  wildcard: ID
  regexp: ID
  range: [ID]
}

input SearchablePostFilterInput {
  id: SearchableIDFilterInput
  title: SearchableStringFilterInput
  createdAt: SearchableStringFilterInput
  updatedAt: SearchableStringFilterInput
  and: [SearchablePostFilterInput]
  or: [SearchablePostFilterInput]
  not: SearchablePostFilterInput
}

enum SearchableSortDirection {
  asc
  desc
}

enum SearchablePostSortableFields {
  id
  title
  createdAt
  updatedAt
}

input SearchablePostSortInput {
  field: SearchablePostSortableFields
  direction: SearchableSortDirection
}

enum SearchableAggregateType {
  terms
  avg
  min
  max
  sum
}

enum SearchablePostAggregateField {
  id
  title
  createdAt
  updatedAt
}

input SearchablePostAggregationInput {
  name: String!
  type: SearchableAggregateType!
  field: SearchablePostAggregateField!
}

"
`;

exports[`Test SearchableModelTransformer with query overrides 1`] = `
"
type Post {
  id: ID!
  title: String!
  createdAt: String
  updatedAt: String
}

type SearchablePostConnection {
  items: [Post]!
  nextToken: String
  total: Int
  aggregateItems: [SearchableAggregateResult]!
}

type SearchableAggregateResult {
  name: String!
  result: SearchableAggregateGenericResult
}

type SearchableAggregateScalarResult {
  value: Float!
}

type SearchableAggregateBucketResult {
  buckets: [SearchableAggregateBucketResultItem]
}

type SearchableAggregateBucketResultItem {
  key: String!
  doc_count: Int!
}

union SearchableAggregateGenericResult = SearchableAggregateScalarResult | SearchableAggregateBucketResult

type Query {
  customSearchPost(filter: SearchablePostFilterInput, sort: [SearchablePostSortInput], limit: Int, nextToken: String, from: Int, aggregates: [SearchablePostAggregationInput]): SearchablePostConnection
  getPost(id: ID!): Post
  listPosts(filter: ModelPostFilterInput, limit: Int, nextToken: String): ModelPostConnection
}

input ModelStringInput {
  ne: String
  eq: String
  le: String
  lt: String
  ge: String
  gt: String
  contains: String
  notContains: String
  between: [String]
  beginsWith: String
  attributeExists: Boolean
  attributeType: ModelAttributeTypes
  size: ModelSizeInput
}

input ModelIntInput {
  ne: Int
  eq: Int
  le: Int
  lt: Int
  ge: Int
  gt: Int
  between: [Int]
  attributeExists: Boolean
  attributeType: ModelAttributeTypes
}

input ModelFloatInput {
  ne: Float
  eq: Float
  le: Float
  lt: Float
  ge: Float
  gt: Float
  between: [Float]
  attributeExists: Boolean
  attributeType: ModelAttributeTypes
}

input ModelBooleanInput {
  ne: Boolean
  eq: Boolean
  attributeExists: Boolean
  attributeType: ModelAttributeTypes
}

input ModelIDInput {
  ne: ID
  eq: ID
  le: ID
  lt: ID
  ge: ID
  gt: ID
  contains: ID
  notContains: ID
  between: [ID]
  beginsWith: ID
  attributeExists: Boolean
  attributeType: ModelAttributeTypes
  size: ModelSizeInput
}

enum ModelAttributeTypes {
  binary
  binarySet
  bool
  list
  map
  number
  numberSet
  string
  stringSet
  _null
}

input ModelSizeInput {
  ne: Int
  eq: Int
  le: Int
  lt: Int
  ge: Int
  gt: Int
  between: [Int]
}

enum ModelSortDirection {
  ASC
  DESC
}

type ModelPostConnection {
  items: [Post]!
  nextToken: String
}

input ModelPostFilterInput {
  id: ModelIDInput
  title: ModelStringInput
  createdAt: ModelStringInput
  updatedAt: ModelStringInput
  and: [ModelPostFilterInput]
  or: [ModelPostFilterInput]
  not: ModelPostFilterInput
}

input ModelPostConditionInput {
  title: ModelStringInput
  createdAt: ModelStringInput
  updatedAt: ModelStringInput
  and: [ModelPostConditionInput]
  or: [ModelPostConditionInput]
  not: ModelPostConditionInput
}

input CreatePostInput {
  id: ID
  title: String!
  createdAt: String
  updatedAt: String
}

input UpdatePostInput {
  id: ID!
  title: String
  createdAt: String
  updatedAt: String
}

input DeletePostInput {
  id: ID!
}

type Mutation {
  createPost(input: CreatePostInput!, condition: ModelPostConditionInput): Post
  updatePost(input: UpdatePostInput!, condition: ModelPostConditionInput): Post
  deletePost(input: DeletePostInput!, condition: ModelPostConditionInput): Post
}

type Subscription {
  onCreatePost: Post @aws_subscribe(mutations: [\\"createPost\\"])
  onUpdatePost: Post @aws_subscribe(mutations: [\\"updatePost\\"])
  onDeletePost: Post @aws_subscribe(mutations: [\\"deletePost\\"])
}

input SearchableStringFilterInput {
  ne: String
  gt: String
  lt: String
  gte: String
  lte: String
  eq: String
  match: String
  matchPhrase: String
  matchPhrasePrefix: String
  multiMatch: String
  exists: Boolean
  wildcard: String
  regexp: String
  range: [String]
}

input SearchableIntFilterInput {
  ne: Int
  gt: Int
  lt: Int
  gte: Int
  lte: Int
  eq: Int
  range: [Int]
}

input SearchableFloatFilterInput {
  ne: Float
  gt: Float
  lt: Float
  gte: Float
  lte: Float
  eq: Float
  range: [Float]
}

input SearchableBooleanFilterInput {
  eq: Boolean
  ne: Boolean
}

input SearchableIDFilterInput {
  ne: ID
  gt: ID
  lt: ID
  gte: ID
  lte: ID
  eq: ID
  match: ID
  matchPhrase: ID
  matchPhrasePrefix: ID
  multiMatch: ID
  exists: Boolean
  wildcard: ID
  regexp: ID
  range: [ID]
}

input SearchablePostFilterInput {
  id: SearchableIDFilterInput
  title: SearchableStringFilterInput
  createdAt: SearchableStringFilterInput
  updatedAt: SearchableStringFilterInput
  and: [SearchablePostFilterInput]
  or: [SearchablePostFilterInput]
  not: SearchablePostFilterInput
}

enum SearchableSortDirection {
  asc
  desc
}

enum SearchablePostSortableFields {
  id
  title
  createdAt
  updatedAt
}

input SearchablePostSortInput {
  field: SearchablePostSortableFields
  direction: SearchableSortDirection
}

enum SearchableAggregateType {
  terms
  avg
  min
  max
  sum
}

enum SearchablePostAggregateField {
  id
  title
  createdAt
  updatedAt
}

input SearchablePostAggregationInput {
  name: String!
  type: SearchableAggregateType!
  field: SearchablePostAggregateField!
}

"
`;

exports[`Test SearchableModelTransformer with sort fields 1`] = `
"
type Post {
  id: ID!
  title: String!
  createdAt: String
  updatedAt: String
}

type SearchablePostConnection {
  items: [Post]!
  nextToken: String
  total: Int
  aggregateItems: [SearchableAggregateResult]!
}

type SearchableAggregateResult {
  name: String!
  result: SearchableAggregateGenericResult
}

type SearchableAggregateScalarResult {
  value: Float!
}

type SearchableAggregateBucketResult {
  buckets: [SearchableAggregateBucketResultItem]
}

type SearchableAggregateBucketResultItem {
  key: String!
  doc_count: Int!
}

union SearchableAggregateGenericResult = SearchableAggregateScalarResult | SearchableAggregateBucketResult

type Query {
  searchPosts(filter: SearchablePostFilterInput, sort: [SearchablePostSortInput], limit: Int, nextToken: String, from: Int, aggregates: [SearchablePostAggregationInput]): SearchablePostConnection
  getPost(id: ID!): Post
  listPosts(filter: ModelPostFilterInput, limit: Int, nextToken: String): ModelPostConnection
}

input ModelStringInput {
  ne: String
  eq: String
  le: String
  lt: String
  ge: String
  gt: String
  contains: String
  notContains: String
  between: [String]
  beginsWith: String
  attributeExists: Boolean
  attributeType: ModelAttributeTypes
  size: ModelSizeInput
}

input ModelIntInput {
  ne: Int
  eq: Int
  le: Int
  lt: Int
  ge: Int
  gt: Int
  between: [Int]
  attributeExists: Boolean
  attributeType: ModelAttributeTypes
}

input ModelFloatInput {
  ne: Float
  eq: Float
  le: Float
  lt: Float
  ge: Float
  gt: Float
  between: [Float]
  attributeExists: Boolean
  attributeType: ModelAttributeTypes
}

input ModelBooleanInput {
  ne: Boolean
  eq: Boolean
  attributeExists: Boolean
  attributeType: ModelAttributeTypes
}

input ModelIDInput {
  ne: ID
  eq: ID
  le: ID
  lt: ID
  ge: ID
  gt: ID
  contains: ID
  notContains: ID
  between: [ID]
  beginsWith: ID
  attributeExists: Boolean
  attributeType: ModelAttributeTypes
  size: ModelSizeInput
}

enum ModelAttributeTypes {
  binary
  binarySet
  bool
  list
  map
  number
  numberSet
  string
  stringSet
  _null
}

input ModelSizeInput {
  ne: Int
  eq: Int
  le: Int
  lt: Int
  ge: Int
  gt: Int
  between: [Int]
}

enum ModelSortDirection {
  ASC
  DESC
}

type ModelPostConnection {
  items: [Post]!
  nextToken: String
}

input ModelPostFilterInput {
  id: ModelIDInput
  title: ModelStringInput
  createdAt: ModelStringInput
  updatedAt: ModelStringInput
  and: [ModelPostFilterInput]
  or: [ModelPostFilterInput]
  not: ModelPostFilterInput
}

input ModelPostConditionInput {
  title: ModelStringInput
  createdAt: ModelStringInput
  updatedAt: ModelStringInput
  and: [ModelPostConditionInput]
  or: [ModelPostConditionInput]
  not: ModelPostConditionInput
}

input CreatePostInput {
  id: ID
  title: String!
  createdAt: String
  updatedAt: String
}

input UpdatePostInput {
  id: ID!
  title: String
  createdAt: String
  updatedAt: String
}

input DeletePostInput {
  id: ID!
}

type Mutation {
  createPost(input: CreatePostInput!, condition: ModelPostConditionInput): Post
  updatePost(input: UpdatePostInput!, condition: ModelPostConditionInput): Post
  deletePost(input: DeletePostInput!, condition: ModelPostConditionInput): Post
}

type Subscription {
  onCreatePost: Post @aws_subscribe(mutations: [\\"createPost\\"])
  onUpdatePost: Post @aws_subscribe(mutations: [\\"updatePost\\"])
  onDeletePost: Post @aws_subscribe(mutations: [\\"deletePost\\"])
}

input SearchableStringFilterInput {
  ne: String
  gt: String
  lt: String
  gte: String
  lte: String
  eq: String
  match: String
  matchPhrase: String
  matchPhrasePrefix: String
  multiMatch: String
  exists: Boolean
  wildcard: String
  regexp: String
  range: [String]
}

input SearchableIntFilterInput {
  ne: Int
  gt: Int
  lt: Int
  gte: Int
  lte: Int
  eq: Int
  range: [Int]
}

input SearchableFloatFilterInput {
  ne: Float
  gt: Float
  lt: Float
  gte: Float
  lte: Float
  eq: Float
  range: [Float]
}

input SearchableBooleanFilterInput {
  eq: Boolean
  ne: Boolean
}

input SearchableIDFilterInput {
  ne: ID
  gt: ID
  lt: ID
  gte: ID
  lte: ID
  eq: ID
  match: ID
  matchPhrase: ID
  matchPhrasePrefix: ID
  multiMatch: ID
  exists: Boolean
  wildcard: ID
  regexp: ID
  range: [ID]
}

input SearchablePostFilterInput {
  id: SearchableIDFilterInput
  title: SearchableStringFilterInput
  createdAt: SearchableStringFilterInput
  updatedAt: SearchableStringFilterInput
  and: [SearchablePostFilterInput]
  or: [SearchablePostFilterInput]
  not: SearchablePostFilterInput
}

enum SearchableSortDirection {
  asc
  desc
}

enum SearchablePostSortableFields {
  id
  title
  createdAt
  updatedAt
}

input SearchablePostSortInput {
  field: SearchablePostSortableFields
  direction: SearchableSortDirection
}

enum SearchableAggregateType {
  terms
  avg
  min
  max
  sum
}

enum SearchablePostAggregateField {
  id
  title
  createdAt
  updatedAt
}

input SearchablePostAggregationInput {
  name: String!
  type: SearchableAggregateType!
  field: SearchablePostAggregateField!
}

"
`;
