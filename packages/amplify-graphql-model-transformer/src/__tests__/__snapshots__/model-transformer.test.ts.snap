// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`ModelTransformer:  should filter known input types from create and update input fields 1`] = `
"
type Test {
  id: ID!
  email: Email
  createdAt: AWSDateTime!
  updatedAt: AWSDateTime!
}

type Email {
  id: ID!
  createdAt: AWSDateTime!
  updatedAt: AWSDateTime!
}

input ModelStringInput {
  ne: String
  eq: String
  le: String
  lt: String
  ge: String
  gt: String
  contains: String
  notContains: String
  between: [String]
  beginsWith: String
  attributeExists: Boolean
  attributeType: ModelAttributeTypes
  size: ModelSizeInput
}

input ModelIntInput {
  ne: Int
  eq: Int
  le: Int
  lt: Int
  ge: Int
  gt: Int
  between: [Int]
  attributeExists: Boolean
  attributeType: ModelAttributeTypes
}

input ModelFloatInput {
  ne: Float
  eq: Float
  le: Float
  lt: Float
  ge: Float
  gt: Float
  between: [Float]
  attributeExists: Boolean
  attributeType: ModelAttributeTypes
}

input ModelBooleanInput {
  ne: Boolean
  eq: Boolean
  attributeExists: Boolean
  attributeType: ModelAttributeTypes
}

input ModelIDInput {
  ne: ID
  eq: ID
  le: ID
  lt: ID
  ge: ID
  gt: ID
  contains: ID
  notContains: ID
  between: [ID]
  beginsWith: ID
  attributeExists: Boolean
  attributeType: ModelAttributeTypes
  size: ModelSizeInput
}

enum ModelAttributeTypes {
  binary
  binarySet
  bool
  list
  map
  number
  numberSet
  string
  stringSet
  _null
}

input ModelSizeInput {
  ne: Int
  eq: Int
  le: Int
  lt: Int
  ge: Int
  gt: Int
  between: [Int]
}

enum ModelSortDirection {
  ASC
  DESC
}

type ModelTestConnection {
  items: [Test]!
  nextToken: String
}

input ModelTestFilterInput {
  id: ModelIDInput
  and: [ModelTestFilterInput]
  or: [ModelTestFilterInput]
  not: ModelTestFilterInput
}

type Query {
  getTest(id: ID!): Test
  listTests(filter: ModelTestFilterInput, limit: Int, nextToken: String): ModelTestConnection
  getEmail(id: ID!): Email
  listEmails(filter: ModelEmailFilterInput, limit: Int, nextToken: String): ModelEmailConnection
}

input ModelTestConditionInput {
  and: [ModelTestConditionInput]
  or: [ModelTestConditionInput]
  not: ModelTestConditionInput
}

input CreateTestInput {
  id: ID
}

input UpdateTestInput {
  id: ID!
}

input DeleteTestInput {
  id: ID!
}

type Mutation {
  createTest(input: CreateTestInput!, condition: ModelTestConditionInput): Test
  updateTest(input: UpdateTestInput!, condition: ModelTestConditionInput): Test
  deleteTest(input: DeleteTestInput!, condition: ModelTestConditionInput): Test
  createEmail(input: CreateEmailInput!, condition: ModelEmailConditionInput): Email
  updateEmail(input: UpdateEmailInput!, condition: ModelEmailConditionInput): Email
  deleteEmail(input: DeleteEmailInput!, condition: ModelEmailConditionInput): Email
}

type Subscription {
  onCreateTest: Test @aws_subscribe(mutations: [\\"createTest\\"])
  onUpdateTest: Test @aws_subscribe(mutations: [\\"updateTest\\"])
  onDeleteTest: Test @aws_subscribe(mutations: [\\"deleteTest\\"])
  onCreateEmail: Email @aws_subscribe(mutations: [\\"createEmail\\"])
  onUpdateEmail: Email @aws_subscribe(mutations: [\\"updateEmail\\"])
  onDeleteEmail: Email @aws_subscribe(mutations: [\\"deleteEmail\\"])
}

type ModelEmailConnection {
  items: [Email]!
  nextToken: String
}

input ModelEmailFilterInput {
  id: ModelIDInput
  and: [ModelEmailFilterInput]
  or: [ModelEmailFilterInput]
  not: ModelEmailFilterInput
}

input ModelEmailConditionInput {
  and: [ModelEmailConditionInput]
  or: [ModelEmailConditionInput]
  not: ModelEmailConditionInput
}

input CreateEmailInput {
  id: ID
}

input UpdateEmailInput {
  id: ID!
}

input DeleteEmailInput {
  id: ID!
}

"
`;

exports[`ModelTransformer:  should generate enum input objects 1`] = `
"
type Post {
  id: ID!
  title: String!
  createdAt: AWSDateTime
  updatedAt: AWSDateTime
  metadata: PostMetadata
  entityMetadata: EntityMetadata
  appearsIn: [Episode!]
  episode: Episode
}

type Author {
  id: ID!
  name: String!
  postMetadata: PostMetadata
  entityMetadata: EntityMetadata
  createdAt: AWSDateTime!
  updatedAt: AWSDateTime!
}

type EntityMetadata {
  isActive: Boolean
}

type PostMetadata {
  tags: Tag
}

type Tag {
  published: Boolean
  metadata: PostMetadata
}

enum Episode {
  NEWHOPE
  EMPIRE
  JEDI
}

type Require {
  id: ID!
  requiredField: String!
  notRequiredField: String
  createdAt: AWSDateTime!
  updatedAt: AWSDateTime!
}

type Comment {
  id: ID!
  title: String!
  content: String
  updatedOn: Int
  createdOn: AWSDateTime!
}

input ModelStringInput {
  ne: String
  eq: String
  le: String
  lt: String
  ge: String
  gt: String
  contains: String
  notContains: String
  between: [String]
  beginsWith: String
  attributeExists: Boolean
  attributeType: ModelAttributeTypes
  size: ModelSizeInput
}

input ModelIntInput {
  ne: Int
  eq: Int
  le: Int
  lt: Int
  ge: Int
  gt: Int
  between: [Int]
  attributeExists: Boolean
  attributeType: ModelAttributeTypes
}

input ModelFloatInput {
  ne: Float
  eq: Float
  le: Float
  lt: Float
  ge: Float
  gt: Float
  between: [Float]
  attributeExists: Boolean
  attributeType: ModelAttributeTypes
}

input ModelBooleanInput {
  ne: Boolean
  eq: Boolean
  attributeExists: Boolean
  attributeType: ModelAttributeTypes
}

input ModelIDInput {
  ne: ID
  eq: ID
  le: ID
  lt: ID
  ge: ID
  gt: ID
  contains: ID
  notContains: ID
  between: [ID]
  beginsWith: ID
  attributeExists: Boolean
  attributeType: ModelAttributeTypes
  size: ModelSizeInput
}

enum ModelAttributeTypes {
  binary
  binarySet
  bool
  list
  map
  number
  numberSet
  string
  stringSet
  _null
}

input ModelSizeInput {
  ne: Int
  eq: Int
  le: Int
  lt: Int
  ge: Int
  gt: Int
  between: [Int]
}

enum ModelSortDirection {
  ASC
  DESC
}

input PostMetadataInput {
  tags: TagInput
}

input TagInput {
  published: Boolean
  metadata: PostMetadataInput
}

input EntityMetadataInput {
  isActive: Boolean
}

type ModelPostConnection {
  items: [Post]!
  nextToken: String
}

input ModelEpisodeListInput {
  eq: [Episode]
  ne: [Episode]
  contains: Episode
  notContains: Episode
}

input ModelEpisodeInput {
  eq: Episode
  ne: Episode
}

input ModelPostFilterInput {
  id: ModelIDInput
  title: ModelStringInput
  createdAt: ModelStringInput
  updatedAt: ModelStringInput
  appearsIn: ModelEpisodeListInput
  episode: ModelEpisodeInput
  and: [ModelPostFilterInput]
  or: [ModelPostFilterInput]
  not: ModelPostFilterInput
}

type Query {
  getPost(id: ID!): Post
  listPosts(filter: ModelPostFilterInput, limit: Int, nextToken: String): ModelPostConnection
  getAuthor(id: ID!): Author
  listAuthors(filter: ModelAuthorFilterInput, limit: Int, nextToken: String): ModelAuthorConnection
  getRequire(id: ID!): Require
  listRequires(filter: ModelRequireFilterInput, limit: Int, nextToken: String): ModelRequireConnection
  getComment(id: ID!): Comment
  listComments(filter: ModelCommentFilterInput, limit: Int, nextToken: String): ModelCommentConnection
}

input ModelPostConditionInput {
  title: ModelStringInput
  createdAt: ModelStringInput
  updatedAt: ModelStringInput
  appearsIn: ModelEpisodeListInput
  episode: ModelEpisodeInput
  and: [ModelPostConditionInput]
  or: [ModelPostConditionInput]
  not: ModelPostConditionInput
}

input CreatePostInput {
  id: ID
  title: String!
  createdAt: AWSDateTime
  updatedAt: AWSDateTime
  metadata: PostMetadataInput
  entityMetadata: EntityMetadataInput
  appearsIn: [Episode!]
  episode: Episode
}

input UpdatePostInput {
  id: ID!
  title: String
  createdAt: AWSDateTime
  updatedAt: AWSDateTime
  metadata: PostMetadataInput
  entityMetadata: EntityMetadataInput
  appearsIn: [Episode!]
  episode: Episode
}

input DeletePostInput {
  id: ID!
}

type Mutation {
  createPost(input: CreatePostInput!, condition: ModelPostConditionInput): Post
  updatePost(input: UpdatePostInput!, condition: ModelPostConditionInput): Post
  deletePost(input: DeletePostInput!, condition: ModelPostConditionInput): Post
  createAuthor(input: CreateAuthorInput!, condition: ModelAuthorConditionInput): Author
  updateAuthor(input: UpdateAuthorInput!, condition: ModelAuthorConditionInput): Author
  deleteAuthor(input: DeleteAuthorInput!, condition: ModelAuthorConditionInput): Author
  createRequire(input: CreateRequireInput!, condition: ModelRequireConditionInput): Require
  updateRequire(input: UpdateRequireInput!, condition: ModelRequireConditionInput): Require
  deleteRequire(input: DeleteRequireInput!, condition: ModelRequireConditionInput): Require
  createComment(input: CreateCommentInput!, condition: ModelCommentConditionInput): Comment
  updateComment(input: UpdateCommentInput!, condition: ModelCommentConditionInput): Comment
  deleteComment(input: DeleteCommentInput!, condition: ModelCommentConditionInput): Comment
}

type Subscription {
  onCreatePost: Post @aws_subscribe(mutations: [\\"createPost\\"])
  onUpdatePost: Post @aws_subscribe(mutations: [\\"updatePost\\"])
  onDeletePost: Post @aws_subscribe(mutations: [\\"deletePost\\"])
  onCreateAuthor: Author @aws_subscribe(mutations: [\\"createAuthor\\"])
  onUpdateAuthor: Author @aws_subscribe(mutations: [\\"updateAuthor\\"])
  onDeleteAuthor: Author @aws_subscribe(mutations: [\\"deleteAuthor\\"])
  onCreateRequire: Require @aws_subscribe(mutations: [\\"createRequire\\"])
  onUpdateRequire: Require @aws_subscribe(mutations: [\\"updateRequire\\"])
  onDeleteRequire: Require @aws_subscribe(mutations: [\\"deleteRequire\\"])
  onCreateComment: Comment @aws_subscribe(mutations: [\\"createComment\\"])
  onUpdateComment: Comment @aws_subscribe(mutations: [\\"updateComment\\"])
  onDeleteComment: Comment @aws_subscribe(mutations: [\\"deleteComment\\"])
}

type ModelAuthorConnection {
  items: [Author]!
  nextToken: String
}

input ModelAuthorFilterInput {
  id: ModelIDInput
  name: ModelStringInput
  and: [ModelAuthorFilterInput]
  or: [ModelAuthorFilterInput]
  not: ModelAuthorFilterInput
}

input ModelAuthorConditionInput {
  name: ModelStringInput
  and: [ModelAuthorConditionInput]
  or: [ModelAuthorConditionInput]
  not: ModelAuthorConditionInput
}

input CreateAuthorInput {
  id: ID
  name: String!
  postMetadata: PostMetadataInput
  entityMetadata: EntityMetadataInput
}

input UpdateAuthorInput {
  id: ID!
  name: String
  postMetadata: PostMetadataInput
  entityMetadata: EntityMetadataInput
}

input DeleteAuthorInput {
  id: ID!
}

type ModelRequireConnection {
  items: [Require]!
  nextToken: String
}

input ModelRequireFilterInput {
  id: ModelIDInput
  requiredField: ModelStringInput
  notRequiredField: ModelStringInput
  and: [ModelRequireFilterInput]
  or: [ModelRequireFilterInput]
  not: ModelRequireFilterInput
}

input ModelRequireConditionInput {
  requiredField: ModelStringInput
  notRequiredField: ModelStringInput
  and: [ModelRequireConditionInput]
  or: [ModelRequireConditionInput]
  not: ModelRequireConditionInput
}

input CreateRequireInput {
  id: ID
  requiredField: String!
  notRequiredField: String
}

input UpdateRequireInput {
  id: ID!
  requiredField: String
  notRequiredField: String
}

input DeleteRequireInput {
  id: ID!
}

type ModelCommentConnection {
  items: [Comment]!
  nextToken: String
}

input ModelCommentFilterInput {
  id: ModelIDInput
  title: ModelStringInput
  content: ModelStringInput
  updatedOn: ModelIntInput
  and: [ModelCommentFilterInput]
  or: [ModelCommentFilterInput]
  not: ModelCommentFilterInput
}

input ModelCommentConditionInput {
  title: ModelStringInput
  content: ModelStringInput
  updatedOn: ModelIntInput
  and: [ModelCommentConditionInput]
  or: [ModelCommentConditionInput]
  not: ModelCommentConditionInput
}

input CreateCommentInput {
  id: ID
  title: String!
  content: String
  updatedOn: Int
}

input UpdateCommentInput {
  id: ID!
  title: String
  content: String
  updatedOn: Int
}

input DeleteCommentInput {
  id: ID!
}

"
`;

exports[`ModelTransformer:  should generate sync resolver with ConflictHandlerType.Automerge 1`] = `
Object {
  "Mutation.createPost.init.1.req.vtl": "## [Start] Initialization default values. **
$util.qr($ctx.stash.put(\\"defaultValues\\", $util.defaultIfNull($ctx.stash.defaultValues, {})))
#set( $createdAt = $util.time.nowISO8601() )
$util.qr($ctx.stash.defaultValues.put(\\"id\\", $util.autoId()))
$util.qr($ctx.stash.defaultValues.put(\\"createdAt\\", $createdAt))
$util.qr($ctx.stash.defaultValues.put(\\"updatedAt\\", $createdAt))
$util.toJson({
  \\"version\\": \\"2018-05-29\\",
  \\"payload\\": {}
})
## [End] Initialization default values. **",
  "Mutation.createPost.postAuth.1.req.vtl": "## [Start] Sandbox Mode Disabled. **
#if( !$ctx.stash.get(\\"hasAuth\\") )
  $util.unauthorized()
#end
$util.toJson({})
## [End] Sandbox Mode Disabled. **",
  "Mutation.createPost.req.vtl": "## [Start] Create Request template. **
#set( $args = $util.defaultIfNull($ctx.stash.transformedArgs, $ctx.args) )
## Set the default values to put request **
#set( $mergedValues = $util.defaultIfNull($ctx.stash.defaultValues, {}) )
## copy the values from input **
$util.qr($mergedValues.putAll($util.defaultIfNull($args.input, {})))
## set the typename **
$util.qr($mergedValues.put(\\"__typename\\", \\"Post\\"))
#set( $PutObject = {
  \\"version\\": \\"2018-05-29\\",
  \\"operation\\": \\"PutItem\\",
  \\"attributeValues\\":   $util.dynamodb.toMapValues($mergedValues),
  \\"condition\\": $condition
} )
#if( $args.condition )
  $util.qr($ctx.stash.conditions.add($args.condition))
#end
## Begin - key condition **
#if( $ctx.stash.metadata.modelObjectKey )
  #set( $keyConditionExpr = {} )
  #set( $keyConditionExprNames = {} )
  #foreach( $entry in $ctx.stash.metadata.modelObjectKey.entrySet() )
    $util.qr($keyConditionExpr.put(\\"keyCondition$velocityCount\\", {
  \\"attributeExists\\": false
}))
    $util.qr($keyConditionExprNames.put(\\"#keyCondition$velocityCount\\", \\"$entry.key\\"))
  #end
  $util.qr($ctx.stash.conditions.add($keyConditionExpr))
#else
  $util.qr($ctx.stash.conditions.add({
  \\"id\\": {
      \\"attributeExists\\": false
  }
}))
#end
## End - key condition **
## Start condition block **
#if( $ctx.stash.conditions && $ctx.stash.conditions.size() != 0 )
  #set( $mergedConditions = {
  \\"and\\": $ctx.stash.conditions
} )
  #set( $Conditions = $util.parseJson($util.transform.toDynamoDBConditionExpression($mergedConditions)) )
  #if( $Conditions.expressionValues && $Conditions.expressionValues.size() == 0 )
    #set( $Conditions = {
  \\"expression\\": $Conditions.expression,
  \\"expressionNames\\": $Conditions.expressionNames
} )
  #end
  ## End condition block **
#end
#if( $Conditions )
  #if( $keyConditionExprNames )
    $util.qr($Conditions.expressionNames.putAll($keyConditionExprNames))
  #end
  $util.qr($PutObject.put(\\"condition\\", $Conditions))
#end
#if( $ctx.stash.metadata.modelObjectKey )
  $util.qr($PutObject.put(\\"key\\", $ctx.stash.metadata.modelObjectKey))
#else
  #set( $Key = {
  \\"id\\":   $util.dynamodb.toDynamoDB($mergedValues.id)
} )
  $util.qr($PutObject.put(\\"key\\", $Key))
#end
$util.toJson($PutObject)
## [End] Create Request template. **",
  "Mutation.createPost.res.vtl": "## [Start] ResponseTemplate. **
$util.qr($ctx.result.put(\\"__operation\\", \\"Mutation\\"))
#if( $ctx.error )
  $util.error($ctx.error.message, $ctx.error.type, $ctx.result)
#else
  $util.toJson($ctx.result)
#end
## [End] ResponseTemplate. **",
  "Mutation.deletePost.postAuth.1.req.vtl": "## [Start] Sandbox Mode Disabled. **
#if( !$ctx.stash.get(\\"hasAuth\\") )
  $util.unauthorized()
#end
$util.toJson({})
## [End] Sandbox Mode Disabled. **",
  "Mutation.deletePost.req.vtl": "## [Start] Delete Request template. **
#set( $args = $util.defaultIfNull($ctx.stash.transformedArgs, $ctx.args) )
#set( $DeleteRequest = {
  \\"version\\": \\"2018-05-29\\",
  \\"operation\\": \\"DeleteItem\\"
} )
#if( $ctx.stash.metadata.modelObjectKey )
  #set( $Key = $ctx.stash.metadata.modelObjectKey )
#else
  #set( $Key = {
  \\"id\\":   $util.dynamodb.toDynamoDB($args.input.id)
} )
#end
$util.qr($DeleteRequest.put(\\"key\\", $Key))
## Begin - key condition **
#if( $ctx.stash.metadata.modelObjectKey )
  #set( $keyConditionExpr = {} )
  #set( $keyConditionExprNames = {} )
  #foreach( $entry in $ctx.stash.metadata.modelObjectKey.entrySet() )
    $util.qr($keyConditionExpr.put(\\"keyCondition$velocityCount\\", {
  \\"attributeExists\\": true
}))
    $util.qr($keyConditionExprNames.put(\\"#keyCondition$velocityCount\\", \\"$entry.key\\"))
  #end
  $util.qr($ctx.stash.conditions.add($keyConditionExpr))
#else
  $util.qr($ctx.stash.conditions.add({
  \\"id\\": {
      \\"attributeExists\\": true
  }
}))
#end
## End - key condition **
#if( $args.condition )
  $util.qr($ctx.stash.conditions.add($args.condition))
#end
## Start condition block **
#if( $ctx.stash.conditions && $ctx.stash.conditions.size() != 0 )
  #set( $mergedConditions = {
  \\"and\\": $ctx.stash.conditions
} )
  #set( $Conditions = $util.parseJson($util.transform.toDynamoDBConditionExpression($mergedConditions)) )
  #if( $Conditions.expressionValues && $Conditions.expressionValues.size() == 0 )
    #set( $Conditions = {
  \\"expression\\": $Conditions.expression,
  \\"expressionNames\\": $Conditions.expressionNames
} )
  #end
  ## End condition block **
#end
#if( $Conditions )
  #if( $keyConditionExprNames )
    $util.qr($Conditions.expressionNames.putAll($keyConditionExprNames))
  #end
  $util.qr($DeleteRequest.put(\\"condition\\", $Conditions))
#end
$util.qr($DeleteRequest.put(\\"_version\\", $util.defaultIfNull($args.input[\\"_version\\"], 0)))
$util.toJson($DeleteRequest)
## [End] Delete Request template. **",
  "Mutation.deletePost.res.vtl": "## [Start] ResponseTemplate. **
$util.qr($ctx.result.put(\\"__operation\\", \\"Mutation\\"))
#if( $ctx.error )
  $util.error($ctx.error.message, $ctx.error.type, $ctx.result)
#else
  $util.toJson($ctx.result)
#end
## [End] ResponseTemplate. **",
  "Mutation.updatePost.init.1.req.vtl": "## [Start] Initialization default values. **
$util.qr($ctx.stash.put(\\"defaultValues\\", $util.defaultIfNull($ctx.stash.defaultValues, {})))
#set( $updatedAt = $util.time.nowISO8601() )
$util.qr($ctx.stash.defaultValues.put(\\"updatedAt\\", $updatedAt))
$util.toJson({
  \\"version\\": \\"2018-05-29\\",
  \\"payload\\": {}
})
## [End] Initialization default values. **",
  "Mutation.updatePost.postAuth.1.req.vtl": "## [Start] Sandbox Mode Disabled. **
#if( !$ctx.stash.get(\\"hasAuth\\") )
  $util.unauthorized()
#end
$util.toJson({})
## [End] Sandbox Mode Disabled. **",
  "Mutation.updatePost.req.vtl": "## [Start] Mutation Update resolver. **
#set( $args = $util.defaultIfNull($ctx.stash.transformedArgs, $ctx.args) )
## Set the default values to put request **
#set( $mergedValues = $util.defaultIfNull($ctx.stash.defaultValues, {}) )
## copy the values from input **
$util.qr($mergedValues.putAll($util.defaultIfNull($args.input, {})))
## set the typename **
## Initialize the vars for creating ddb expression **
#set( $expNames = {} )
#set( $expValues = {} )
#set( $expSet = {} )
#set( $expAdd = {} )
#set( $expRemove = [] )
#if( $ctx.stash.metadata.modelObjectKey )
  #set( $Key = $ctx.stash.metadata.modelObjectKey )
#else
  #set( $Key = {
  \\"id\\":   $util.dynamodb.toDynamoDB($args.input.id)
} )
#end
## Model key **
#if( $ctx.stash.metadata.modelObjectKey )
  #set( $keyFields = [\\"_version\\", \\"_deleted\\", \\"_lastChangedAt\\"] )
  #foreach( $entry in $ctx.stash.metadata.modelObjectKey.entrySet() )
    $util.qr($keyFields.add(\\"$entry.key\\"))
  #end
#else
  #set( $keyFields = [\\"id\\", \\"_version\\", \\"_deleted\\", \\"_lastChangedAt\\"] )
#end
#foreach( $entry in $util.map.copyAndRemoveAllKeys($mergedValues, $keyFields).entrySet() )
  #if( !$util.isNull($ctx.stash.metadata.dynamodbNameOverrideMap) && $ctx.stash.metadata.dynamodbNameOverrideMap.containsKey(\\"$entry.key\\") )
    #set( $entryKeyAttributeName = $ctx.stash.metadata.dynamodbNameOverrideMap.get(\\"$entry.key\\") )
  #else
    #set( $entryKeyAttributeName = $entry.key )
  #end
  #if( $util.isNull($entry.value) )
    #set( $discard = $expRemove.add(\\"#$entryKeyAttributeName\\") )
    $util.qr($expNames.put(\\"#$entryKeyAttributeName\\", \\"$entry.key\\"))
  #else
    $util.qr($expSet.put(\\"#$entryKeyAttributeName\\", \\":$entryKeyAttributeName\\"))
    $util.qr($expNames.put(\\"#$entryKeyAttributeName\\", \\"$entry.key\\"))
    $util.qr($expValues.put(\\":$entryKeyAttributeName\\", $util.dynamodb.toDynamoDB($entry.value)))
  #end
#end
#set( $expression = \\"\\" )
#if( !$expSet.isEmpty() )
  #set( $expression = \\"SET\\" )
  #foreach( $entry in $expSet.entrySet() )
    #set( $expression = \\"$expression $entry.key = $entry.value\\" )
    #if( $foreach.hasNext() )
      #set( $expression = \\"$expression,\\" )
    #end
  #end
#end
#if( !$expAdd.isEmpty() )
  #set( $expression = \\"$expression ADD\\" )
  #foreach( $entry in $expAdd.entrySet() )
    #set( $expression = \\"$expression $entry.key $entry.value\\" )
    #if( $foreach.hasNext() )
      #set( $expression = \\"$expression,\\" )
    #end
  #end
#end
#if( !$expRemove.isEmpty() )
  #set( $expression = \\"$expression REMOVE\\" )
  #foreach( $entry in $expRemove )
    #set( $expression = \\"$expression $entry\\" )
    #if( $foreach.hasNext() )
      #set( $expression = \\"$expression,\\" )
    #end
  #end
#end
#set( $update = {} )
$util.qr($update.put(\\"expression\\", \\"$expression\\"))
#if( !$expNames.isEmpty() )
  $util.qr($update.put(\\"expressionNames\\", $expNames))
#end
#if( !$expValues.isEmpty() )
  $util.qr($update.put(\\"expressionValues\\", $expValues))
#end
## Begin - key condition **
#if( $ctx.stash.metadata.modelObjectKey )
  #set( $keyConditionExpr = {} )
  #set( $keyConditionExprNames = {} )
  #foreach( $entry in $ctx.stash.metadata.modelObjectKey.entrySet() )
    $util.qr($keyConditionExpr.put(\\"keyCondition$velocityCount\\", {
  \\"attributeExists\\": true
}))
    $util.qr($keyConditionExprNames.put(\\"#keyCondition$velocityCount\\", \\"$entry.key\\"))
  #end
  $util.qr($ctx.stash.conditions.add($keyConditionExpr))
#else
  $util.qr($ctx.stash.conditions.add({
  \\"id\\": {
      \\"attributeExists\\": true
  }
}))
#end
## End - key condition **
#if( $args.condition )
  $util.qr($ctx.stash.conditions.add($args.condition))
#end
## Start condition block **
#if( $ctx.stash.conditions && $ctx.stash.conditions.size() != 0 )
  #set( $mergedConditions = {
  \\"and\\": $ctx.stash.conditions
} )
  #set( $Conditions = $util.parseJson($util.transform.toDynamoDBConditionExpression($mergedConditions)) )
  #if( $Conditions.expressionValues && $Conditions.expressionValues.size() == 0 )
    #set( $Conditions = {
  \\"expression\\": $Conditions.expression,
  \\"expressionNames\\": $Conditions.expressionNames
} )
  #end
  ## End condition block **
#end
#set( $UpdateItem = {
  \\"version\\": \\"2018-05-29\\",
  \\"operation\\": \\"UpdateItem\\",
  \\"key\\": $Key,
  \\"update\\": $update,
  \\"_version\\": $util.defaultIfNull($args.input[\\"_version\\"], 0)
} )
#if( $Conditions )
  #if( $keyConditionExprNames )
    $util.qr($Conditions.expressionNames.putAll($keyConditionExprNames))
  #end
  $util.qr($UpdateItem.put(\\"condition\\", $Conditions))
#end
$util.toJson($UpdateItem)
## [End] Mutation Update resolver. **",
  "Mutation.updatePost.res.vtl": "## [Start] ResponseTemplate. **
$util.qr($ctx.result.put(\\"__operation\\", \\"Mutation\\"))
#if( $ctx.error )
  $util.error($ctx.error.message, $ctx.error.type, $ctx.result)
#else
  $util.toJson($ctx.result)
#end
## [End] ResponseTemplate. **",
  "Query.getPost.postAuth.1.req.vtl": "## [Start] Sandbox Mode Disabled. **
#if( !$ctx.stash.get(\\"hasAuth\\") )
  $util.unauthorized()
#end
$util.toJson({})
## [End] Sandbox Mode Disabled. **",
  "Query.getPost.req.vtl": "## [Start] Get Request template. **
#set( $GetRequest = {
  \\"version\\": \\"2018-05-29\\",
  \\"operation\\": \\"Query\\"
} )
#if( $ctx.stash.metadata.modelObjectKey )
  #set( $expression = \\"\\" )
  #set( $expressionNames = {} )
  #set( $expressionValues = {} )
  #foreach( $item in $ctx.stash.metadata.modelObjectKey.entrySet() )
    #set( $expression = \\"$expression#keyCount$velocityCount = :valueCount$velocityCount AND \\" )
    $util.qr($expressionNames.put(\\"#keyCount$velocityCount\\", $item.key))
    $util.qr($expressionValues.put(\\":valueCount$velocityCount\\", $item.value))
  #end
  #set( $expression = $expression.replaceAll(\\"AND $\\", \\"\\") )
  #set( $query = {
  \\"expression\\": $expression,
  \\"expressionNames\\": $expressionNames,
  \\"expressionValues\\": $expressionValues
} )
#else
  #set( $query = {
  \\"expression\\": \\"id = :id\\",
  \\"expressionValues\\": {
      \\":id\\":     $util.parseJson($util.dynamodb.toDynamoDBJson($ctx.args.id))
  }
} )
#end
$util.qr($GetRequest.put(\\"query\\", $query))
#if( !$util.isNullOrEmpty($ctx.stash.authFilter) )
  $util.qr($GetRequest.put(\\"filter\\", $util.parseJson($util.transform.toDynamoDBFilterExpression($ctx.stash.authFilter))))
#end
$util.toJson($GetRequest)
## [End] Get Request template. **",
  "Query.getPost.res.vtl": "## [Start] Get Response template. **
#if( $ctx.error )
  $util.error($ctx.error.message, $ctx.error.type, $ctx.result)
#end
#if( !$ctx.result.items.isEmpty() && $ctx.result.scannedCount == 1 )
  $util.toJson($ctx.result.items[0])
#else
  #if( $ctx.result.items.isEmpty() && $ctx.result.scannedCount == 1 )
$util.unauthorized()
  #end
  $util.toJson(null)
#end
## [End] Get Response template. **",
  "Query.listPosts.postAuth.1.req.vtl": "## [Start] Sandbox Mode Disabled. **
#if( !$ctx.stash.get(\\"hasAuth\\") )
  $util.unauthorized()
#end
$util.toJson({})
## [End] Sandbox Mode Disabled. **",
  "Query.listPosts.req.vtl": "## [Start] List Request. **
#set( $args = $util.defaultIfNull($ctx.stash.transformedArgs, $ctx.args) )
#set( $limit = $util.defaultIfNull($args.limit, 100) )
#set( $ListRequest = {
  \\"version\\": \\"2018-05-29\\",
  \\"limit\\": $limit
} )
#if( $args.nextToken )
  #set( $ListRequest.nextToken = $args.nextToken )
#end
#if( !$util.isNullOrEmpty($ctx.stash.authFilter) )
  #set( $filter = $ctx.stash.authFilter )
  #if( !$util.isNullOrEmpty($args.filter) )
    #set( $filter = {
  \\"and\\":   [$filter, $args.filter]
} )
  #end
#else
  #if( !$util.isNullOrEmpty($args.filter) )
    #set( $filter = $args.filter )
  #end
#end
#if( !$util.isNullOrEmpty($filter) )
  #set( $filterExpression = $util.parseJson($util.transform.toDynamoDBFilterExpression($filter)) )
  #if( !$util.isNullOrBlank($filterExpression.expression) )
    #if( $filterExpression.expressionValues.size() == 0 )
      $util.qr($filterExpression.remove(\\"expressionValues\\"))
    #end
    #set( $ListRequest.filter = $filterExpression )
  #end
#end
#if( !$util.isNull($ctx.stash.modelQueryExpression) && !$util.isNullOrEmpty($ctx.stash.modelQueryExpression.expression) )
  $util.qr($ListRequest.put(\\"operation\\", \\"Query\\"))
  $util.qr($ListRequest.put(\\"query\\", $ctx.stash.modelQueryExpression))
  #if( !$util.isNull($args.sortDirection) && $args.sortDirection == \\"DESC\\" )
    #set( $ListRequest.scanIndexForward = false )
  #else
    #set( $ListRequest.scanIndexForward = true )
  #end
#else
  $util.qr($ListRequest.put(\\"operation\\", \\"Scan\\"))
#end
#if( !$util.isNull($ctx.stash.metadata.index) )
  #set( $ListRequest.IndexName = $ctx.stash.metadata.index )
#end
$util.toJson($ListRequest)
## [End] List Request. **",
  "Query.listPosts.res.vtl": "## [Start] ResponseTemplate. **
#if( $ctx.error )
  $util.error($ctx.error.message, $ctx.error.type, $ctx.result)
#else
  $util.toJson($ctx.result)
#end
## [End] ResponseTemplate. **",
  "Query.syncPosts.postAuth.1.req.vtl": "## [Start] Sandbox Mode Disabled. **
#if( !$ctx.stash.get(\\"hasAuth\\") )
  $util.unauthorized()
#end
$util.toJson({})
## [End] Sandbox Mode Disabled. **",
  "Query.syncPosts.req.vtl": "## [Start] Sync Request template. **
#set( $args = $util.defaultIfNull($ctx.stash.transformedArgs, $ctx.args) )
#if( !$util.isNullOrEmpty($ctx.stash.authFilter) )
  #set( $filter = $ctx.stash.authFilter )
  #if( !$util.isNullOrEmpty($args.filter) )
    #set( $filter = {
  \\"and\\":   [$filter, $args.filter]
} )
  #end
#else
  #if( !$util.isNullOrEmpty($args.filter) )
    #set( $filter = $args.filter )
  #end
#end
#if( !$util.isNullOrEmpty($filter) )
  #set( $filterExpression = $util.parseJson($util.transform.toDynamoDBFilterExpression($filter)) )
  #if( !$util.isNullOrBlank($filterExpression.expression) )
    #if( $filterExpression.expressionValues.size() == 0 )
      $util.qr($filterExpression.remove(\\"expressionValues\\"))
    #end
    #set( $filter = $filterExpression )
  #end
#end
{
  \\"version\\": \\"2018-05-29\\",
  \\"operation\\": \\"Sync\\",
  \\"filter\\":   #if( $filter )
$util.toJson($filter)
  #else
null
  #end,
  \\"limit\\": $util.defaultIfNull($args.limit, 100),
  \\"lastSync\\": $util.toJson($util.defaultIfNull($args.lastSync, null)),
  \\"nextToken\\": $util.toJson($util.defaultIfNull($args.nextToken, null))
}
## [End] Sync Request template. **",
  "Query.syncPosts.res.vtl": "## [Start] ResponseTemplate. **
#if( $ctx.error )
  $util.error($ctx.error.message, $ctx.error.type, $ctx.result)
#else
  $util.toJson($ctx.result)
#end
## [End] ResponseTemplate. **",
  "Subscription.onCreatePost.postAuth.1.req.vtl": "## [Start] Sandbox Mode Disabled. **
#if( !$ctx.stash.get(\\"hasAuth\\") )
  $util.unauthorized()
#end
$util.toJson({})
## [End] Sandbox Mode Disabled. **",
  "Subscription.onCreatePost.req.vtl": "## [Start] Subscription Request template. **
$util.toJson({
  \\"version\\": \\"2018-05-29\\",
  \\"payload\\": {}
})
## [End] Subscription Request template. **",
  "Subscription.onCreatePost.res.vtl": "## [Start] Subscription Response template. **
$util.toJson(null)
## [End] Subscription Response template. **",
  "Subscription.onDeletePost.postAuth.1.req.vtl": "## [Start] Sandbox Mode Disabled. **
#if( !$ctx.stash.get(\\"hasAuth\\") )
  $util.unauthorized()
#end
$util.toJson({})
## [End] Sandbox Mode Disabled. **",
  "Subscription.onDeletePost.req.vtl": "## [Start] Subscription Request template. **
$util.toJson({
  \\"version\\": \\"2018-05-29\\",
  \\"payload\\": {}
})
## [End] Subscription Request template. **",
  "Subscription.onDeletePost.res.vtl": "## [Start] Subscription Response template. **
$util.toJson(null)
## [End] Subscription Response template. **",
  "Subscription.onUpdatePost.postAuth.1.req.vtl": "## [Start] Sandbox Mode Disabled. **
#if( !$ctx.stash.get(\\"hasAuth\\") )
  $util.unauthorized()
#end
$util.toJson({})
## [End] Sandbox Mode Disabled. **",
  "Subscription.onUpdatePost.req.vtl": "## [Start] Subscription Request template. **
$util.toJson({
  \\"version\\": \\"2018-05-29\\",
  \\"payload\\": {}
})
## [End] Subscription Request template. **",
  "Subscription.onUpdatePost.res.vtl": "## [Start] Subscription Response template. **
$util.toJson(null)
## [End] Subscription Response template. **",
}
`;

exports[`ModelTransformer:  should generate sync resolver with ConflictHandlerType.LAMBDA 1`] = `
Object {
  "Mutation.createPost.init.1.req.vtl": "## [Start] Initialization default values. **
$util.qr($ctx.stash.put(\\"defaultValues\\", $util.defaultIfNull($ctx.stash.defaultValues, {})))
#set( $createdAt = $util.time.nowISO8601() )
$util.qr($ctx.stash.defaultValues.put(\\"id\\", $util.autoId()))
$util.qr($ctx.stash.defaultValues.put(\\"createdAt\\", $createdAt))
$util.qr($ctx.stash.defaultValues.put(\\"updatedAt\\", $createdAt))
$util.toJson({
  \\"version\\": \\"2018-05-29\\",
  \\"payload\\": {}
})
## [End] Initialization default values. **",
  "Mutation.createPost.postAuth.1.req.vtl": "## [Start] Sandbox Mode Disabled. **
#if( !$ctx.stash.get(\\"hasAuth\\") )
  $util.unauthorized()
#end
$util.toJson({})
## [End] Sandbox Mode Disabled. **",
  "Mutation.createPost.req.vtl": "## [Start] Create Request template. **
#set( $args = $util.defaultIfNull($ctx.stash.transformedArgs, $ctx.args) )
## Set the default values to put request **
#set( $mergedValues = $util.defaultIfNull($ctx.stash.defaultValues, {}) )
## copy the values from input **
$util.qr($mergedValues.putAll($util.defaultIfNull($args.input, {})))
## set the typename **
$util.qr($mergedValues.put(\\"__typename\\", \\"Post\\"))
#set( $PutObject = {
  \\"version\\": \\"2018-05-29\\",
  \\"operation\\": \\"PutItem\\",
  \\"attributeValues\\":   $util.dynamodb.toMapValues($mergedValues),
  \\"condition\\": $condition
} )
#if( $args.condition )
  $util.qr($ctx.stash.conditions.add($args.condition))
#end
## Begin - key condition **
#if( $ctx.stash.metadata.modelObjectKey )
  #set( $keyConditionExpr = {} )
  #set( $keyConditionExprNames = {} )
  #foreach( $entry in $ctx.stash.metadata.modelObjectKey.entrySet() )
    $util.qr($keyConditionExpr.put(\\"keyCondition$velocityCount\\", {
  \\"attributeExists\\": false
}))
    $util.qr($keyConditionExprNames.put(\\"#keyCondition$velocityCount\\", \\"$entry.key\\"))
  #end
  $util.qr($ctx.stash.conditions.add($keyConditionExpr))
#else
  $util.qr($ctx.stash.conditions.add({
  \\"id\\": {
      \\"attributeExists\\": false
  }
}))
#end
## End - key condition **
## Start condition block **
#if( $ctx.stash.conditions && $ctx.stash.conditions.size() != 0 )
  #set( $mergedConditions = {
  \\"and\\": $ctx.stash.conditions
} )
  #set( $Conditions = $util.parseJson($util.transform.toDynamoDBConditionExpression($mergedConditions)) )
  #if( $Conditions.expressionValues && $Conditions.expressionValues.size() == 0 )
    #set( $Conditions = {
  \\"expression\\": $Conditions.expression,
  \\"expressionNames\\": $Conditions.expressionNames
} )
  #end
  ## End condition block **
#end
#if( $Conditions )
  #if( $keyConditionExprNames )
    $util.qr($Conditions.expressionNames.putAll($keyConditionExprNames))
  #end
  $util.qr($PutObject.put(\\"condition\\", $Conditions))
#end
#if( $ctx.stash.metadata.modelObjectKey )
  $util.qr($PutObject.put(\\"key\\", $ctx.stash.metadata.modelObjectKey))
#else
  #set( $Key = {
  \\"id\\":   $util.dynamodb.toDynamoDB($mergedValues.id)
} )
  $util.qr($PutObject.put(\\"key\\", $Key))
#end
$util.toJson($PutObject)
## [End] Create Request template. **",
  "Mutation.createPost.res.vtl": "## [Start] ResponseTemplate. **
$util.qr($ctx.result.put(\\"__operation\\", \\"Mutation\\"))
#if( $ctx.error )
  $util.error($ctx.error.message, $ctx.error.type, $ctx.result)
#else
  $util.toJson($ctx.result)
#end
## [End] ResponseTemplate. **",
  "Mutation.deletePost.postAuth.1.req.vtl": "## [Start] Sandbox Mode Disabled. **
#if( !$ctx.stash.get(\\"hasAuth\\") )
  $util.unauthorized()
#end
$util.toJson({})
## [End] Sandbox Mode Disabled. **",
  "Mutation.deletePost.req.vtl": "## [Start] Delete Request template. **
#set( $args = $util.defaultIfNull($ctx.stash.transformedArgs, $ctx.args) )
#set( $DeleteRequest = {
  \\"version\\": \\"2018-05-29\\",
  \\"operation\\": \\"DeleteItem\\"
} )
#if( $ctx.stash.metadata.modelObjectKey )
  #set( $Key = $ctx.stash.metadata.modelObjectKey )
#else
  #set( $Key = {
  \\"id\\":   $util.dynamodb.toDynamoDB($args.input.id)
} )
#end
$util.qr($DeleteRequest.put(\\"key\\", $Key))
## Begin - key condition **
#if( $ctx.stash.metadata.modelObjectKey )
  #set( $keyConditionExpr = {} )
  #set( $keyConditionExprNames = {} )
  #foreach( $entry in $ctx.stash.metadata.modelObjectKey.entrySet() )
    $util.qr($keyConditionExpr.put(\\"keyCondition$velocityCount\\", {
  \\"attributeExists\\": true
}))
    $util.qr($keyConditionExprNames.put(\\"#keyCondition$velocityCount\\", \\"$entry.key\\"))
  #end
  $util.qr($ctx.stash.conditions.add($keyConditionExpr))
#else
  $util.qr($ctx.stash.conditions.add({
  \\"id\\": {
      \\"attributeExists\\": true
  }
}))
#end
## End - key condition **
#if( $args.condition )
  $util.qr($ctx.stash.conditions.add($args.condition))
#end
## Start condition block **
#if( $ctx.stash.conditions && $ctx.stash.conditions.size() != 0 )
  #set( $mergedConditions = {
  \\"and\\": $ctx.stash.conditions
} )
  #set( $Conditions = $util.parseJson($util.transform.toDynamoDBConditionExpression($mergedConditions)) )
  #if( $Conditions.expressionValues && $Conditions.expressionValues.size() == 0 )
    #set( $Conditions = {
  \\"expression\\": $Conditions.expression,
  \\"expressionNames\\": $Conditions.expressionNames
} )
  #end
  ## End condition block **
#end
#if( $Conditions )
  #if( $keyConditionExprNames )
    $util.qr($Conditions.expressionNames.putAll($keyConditionExprNames))
  #end
  $util.qr($DeleteRequest.put(\\"condition\\", $Conditions))
#end
$util.qr($DeleteRequest.put(\\"_version\\", $util.defaultIfNull($args.input[\\"_version\\"], 0)))
$util.toJson($DeleteRequest)
## [End] Delete Request template. **",
  "Mutation.deletePost.res.vtl": "## [Start] ResponseTemplate. **
$util.qr($ctx.result.put(\\"__operation\\", \\"Mutation\\"))
#if( $ctx.error )
  $util.error($ctx.error.message, $ctx.error.type, $ctx.result)
#else
  $util.toJson($ctx.result)
#end
## [End] ResponseTemplate. **",
  "Mutation.updatePost.init.1.req.vtl": "## [Start] Initialization default values. **
$util.qr($ctx.stash.put(\\"defaultValues\\", $util.defaultIfNull($ctx.stash.defaultValues, {})))
#set( $updatedAt = $util.time.nowISO8601() )
$util.qr($ctx.stash.defaultValues.put(\\"updatedAt\\", $updatedAt))
$util.toJson({
  \\"version\\": \\"2018-05-29\\",
  \\"payload\\": {}
})
## [End] Initialization default values. **",
  "Mutation.updatePost.postAuth.1.req.vtl": "## [Start] Sandbox Mode Disabled. **
#if( !$ctx.stash.get(\\"hasAuth\\") )
  $util.unauthorized()
#end
$util.toJson({})
## [End] Sandbox Mode Disabled. **",
  "Mutation.updatePost.req.vtl": "## [Start] Mutation Update resolver. **
#set( $args = $util.defaultIfNull($ctx.stash.transformedArgs, $ctx.args) )
## Set the default values to put request **
#set( $mergedValues = $util.defaultIfNull($ctx.stash.defaultValues, {}) )
## copy the values from input **
$util.qr($mergedValues.putAll($util.defaultIfNull($args.input, {})))
## set the typename **
## Initialize the vars for creating ddb expression **
#set( $expNames = {} )
#set( $expValues = {} )
#set( $expSet = {} )
#set( $expAdd = {} )
#set( $expRemove = [] )
#if( $ctx.stash.metadata.modelObjectKey )
  #set( $Key = $ctx.stash.metadata.modelObjectKey )
#else
  #set( $Key = {
  \\"id\\":   $util.dynamodb.toDynamoDB($args.input.id)
} )
#end
## Model key **
#if( $ctx.stash.metadata.modelObjectKey )
  #set( $keyFields = [\\"_version\\", \\"_deleted\\", \\"_lastChangedAt\\"] )
  #foreach( $entry in $ctx.stash.metadata.modelObjectKey.entrySet() )
    $util.qr($keyFields.add(\\"$entry.key\\"))
  #end
#else
  #set( $keyFields = [\\"id\\", \\"_version\\", \\"_deleted\\", \\"_lastChangedAt\\"] )
#end
#foreach( $entry in $util.map.copyAndRemoveAllKeys($mergedValues, $keyFields).entrySet() )
  #if( !$util.isNull($ctx.stash.metadata.dynamodbNameOverrideMap) && $ctx.stash.metadata.dynamodbNameOverrideMap.containsKey(\\"$entry.key\\") )
    #set( $entryKeyAttributeName = $ctx.stash.metadata.dynamodbNameOverrideMap.get(\\"$entry.key\\") )
  #else
    #set( $entryKeyAttributeName = $entry.key )
  #end
  #if( $util.isNull($entry.value) )
    #set( $discard = $expRemove.add(\\"#$entryKeyAttributeName\\") )
    $util.qr($expNames.put(\\"#$entryKeyAttributeName\\", \\"$entry.key\\"))
  #else
    $util.qr($expSet.put(\\"#$entryKeyAttributeName\\", \\":$entryKeyAttributeName\\"))
    $util.qr($expNames.put(\\"#$entryKeyAttributeName\\", \\"$entry.key\\"))
    $util.qr($expValues.put(\\":$entryKeyAttributeName\\", $util.dynamodb.toDynamoDB($entry.value)))
  #end
#end
#set( $expression = \\"\\" )
#if( !$expSet.isEmpty() )
  #set( $expression = \\"SET\\" )
  #foreach( $entry in $expSet.entrySet() )
    #set( $expression = \\"$expression $entry.key = $entry.value\\" )
    #if( $foreach.hasNext() )
      #set( $expression = \\"$expression,\\" )
    #end
  #end
#end
#if( !$expAdd.isEmpty() )
  #set( $expression = \\"$expression ADD\\" )
  #foreach( $entry in $expAdd.entrySet() )
    #set( $expression = \\"$expression $entry.key $entry.value\\" )
    #if( $foreach.hasNext() )
      #set( $expression = \\"$expression,\\" )
    #end
  #end
#end
#if( !$expRemove.isEmpty() )
  #set( $expression = \\"$expression REMOVE\\" )
  #foreach( $entry in $expRemove )
    #set( $expression = \\"$expression $entry\\" )
    #if( $foreach.hasNext() )
      #set( $expression = \\"$expression,\\" )
    #end
  #end
#end
#set( $update = {} )
$util.qr($update.put(\\"expression\\", \\"$expression\\"))
#if( !$expNames.isEmpty() )
  $util.qr($update.put(\\"expressionNames\\", $expNames))
#end
#if( !$expValues.isEmpty() )
  $util.qr($update.put(\\"expressionValues\\", $expValues))
#end
## Begin - key condition **
#if( $ctx.stash.metadata.modelObjectKey )
  #set( $keyConditionExpr = {} )
  #set( $keyConditionExprNames = {} )
  #foreach( $entry in $ctx.stash.metadata.modelObjectKey.entrySet() )
    $util.qr($keyConditionExpr.put(\\"keyCondition$velocityCount\\", {
  \\"attributeExists\\": true
}))
    $util.qr($keyConditionExprNames.put(\\"#keyCondition$velocityCount\\", \\"$entry.key\\"))
  #end
  $util.qr($ctx.stash.conditions.add($keyConditionExpr))
#else
  $util.qr($ctx.stash.conditions.add({
  \\"id\\": {
      \\"attributeExists\\": true
  }
}))
#end
## End - key condition **
#if( $args.condition )
  $util.qr($ctx.stash.conditions.add($args.condition))
#end
## Start condition block **
#if( $ctx.stash.conditions && $ctx.stash.conditions.size() != 0 )
  #set( $mergedConditions = {
  \\"and\\": $ctx.stash.conditions
} )
  #set( $Conditions = $util.parseJson($util.transform.toDynamoDBConditionExpression($mergedConditions)) )
  #if( $Conditions.expressionValues && $Conditions.expressionValues.size() == 0 )
    #set( $Conditions = {
  \\"expression\\": $Conditions.expression,
  \\"expressionNames\\": $Conditions.expressionNames
} )
  #end
  ## End condition block **
#end
#set( $UpdateItem = {
  \\"version\\": \\"2018-05-29\\",
  \\"operation\\": \\"UpdateItem\\",
  \\"key\\": $Key,
  \\"update\\": $update,
  \\"_version\\": $util.defaultIfNull($args.input[\\"_version\\"], 0)
} )
#if( $Conditions )
  #if( $keyConditionExprNames )
    $util.qr($Conditions.expressionNames.putAll($keyConditionExprNames))
  #end
  $util.qr($UpdateItem.put(\\"condition\\", $Conditions))
#end
$util.toJson($UpdateItem)
## [End] Mutation Update resolver. **",
  "Mutation.updatePost.res.vtl": "## [Start] ResponseTemplate. **
$util.qr($ctx.result.put(\\"__operation\\", \\"Mutation\\"))
#if( $ctx.error )
  $util.error($ctx.error.message, $ctx.error.type, $ctx.result)
#else
  $util.toJson($ctx.result)
#end
## [End] ResponseTemplate. **",
  "Query.getPost.postAuth.1.req.vtl": "## [Start] Sandbox Mode Disabled. **
#if( !$ctx.stash.get(\\"hasAuth\\") )
  $util.unauthorized()
#end
$util.toJson({})
## [End] Sandbox Mode Disabled. **",
  "Query.getPost.req.vtl": "## [Start] Get Request template. **
#set( $GetRequest = {
  \\"version\\": \\"2018-05-29\\",
  \\"operation\\": \\"Query\\"
} )
#if( $ctx.stash.metadata.modelObjectKey )
  #set( $expression = \\"\\" )
  #set( $expressionNames = {} )
  #set( $expressionValues = {} )
  #foreach( $item in $ctx.stash.metadata.modelObjectKey.entrySet() )
    #set( $expression = \\"$expression#keyCount$velocityCount = :valueCount$velocityCount AND \\" )
    $util.qr($expressionNames.put(\\"#keyCount$velocityCount\\", $item.key))
    $util.qr($expressionValues.put(\\":valueCount$velocityCount\\", $item.value))
  #end
  #set( $expression = $expression.replaceAll(\\"AND $\\", \\"\\") )
  #set( $query = {
  \\"expression\\": $expression,
  \\"expressionNames\\": $expressionNames,
  \\"expressionValues\\": $expressionValues
} )
#else
  #set( $query = {
  \\"expression\\": \\"id = :id\\",
  \\"expressionValues\\": {
      \\":id\\":     $util.parseJson($util.dynamodb.toDynamoDBJson($ctx.args.id))
  }
} )
#end
$util.qr($GetRequest.put(\\"query\\", $query))
#if( !$util.isNullOrEmpty($ctx.stash.authFilter) )
  $util.qr($GetRequest.put(\\"filter\\", $util.parseJson($util.transform.toDynamoDBFilterExpression($ctx.stash.authFilter))))
#end
$util.toJson($GetRequest)
## [End] Get Request template. **",
  "Query.getPost.res.vtl": "## [Start] Get Response template. **
#if( $ctx.error )
  $util.error($ctx.error.message, $ctx.error.type, $ctx.result)
#end
#if( !$ctx.result.items.isEmpty() && $ctx.result.scannedCount == 1 )
  $util.toJson($ctx.result.items[0])
#else
  #if( $ctx.result.items.isEmpty() && $ctx.result.scannedCount == 1 )
$util.unauthorized()
  #end
  $util.toJson(null)
#end
## [End] Get Response template. **",
  "Query.listPosts.postAuth.1.req.vtl": "## [Start] Sandbox Mode Disabled. **
#if( !$ctx.stash.get(\\"hasAuth\\") )
  $util.unauthorized()
#end
$util.toJson({})
## [End] Sandbox Mode Disabled. **",
  "Query.listPosts.req.vtl": "## [Start] List Request. **
#set( $args = $util.defaultIfNull($ctx.stash.transformedArgs, $ctx.args) )
#set( $limit = $util.defaultIfNull($args.limit, 100) )
#set( $ListRequest = {
  \\"version\\": \\"2018-05-29\\",
  \\"limit\\": $limit
} )
#if( $args.nextToken )
  #set( $ListRequest.nextToken = $args.nextToken )
#end
#if( !$util.isNullOrEmpty($ctx.stash.authFilter) )
  #set( $filter = $ctx.stash.authFilter )
  #if( !$util.isNullOrEmpty($args.filter) )
    #set( $filter = {
  \\"and\\":   [$filter, $args.filter]
} )
  #end
#else
  #if( !$util.isNullOrEmpty($args.filter) )
    #set( $filter = $args.filter )
  #end
#end
#if( !$util.isNullOrEmpty($filter) )
  #set( $filterExpression = $util.parseJson($util.transform.toDynamoDBFilterExpression($filter)) )
  #if( !$util.isNullOrBlank($filterExpression.expression) )
    #if( $filterExpression.expressionValues.size() == 0 )
      $util.qr($filterExpression.remove(\\"expressionValues\\"))
    #end
    #set( $ListRequest.filter = $filterExpression )
  #end
#end
#if( !$util.isNull($ctx.stash.modelQueryExpression) && !$util.isNullOrEmpty($ctx.stash.modelQueryExpression.expression) )
  $util.qr($ListRequest.put(\\"operation\\", \\"Query\\"))
  $util.qr($ListRequest.put(\\"query\\", $ctx.stash.modelQueryExpression))
  #if( !$util.isNull($args.sortDirection) && $args.sortDirection == \\"DESC\\" )
    #set( $ListRequest.scanIndexForward = false )
  #else
    #set( $ListRequest.scanIndexForward = true )
  #end
#else
  $util.qr($ListRequest.put(\\"operation\\", \\"Scan\\"))
#end
#if( !$util.isNull($ctx.stash.metadata.index) )
  #set( $ListRequest.IndexName = $ctx.stash.metadata.index )
#end
$util.toJson($ListRequest)
## [End] List Request. **",
  "Query.listPosts.res.vtl": "## [Start] ResponseTemplate. **
#if( $ctx.error )
  $util.error($ctx.error.message, $ctx.error.type, $ctx.result)
#else
  $util.toJson($ctx.result)
#end
## [End] ResponseTemplate. **",
  "Query.syncPosts.postAuth.1.req.vtl": "## [Start] Sandbox Mode Disabled. **
#if( !$ctx.stash.get(\\"hasAuth\\") )
  $util.unauthorized()
#end
$util.toJson({})
## [End] Sandbox Mode Disabled. **",
  "Query.syncPosts.req.vtl": "## [Start] Sync Request template. **
#set( $args = $util.defaultIfNull($ctx.stash.transformedArgs, $ctx.args) )
#if( !$util.isNullOrEmpty($ctx.stash.authFilter) )
  #set( $filter = $ctx.stash.authFilter )
  #if( !$util.isNullOrEmpty($args.filter) )
    #set( $filter = {
  \\"and\\":   [$filter, $args.filter]
} )
  #end
#else
  #if( !$util.isNullOrEmpty($args.filter) )
    #set( $filter = $args.filter )
  #end
#end
#if( !$util.isNullOrEmpty($filter) )
  #set( $filterExpression = $util.parseJson($util.transform.toDynamoDBFilterExpression($filter)) )
  #if( !$util.isNullOrBlank($filterExpression.expression) )
    #if( $filterExpression.expressionValues.size() == 0 )
      $util.qr($filterExpression.remove(\\"expressionValues\\"))
    #end
    #set( $filter = $filterExpression )
  #end
#end
{
  \\"version\\": \\"2018-05-29\\",
  \\"operation\\": \\"Sync\\",
  \\"filter\\":   #if( $filter )
$util.toJson($filter)
  #else
null
  #end,
  \\"limit\\": $util.defaultIfNull($args.limit, 100),
  \\"lastSync\\": $util.toJson($util.defaultIfNull($args.lastSync, null)),
  \\"nextToken\\": $util.toJson($util.defaultIfNull($args.nextToken, null))
}
## [End] Sync Request template. **",
  "Query.syncPosts.res.vtl": "## [Start] ResponseTemplate. **
#if( $ctx.error )
  $util.error($ctx.error.message, $ctx.error.type, $ctx.result)
#else
  $util.toJson($ctx.result)
#end
## [End] ResponseTemplate. **",
  "Subscription.onCreatePost.postAuth.1.req.vtl": "## [Start] Sandbox Mode Disabled. **
#if( !$ctx.stash.get(\\"hasAuth\\") )
  $util.unauthorized()
#end
$util.toJson({})
## [End] Sandbox Mode Disabled. **",
  "Subscription.onCreatePost.req.vtl": "## [Start] Subscription Request template. **
$util.toJson({
  \\"version\\": \\"2018-05-29\\",
  \\"payload\\": {}
})
## [End] Subscription Request template. **",
  "Subscription.onCreatePost.res.vtl": "## [Start] Subscription Response template. **
$util.toJson(null)
## [End] Subscription Response template. **",
  "Subscription.onDeletePost.postAuth.1.req.vtl": "## [Start] Sandbox Mode Disabled. **
#if( !$ctx.stash.get(\\"hasAuth\\") )
  $util.unauthorized()
#end
$util.toJson({})
## [End] Sandbox Mode Disabled. **",
  "Subscription.onDeletePost.req.vtl": "## [Start] Subscription Request template. **
$util.toJson({
  \\"version\\": \\"2018-05-29\\",
  \\"payload\\": {}
})
## [End] Subscription Request template. **",
  "Subscription.onDeletePost.res.vtl": "## [Start] Subscription Response template. **
$util.toJson(null)
## [End] Subscription Response template. **",
  "Subscription.onUpdatePost.postAuth.1.req.vtl": "## [Start] Sandbox Mode Disabled. **
#if( !$ctx.stash.get(\\"hasAuth\\") )
  $util.unauthorized()
#end
$util.toJson({})
## [End] Sandbox Mode Disabled. **",
  "Subscription.onUpdatePost.req.vtl": "## [Start] Subscription Request template. **
$util.toJson({
  \\"version\\": \\"2018-05-29\\",
  \\"payload\\": {}
})
## [End] Subscription Request template. **",
  "Subscription.onUpdatePost.res.vtl": "## [Start] Subscription Response template. **
$util.toJson(null)
## [End] Subscription Response template. **",
}
`;

exports[`ModelTransformer:  should generate sync resolver with ConflictHandlerType.Optimistic 1`] = `
Object {
  "Mutation.createPost.init.1.req.vtl": "## [Start] Initialization default values. **
$util.qr($ctx.stash.put(\\"defaultValues\\", $util.defaultIfNull($ctx.stash.defaultValues, {})))
#set( $createdAt = $util.time.nowISO8601() )
$util.qr($ctx.stash.defaultValues.put(\\"id\\", $util.autoId()))
$util.qr($ctx.stash.defaultValues.put(\\"createdAt\\", $createdAt))
$util.qr($ctx.stash.defaultValues.put(\\"updatedAt\\", $createdAt))
$util.toJson({
  \\"version\\": \\"2018-05-29\\",
  \\"payload\\": {}
})
## [End] Initialization default values. **",
  "Mutation.createPost.postAuth.1.req.vtl": "## [Start] Sandbox Mode Disabled. **
#if( !$ctx.stash.get(\\"hasAuth\\") )
  $util.unauthorized()
#end
$util.toJson({})
## [End] Sandbox Mode Disabled. **",
  "Mutation.createPost.req.vtl": "## [Start] Create Request template. **
#set( $args = $util.defaultIfNull($ctx.stash.transformedArgs, $ctx.args) )
## Set the default values to put request **
#set( $mergedValues = $util.defaultIfNull($ctx.stash.defaultValues, {}) )
## copy the values from input **
$util.qr($mergedValues.putAll($util.defaultIfNull($args.input, {})))
## set the typename **
$util.qr($mergedValues.put(\\"__typename\\", \\"Post\\"))
#set( $PutObject = {
  \\"version\\": \\"2018-05-29\\",
  \\"operation\\": \\"PutItem\\",
  \\"attributeValues\\":   $util.dynamodb.toMapValues($mergedValues),
  \\"condition\\": $condition
} )
#if( $args.condition )
  $util.qr($ctx.stash.conditions.add($args.condition))
#end
## Begin - key condition **
#if( $ctx.stash.metadata.modelObjectKey )
  #set( $keyConditionExpr = {} )
  #set( $keyConditionExprNames = {} )
  #foreach( $entry in $ctx.stash.metadata.modelObjectKey.entrySet() )
    $util.qr($keyConditionExpr.put(\\"keyCondition$velocityCount\\", {
  \\"attributeExists\\": false
}))
    $util.qr($keyConditionExprNames.put(\\"#keyCondition$velocityCount\\", \\"$entry.key\\"))
  #end
  $util.qr($ctx.stash.conditions.add($keyConditionExpr))
#else
  $util.qr($ctx.stash.conditions.add({
  \\"id\\": {
      \\"attributeExists\\": false
  }
}))
#end
## End - key condition **
## Start condition block **
#if( $ctx.stash.conditions && $ctx.stash.conditions.size() != 0 )
  #set( $mergedConditions = {
  \\"and\\": $ctx.stash.conditions
} )
  #set( $Conditions = $util.parseJson($util.transform.toDynamoDBConditionExpression($mergedConditions)) )
  #if( $Conditions.expressionValues && $Conditions.expressionValues.size() == 0 )
    #set( $Conditions = {
  \\"expression\\": $Conditions.expression,
  \\"expressionNames\\": $Conditions.expressionNames
} )
  #end
  ## End condition block **
#end
#if( $Conditions )
  #if( $keyConditionExprNames )
    $util.qr($Conditions.expressionNames.putAll($keyConditionExprNames))
  #end
  $util.qr($PutObject.put(\\"condition\\", $Conditions))
#end
#if( $ctx.stash.metadata.modelObjectKey )
  $util.qr($PutObject.put(\\"key\\", $ctx.stash.metadata.modelObjectKey))
#else
  #set( $Key = {
  \\"id\\":   $util.dynamodb.toDynamoDB($mergedValues.id)
} )
  $util.qr($PutObject.put(\\"key\\", $Key))
#end
$util.toJson($PutObject)
## [End] Create Request template. **",
  "Mutation.createPost.res.vtl": "## [Start] ResponseTemplate. **
$util.qr($ctx.result.put(\\"__operation\\", \\"Mutation\\"))
#if( $ctx.error )
  $util.error($ctx.error.message, $ctx.error.type, $ctx.result)
#else
  $util.toJson($ctx.result)
#end
## [End] ResponseTemplate. **",
  "Mutation.deletePost.postAuth.1.req.vtl": "## [Start] Sandbox Mode Disabled. **
#if( !$ctx.stash.get(\\"hasAuth\\") )
  $util.unauthorized()
#end
$util.toJson({})
## [End] Sandbox Mode Disabled. **",
  "Mutation.deletePost.req.vtl": "## [Start] Delete Request template. **
#set( $args = $util.defaultIfNull($ctx.stash.transformedArgs, $ctx.args) )
#set( $DeleteRequest = {
  \\"version\\": \\"2018-05-29\\",
  \\"operation\\": \\"DeleteItem\\"
} )
#if( $ctx.stash.metadata.modelObjectKey )
  #set( $Key = $ctx.stash.metadata.modelObjectKey )
#else
  #set( $Key = {
  \\"id\\":   $util.dynamodb.toDynamoDB($args.input.id)
} )
#end
$util.qr($DeleteRequest.put(\\"key\\", $Key))
## Begin - key condition **
#if( $ctx.stash.metadata.modelObjectKey )
  #set( $keyConditionExpr = {} )
  #set( $keyConditionExprNames = {} )
  #foreach( $entry in $ctx.stash.metadata.modelObjectKey.entrySet() )
    $util.qr($keyConditionExpr.put(\\"keyCondition$velocityCount\\", {
  \\"attributeExists\\": true
}))
    $util.qr($keyConditionExprNames.put(\\"#keyCondition$velocityCount\\", \\"$entry.key\\"))
  #end
  $util.qr($ctx.stash.conditions.add($keyConditionExpr))
#else
  $util.qr($ctx.stash.conditions.add({
  \\"id\\": {
      \\"attributeExists\\": true
  }
}))
#end
## End - key condition **
#if( $args.condition )
  $util.qr($ctx.stash.conditions.add($args.condition))
#end
## Start condition block **
#if( $ctx.stash.conditions && $ctx.stash.conditions.size() != 0 )
  #set( $mergedConditions = {
  \\"and\\": $ctx.stash.conditions
} )
  #set( $Conditions = $util.parseJson($util.transform.toDynamoDBConditionExpression($mergedConditions)) )
  #if( $Conditions.expressionValues && $Conditions.expressionValues.size() == 0 )
    #set( $Conditions = {
  \\"expression\\": $Conditions.expression,
  \\"expressionNames\\": $Conditions.expressionNames
} )
  #end
  ## End condition block **
#end
#if( $Conditions )
  #if( $keyConditionExprNames )
    $util.qr($Conditions.expressionNames.putAll($keyConditionExprNames))
  #end
  $util.qr($DeleteRequest.put(\\"condition\\", $Conditions))
#end
$util.qr($DeleteRequest.put(\\"_version\\", $util.defaultIfNull($args.input[\\"_version\\"], 0)))
$util.toJson($DeleteRequest)
## [End] Delete Request template. **",
  "Mutation.deletePost.res.vtl": "## [Start] ResponseTemplate. **
$util.qr($ctx.result.put(\\"__operation\\", \\"Mutation\\"))
#if( $ctx.error )
  $util.error($ctx.error.message, $ctx.error.type, $ctx.result)
#else
  $util.toJson($ctx.result)
#end
## [End] ResponseTemplate. **",
  "Mutation.updatePost.init.1.req.vtl": "## [Start] Initialization default values. **
$util.qr($ctx.stash.put(\\"defaultValues\\", $util.defaultIfNull($ctx.stash.defaultValues, {})))
#set( $updatedAt = $util.time.nowISO8601() )
$util.qr($ctx.stash.defaultValues.put(\\"updatedAt\\", $updatedAt))
$util.toJson({
  \\"version\\": \\"2018-05-29\\",
  \\"payload\\": {}
})
## [End] Initialization default values. **",
  "Mutation.updatePost.postAuth.1.req.vtl": "## [Start] Sandbox Mode Disabled. **
#if( !$ctx.stash.get(\\"hasAuth\\") )
  $util.unauthorized()
#end
$util.toJson({})
## [End] Sandbox Mode Disabled. **",
  "Mutation.updatePost.req.vtl": "## [Start] Mutation Update resolver. **
#set( $args = $util.defaultIfNull($ctx.stash.transformedArgs, $ctx.args) )
## Set the default values to put request **
#set( $mergedValues = $util.defaultIfNull($ctx.stash.defaultValues, {}) )
## copy the values from input **
$util.qr($mergedValues.putAll($util.defaultIfNull($args.input, {})))
## set the typename **
## Initialize the vars for creating ddb expression **
#set( $expNames = {} )
#set( $expValues = {} )
#set( $expSet = {} )
#set( $expAdd = {} )
#set( $expRemove = [] )
#if( $ctx.stash.metadata.modelObjectKey )
  #set( $Key = $ctx.stash.metadata.modelObjectKey )
#else
  #set( $Key = {
  \\"id\\":   $util.dynamodb.toDynamoDB($args.input.id)
} )
#end
## Model key **
#if( $ctx.stash.metadata.modelObjectKey )
  #set( $keyFields = [\\"_version\\", \\"_deleted\\", \\"_lastChangedAt\\"] )
  #foreach( $entry in $ctx.stash.metadata.modelObjectKey.entrySet() )
    $util.qr($keyFields.add(\\"$entry.key\\"))
  #end
#else
  #set( $keyFields = [\\"id\\", \\"_version\\", \\"_deleted\\", \\"_lastChangedAt\\"] )
#end
#foreach( $entry in $util.map.copyAndRemoveAllKeys($mergedValues, $keyFields).entrySet() )
  #if( !$util.isNull($ctx.stash.metadata.dynamodbNameOverrideMap) && $ctx.stash.metadata.dynamodbNameOverrideMap.containsKey(\\"$entry.key\\") )
    #set( $entryKeyAttributeName = $ctx.stash.metadata.dynamodbNameOverrideMap.get(\\"$entry.key\\") )
  #else
    #set( $entryKeyAttributeName = $entry.key )
  #end
  #if( $util.isNull($entry.value) )
    #set( $discard = $expRemove.add(\\"#$entryKeyAttributeName\\") )
    $util.qr($expNames.put(\\"#$entryKeyAttributeName\\", \\"$entry.key\\"))
  #else
    $util.qr($expSet.put(\\"#$entryKeyAttributeName\\", \\":$entryKeyAttributeName\\"))
    $util.qr($expNames.put(\\"#$entryKeyAttributeName\\", \\"$entry.key\\"))
    $util.qr($expValues.put(\\":$entryKeyAttributeName\\", $util.dynamodb.toDynamoDB($entry.value)))
  #end
#end
#set( $expression = \\"\\" )
#if( !$expSet.isEmpty() )
  #set( $expression = \\"SET\\" )
  #foreach( $entry in $expSet.entrySet() )
    #set( $expression = \\"$expression $entry.key = $entry.value\\" )
    #if( $foreach.hasNext() )
      #set( $expression = \\"$expression,\\" )
    #end
  #end
#end
#if( !$expAdd.isEmpty() )
  #set( $expression = \\"$expression ADD\\" )
  #foreach( $entry in $expAdd.entrySet() )
    #set( $expression = \\"$expression $entry.key $entry.value\\" )
    #if( $foreach.hasNext() )
      #set( $expression = \\"$expression,\\" )
    #end
  #end
#end
#if( !$expRemove.isEmpty() )
  #set( $expression = \\"$expression REMOVE\\" )
  #foreach( $entry in $expRemove )
    #set( $expression = \\"$expression $entry\\" )
    #if( $foreach.hasNext() )
      #set( $expression = \\"$expression,\\" )
    #end
  #end
#end
#set( $update = {} )
$util.qr($update.put(\\"expression\\", \\"$expression\\"))
#if( !$expNames.isEmpty() )
  $util.qr($update.put(\\"expressionNames\\", $expNames))
#end
#if( !$expValues.isEmpty() )
  $util.qr($update.put(\\"expressionValues\\", $expValues))
#end
## Begin - key condition **
#if( $ctx.stash.metadata.modelObjectKey )
  #set( $keyConditionExpr = {} )
  #set( $keyConditionExprNames = {} )
  #foreach( $entry in $ctx.stash.metadata.modelObjectKey.entrySet() )
    $util.qr($keyConditionExpr.put(\\"keyCondition$velocityCount\\", {
  \\"attributeExists\\": true
}))
    $util.qr($keyConditionExprNames.put(\\"#keyCondition$velocityCount\\", \\"$entry.key\\"))
  #end
  $util.qr($ctx.stash.conditions.add($keyConditionExpr))
#else
  $util.qr($ctx.stash.conditions.add({
  \\"id\\": {
      \\"attributeExists\\": true
  }
}))
#end
## End - key condition **
#if( $args.condition )
  $util.qr($ctx.stash.conditions.add($args.condition))
#end
## Start condition block **
#if( $ctx.stash.conditions && $ctx.stash.conditions.size() != 0 )
  #set( $mergedConditions = {
  \\"and\\": $ctx.stash.conditions
} )
  #set( $Conditions = $util.parseJson($util.transform.toDynamoDBConditionExpression($mergedConditions)) )
  #if( $Conditions.expressionValues && $Conditions.expressionValues.size() == 0 )
    #set( $Conditions = {
  \\"expression\\": $Conditions.expression,
  \\"expressionNames\\": $Conditions.expressionNames
} )
  #end
  ## End condition block **
#end
#set( $UpdateItem = {
  \\"version\\": \\"2018-05-29\\",
  \\"operation\\": \\"UpdateItem\\",
  \\"key\\": $Key,
  \\"update\\": $update,
  \\"_version\\": $util.defaultIfNull($args.input[\\"_version\\"], 0)
} )
#if( $Conditions )
  #if( $keyConditionExprNames )
    $util.qr($Conditions.expressionNames.putAll($keyConditionExprNames))
  #end
  $util.qr($UpdateItem.put(\\"condition\\", $Conditions))
#end
$util.toJson($UpdateItem)
## [End] Mutation Update resolver. **",
  "Mutation.updatePost.res.vtl": "## [Start] ResponseTemplate. **
$util.qr($ctx.result.put(\\"__operation\\", \\"Mutation\\"))
#if( $ctx.error )
  $util.error($ctx.error.message, $ctx.error.type, $ctx.result)
#else
  $util.toJson($ctx.result)
#end
## [End] ResponseTemplate. **",
  "Query.getPost.postAuth.1.req.vtl": "## [Start] Sandbox Mode Disabled. **
#if( !$ctx.stash.get(\\"hasAuth\\") )
  $util.unauthorized()
#end
$util.toJson({})
## [End] Sandbox Mode Disabled. **",
  "Query.getPost.req.vtl": "## [Start] Get Request template. **
#set( $GetRequest = {
  \\"version\\": \\"2018-05-29\\",
  \\"operation\\": \\"Query\\"
} )
#if( $ctx.stash.metadata.modelObjectKey )
  #set( $expression = \\"\\" )
  #set( $expressionNames = {} )
  #set( $expressionValues = {} )
  #foreach( $item in $ctx.stash.metadata.modelObjectKey.entrySet() )
    #set( $expression = \\"$expression#keyCount$velocityCount = :valueCount$velocityCount AND \\" )
    $util.qr($expressionNames.put(\\"#keyCount$velocityCount\\", $item.key))
    $util.qr($expressionValues.put(\\":valueCount$velocityCount\\", $item.value))
  #end
  #set( $expression = $expression.replaceAll(\\"AND $\\", \\"\\") )
  #set( $query = {
  \\"expression\\": $expression,
  \\"expressionNames\\": $expressionNames,
  \\"expressionValues\\": $expressionValues
} )
#else
  #set( $query = {
  \\"expression\\": \\"id = :id\\",
  \\"expressionValues\\": {
      \\":id\\":     $util.parseJson($util.dynamodb.toDynamoDBJson($ctx.args.id))
  }
} )
#end
$util.qr($GetRequest.put(\\"query\\", $query))
#if( !$util.isNullOrEmpty($ctx.stash.authFilter) )
  $util.qr($GetRequest.put(\\"filter\\", $util.parseJson($util.transform.toDynamoDBFilterExpression($ctx.stash.authFilter))))
#end
$util.toJson($GetRequest)
## [End] Get Request template. **",
  "Query.getPost.res.vtl": "## [Start] Get Response template. **
#if( $ctx.error )
  $util.error($ctx.error.message, $ctx.error.type, $ctx.result)
#end
#if( !$ctx.result.items.isEmpty() && $ctx.result.scannedCount == 1 )
  $util.toJson($ctx.result.items[0])
#else
  #if( $ctx.result.items.isEmpty() && $ctx.result.scannedCount == 1 )
$util.unauthorized()
  #end
  $util.toJson(null)
#end
## [End] Get Response template. **",
  "Query.listPosts.postAuth.1.req.vtl": "## [Start] Sandbox Mode Disabled. **
#if( !$ctx.stash.get(\\"hasAuth\\") )
  $util.unauthorized()
#end
$util.toJson({})
## [End] Sandbox Mode Disabled. **",
  "Query.listPosts.req.vtl": "## [Start] List Request. **
#set( $args = $util.defaultIfNull($ctx.stash.transformedArgs, $ctx.args) )
#set( $limit = $util.defaultIfNull($args.limit, 100) )
#set( $ListRequest = {
  \\"version\\": \\"2018-05-29\\",
  \\"limit\\": $limit
} )
#if( $args.nextToken )
  #set( $ListRequest.nextToken = $args.nextToken )
#end
#if( !$util.isNullOrEmpty($ctx.stash.authFilter) )
  #set( $filter = $ctx.stash.authFilter )
  #if( !$util.isNullOrEmpty($args.filter) )
    #set( $filter = {
  \\"and\\":   [$filter, $args.filter]
} )
  #end
#else
  #if( !$util.isNullOrEmpty($args.filter) )
    #set( $filter = $args.filter )
  #end
#end
#if( !$util.isNullOrEmpty($filter) )
  #set( $filterExpression = $util.parseJson($util.transform.toDynamoDBFilterExpression($filter)) )
  #if( !$util.isNullOrBlank($filterExpression.expression) )
    #if( $filterExpression.expressionValues.size() == 0 )
      $util.qr($filterExpression.remove(\\"expressionValues\\"))
    #end
    #set( $ListRequest.filter = $filterExpression )
  #end
#end
#if( !$util.isNull($ctx.stash.modelQueryExpression) && !$util.isNullOrEmpty($ctx.stash.modelQueryExpression.expression) )
  $util.qr($ListRequest.put(\\"operation\\", \\"Query\\"))
  $util.qr($ListRequest.put(\\"query\\", $ctx.stash.modelQueryExpression))
  #if( !$util.isNull($args.sortDirection) && $args.sortDirection == \\"DESC\\" )
    #set( $ListRequest.scanIndexForward = false )
  #else
    #set( $ListRequest.scanIndexForward = true )
  #end
#else
  $util.qr($ListRequest.put(\\"operation\\", \\"Scan\\"))
#end
#if( !$util.isNull($ctx.stash.metadata.index) )
  #set( $ListRequest.IndexName = $ctx.stash.metadata.index )
#end
$util.toJson($ListRequest)
## [End] List Request. **",
  "Query.listPosts.res.vtl": "## [Start] ResponseTemplate. **
#if( $ctx.error )
  $util.error($ctx.error.message, $ctx.error.type, $ctx.result)
#else
  $util.toJson($ctx.result)
#end
## [End] ResponseTemplate. **",
  "Query.syncPosts.postAuth.1.req.vtl": "## [Start] Sandbox Mode Disabled. **
#if( !$ctx.stash.get(\\"hasAuth\\") )
  $util.unauthorized()
#end
$util.toJson({})
## [End] Sandbox Mode Disabled. **",
  "Query.syncPosts.req.vtl": "## [Start] Sync Request template. **
#set( $args = $util.defaultIfNull($ctx.stash.transformedArgs, $ctx.args) )
#if( !$util.isNullOrEmpty($ctx.stash.authFilter) )
  #set( $filter = $ctx.stash.authFilter )
  #if( !$util.isNullOrEmpty($args.filter) )
    #set( $filter = {
  \\"and\\":   [$filter, $args.filter]
} )
  #end
#else
  #if( !$util.isNullOrEmpty($args.filter) )
    #set( $filter = $args.filter )
  #end
#end
#if( !$util.isNullOrEmpty($filter) )
  #set( $filterExpression = $util.parseJson($util.transform.toDynamoDBFilterExpression($filter)) )
  #if( !$util.isNullOrBlank($filterExpression.expression) )
    #if( $filterExpression.expressionValues.size() == 0 )
      $util.qr($filterExpression.remove(\\"expressionValues\\"))
    #end
    #set( $filter = $filterExpression )
  #end
#end
{
  \\"version\\": \\"2018-05-29\\",
  \\"operation\\": \\"Sync\\",
  \\"filter\\":   #if( $filter )
$util.toJson($filter)
  #else
null
  #end,
  \\"limit\\": $util.defaultIfNull($args.limit, 100),
  \\"lastSync\\": $util.toJson($util.defaultIfNull($args.lastSync, null)),
  \\"nextToken\\": $util.toJson($util.defaultIfNull($args.nextToken, null))
}
## [End] Sync Request template. **",
  "Query.syncPosts.res.vtl": "## [Start] ResponseTemplate. **
#if( $ctx.error )
  $util.error($ctx.error.message, $ctx.error.type, $ctx.result)
#else
  $util.toJson($ctx.result)
#end
## [End] ResponseTemplate. **",
  "Subscription.onCreatePost.postAuth.1.req.vtl": "## [Start] Sandbox Mode Disabled. **
#if( !$ctx.stash.get(\\"hasAuth\\") )
  $util.unauthorized()
#end
$util.toJson({})
## [End] Sandbox Mode Disabled. **",
  "Subscription.onCreatePost.req.vtl": "## [Start] Subscription Request template. **
$util.toJson({
  \\"version\\": \\"2018-05-29\\",
  \\"payload\\": {}
})
## [End] Subscription Request template. **",
  "Subscription.onCreatePost.res.vtl": "## [Start] Subscription Response template. **
$util.toJson(null)
## [End] Subscription Response template. **",
  "Subscription.onDeletePost.postAuth.1.req.vtl": "## [Start] Sandbox Mode Disabled. **
#if( !$ctx.stash.get(\\"hasAuth\\") )
  $util.unauthorized()
#end
$util.toJson({})
## [End] Sandbox Mode Disabled. **",
  "Subscription.onDeletePost.req.vtl": "## [Start] Subscription Request template. **
$util.toJson({
  \\"version\\": \\"2018-05-29\\",
  \\"payload\\": {}
})
## [End] Subscription Request template. **",
  "Subscription.onDeletePost.res.vtl": "## [Start] Subscription Response template. **
$util.toJson(null)
## [End] Subscription Response template. **",
  "Subscription.onUpdatePost.postAuth.1.req.vtl": "## [Start] Sandbox Mode Disabled. **
#if( !$ctx.stash.get(\\"hasAuth\\") )
  $util.unauthorized()
#end
$util.toJson({})
## [End] Sandbox Mode Disabled. **",
  "Subscription.onUpdatePost.req.vtl": "## [Start] Subscription Request template. **
$util.toJson({
  \\"version\\": \\"2018-05-29\\",
  \\"payload\\": {}
})
## [End] Subscription Request template. **",
  "Subscription.onUpdatePost.res.vtl": "## [Start] Subscription Response template. **
$util.toJson(null)
## [End] Subscription Response template. **",
}
`;

exports[`ModelTransformer:  should have timestamps as nullable fields when the type makes it non-nullable 1`] = `
"
type Post {
  id: ID!
  str: String
  createdAt: AWSDateTime!
  updatedAt: AWSDateTime!
}

input ModelStringInput {
  ne: String
  eq: String
  le: String
  lt: String
  ge: String
  gt: String
  contains: String
  notContains: String
  between: [String]
  beginsWith: String
  attributeExists: Boolean
  attributeType: ModelAttributeTypes
  size: ModelSizeInput
}

input ModelIntInput {
  ne: Int
  eq: Int
  le: Int
  lt: Int
  ge: Int
  gt: Int
  between: [Int]
  attributeExists: Boolean
  attributeType: ModelAttributeTypes
}

input ModelFloatInput {
  ne: Float
  eq: Float
  le: Float
  lt: Float
  ge: Float
  gt: Float
  between: [Float]
  attributeExists: Boolean
  attributeType: ModelAttributeTypes
}

input ModelBooleanInput {
  ne: Boolean
  eq: Boolean
  attributeExists: Boolean
  attributeType: ModelAttributeTypes
}

input ModelIDInput {
  ne: ID
  eq: ID
  le: ID
  lt: ID
  ge: ID
  gt: ID
  contains: ID
  notContains: ID
  between: [ID]
  beginsWith: ID
  attributeExists: Boolean
  attributeType: ModelAttributeTypes
  size: ModelSizeInput
}

enum ModelAttributeTypes {
  binary
  binarySet
  bool
  list
  map
  number
  numberSet
  string
  stringSet
  _null
}

input ModelSizeInput {
  ne: Int
  eq: Int
  le: Int
  lt: Int
  ge: Int
  gt: Int
  between: [Int]
}

enum ModelSortDirection {
  ASC
  DESC
}

type ModelPostConnection {
  items: [Post]!
  nextToken: String
}

input ModelPostFilterInput {
  id: ModelIDInput
  str: ModelStringInput
  createdAt: ModelStringInput
  updatedAt: ModelStringInput
  and: [ModelPostFilterInput]
  or: [ModelPostFilterInput]
  not: ModelPostFilterInput
}

type Query {
  getPost(id: ID!): Post
  listPosts(filter: ModelPostFilterInput, limit: Int, nextToken: String): ModelPostConnection
}

input ModelPostConditionInput {
  str: ModelStringInput
  createdAt: ModelStringInput
  updatedAt: ModelStringInput
  and: [ModelPostConditionInput]
  or: [ModelPostConditionInput]
  not: ModelPostConditionInput
}

input CreatePostInput {
  id: ID
  str: String
  createdAt: AWSDateTime
  updatedAt: AWSDateTime
}

input UpdatePostInput {
  id: ID!
  str: String
  createdAt: AWSDateTime
  updatedAt: AWSDateTime
}

input DeletePostInput {
  id: ID!
}

type Mutation {
  createPost(input: CreatePostInput!, condition: ModelPostConditionInput): Post
  updatePost(input: UpdatePostInput!, condition: ModelPostConditionInput): Post
  deletePost(input: DeletePostInput!, condition: ModelPostConditionInput): Post
}

type Subscription {
  onCreatePost: Post @aws_subscribe(mutations: [\\"createPost\\"])
  onUpdatePost: Post @aws_subscribe(mutations: [\\"updatePost\\"])
  onDeletePost: Post @aws_subscribe(mutations: [\\"deletePost\\"])
}

"
`;

exports[`ModelTransformer:  should have timestamps as nullable fields when the type makes it non-nullable 2`] = `
"## [Start] Create Request template. **
#set( $args = $util.defaultIfNull($ctx.stash.transformedArgs, $ctx.args) )
## Set the default values to put request **
#set( $mergedValues = $util.defaultIfNull($ctx.stash.defaultValues, {}) )
## copy the values from input **
$util.qr($mergedValues.putAll($util.defaultIfNull($args.input, {})))
## set the typename **
$util.qr($mergedValues.put(\\"__typename\\", \\"Post\\"))
#set( $PutObject = {
  \\"version\\": \\"2018-05-29\\",
  \\"operation\\": \\"PutItem\\",
  \\"attributeValues\\":   $util.dynamodb.toMapValues($mergedValues),
  \\"condition\\": $condition
} )
#if( $args.condition )
  $util.qr($ctx.stash.conditions.add($args.condition))
#end
## Begin - key condition **
#if( $ctx.stash.metadata.modelObjectKey )
  #set( $keyConditionExpr = {} )
  #set( $keyConditionExprNames = {} )
  #foreach( $entry in $ctx.stash.metadata.modelObjectKey.entrySet() )
    $util.qr($keyConditionExpr.put(\\"keyCondition$velocityCount\\", {
  \\"attributeExists\\": false
}))
    $util.qr($keyConditionExprNames.put(\\"#keyCondition$velocityCount\\", \\"$entry.key\\"))
  #end
  $util.qr($ctx.stash.conditions.add($keyConditionExpr))
#else
  $util.qr($ctx.stash.conditions.add({
  \\"id\\": {
      \\"attributeExists\\": false
  }
}))
#end
## End - key condition **
## Start condition block **
#if( $ctx.stash.conditions && $ctx.stash.conditions.size() != 0 )
  #set( $mergedConditions = {
  \\"and\\": $ctx.stash.conditions
} )
  #set( $Conditions = $util.parseJson($util.transform.toDynamoDBConditionExpression($mergedConditions)) )
  #if( $Conditions.expressionValues && $Conditions.expressionValues.size() == 0 )
    #set( $Conditions = {
  \\"expression\\": $Conditions.expression,
  \\"expressionNames\\": $Conditions.expressionNames
} )
  #end
  ## End condition block **
#end
#if( $Conditions )
  #if( $keyConditionExprNames )
    $util.qr($Conditions.expressionNames.putAll($keyConditionExprNames))
  #end
  $util.qr($PutObject.put(\\"condition\\", $Conditions))
#end
#if( $ctx.stash.metadata.modelObjectKey )
  $util.qr($PutObject.put(\\"key\\", $ctx.stash.metadata.modelObjectKey))
#else
  #set( $Key = {
  \\"id\\":   $util.dynamodb.toDynamoDB($mergedValues.id)
} )
  $util.qr($PutObject.put(\\"key\\", $Key))
#end
$util.toJson($PutObject)
## [End] Create Request template. **"
`;

exports[`ModelTransformer:  should have timestamps as nullable fields when the type makes it non-nullable 3`] = `
"## [Start] Mutation Update resolver. **
#set( $args = $util.defaultIfNull($ctx.stash.transformedArgs, $ctx.args) )
## Set the default values to put request **
#set( $mergedValues = $util.defaultIfNull($ctx.stash.defaultValues, {}) )
## copy the values from input **
$util.qr($mergedValues.putAll($util.defaultIfNull($args.input, {})))
## set the typename **
## Initialize the vars for creating ddb expression **
#set( $expNames = {} )
#set( $expValues = {} )
#set( $expSet = {} )
#set( $expAdd = {} )
#set( $expRemove = [] )
#if( $ctx.stash.metadata.modelObjectKey )
  #set( $Key = $ctx.stash.metadata.modelObjectKey )
#else
  #set( $Key = {
  \\"id\\":   $util.dynamodb.toDynamoDB($args.input.id)
} )
#end
## Model key **
#if( $ctx.stash.metadata.modelObjectKey )
  #set( $keyFields = [] )
  #foreach( $entry in $ctx.stash.metadata.modelObjectKey.entrySet() )
    $util.qr($keyFields.add(\\"$entry.key\\"))
  #end
#else
  #set( $keyFields = [\\"id\\"] )
#end
#foreach( $entry in $util.map.copyAndRemoveAllKeys($mergedValues, $keyFields).entrySet() )
  #if( !$util.isNull($ctx.stash.metadata.dynamodbNameOverrideMap) && $ctx.stash.metadata.dynamodbNameOverrideMap.containsKey(\\"$entry.key\\") )
    #set( $entryKeyAttributeName = $ctx.stash.metadata.dynamodbNameOverrideMap.get(\\"$entry.key\\") )
  #else
    #set( $entryKeyAttributeName = $entry.key )
  #end
  #if( $util.isNull($entry.value) )
    #set( $discard = $expRemove.add(\\"#$entryKeyAttributeName\\") )
    $util.qr($expNames.put(\\"#$entryKeyAttributeName\\", \\"$entry.key\\"))
  #else
    $util.qr($expSet.put(\\"#$entryKeyAttributeName\\", \\":$entryKeyAttributeName\\"))
    $util.qr($expNames.put(\\"#$entryKeyAttributeName\\", \\"$entry.key\\"))
    $util.qr($expValues.put(\\":$entryKeyAttributeName\\", $util.dynamodb.toDynamoDB($entry.value)))
  #end
#end
#set( $expression = \\"\\" )
#if( !$expSet.isEmpty() )
  #set( $expression = \\"SET\\" )
  #foreach( $entry in $expSet.entrySet() )
    #set( $expression = \\"$expression $entry.key = $entry.value\\" )
    #if( $foreach.hasNext() )
      #set( $expression = \\"$expression,\\" )
    #end
  #end
#end
#if( !$expAdd.isEmpty() )
  #set( $expression = \\"$expression ADD\\" )
  #foreach( $entry in $expAdd.entrySet() )
    #set( $expression = \\"$expression $entry.key $entry.value\\" )
    #if( $foreach.hasNext() )
      #set( $expression = \\"$expression,\\" )
    #end
  #end
#end
#if( !$expRemove.isEmpty() )
  #set( $expression = \\"$expression REMOVE\\" )
  #foreach( $entry in $expRemove )
    #set( $expression = \\"$expression $entry\\" )
    #if( $foreach.hasNext() )
      #set( $expression = \\"$expression,\\" )
    #end
  #end
#end
#set( $update = {} )
$util.qr($update.put(\\"expression\\", \\"$expression\\"))
#if( !$expNames.isEmpty() )
  $util.qr($update.put(\\"expressionNames\\", $expNames))
#end
#if( !$expValues.isEmpty() )
  $util.qr($update.put(\\"expressionValues\\", $expValues))
#end
## Begin - key condition **
#if( $ctx.stash.metadata.modelObjectKey )
  #set( $keyConditionExpr = {} )
  #set( $keyConditionExprNames = {} )
  #foreach( $entry in $ctx.stash.metadata.modelObjectKey.entrySet() )
    $util.qr($keyConditionExpr.put(\\"keyCondition$velocityCount\\", {
  \\"attributeExists\\": true
}))
    $util.qr($keyConditionExprNames.put(\\"#keyCondition$velocityCount\\", \\"$entry.key\\"))
  #end
  $util.qr($ctx.stash.conditions.add($keyConditionExpr))
#else
  $util.qr($ctx.stash.conditions.add({
  \\"id\\": {
      \\"attributeExists\\": true
  }
}))
#end
## End - key condition **
#if( $args.condition )
  $util.qr($ctx.stash.conditions.add($args.condition))
#end
## Start condition block **
#if( $ctx.stash.conditions && $ctx.stash.conditions.size() != 0 )
  #set( $mergedConditions = {
  \\"and\\": $ctx.stash.conditions
} )
  #set( $Conditions = $util.parseJson($util.transform.toDynamoDBConditionExpression($mergedConditions)) )
  #if( $Conditions.expressionValues && $Conditions.expressionValues.size() == 0 )
    #set( $Conditions = {
  \\"expression\\": $Conditions.expression,
  \\"expressionNames\\": $Conditions.expressionNames
} )
  #end
  ## End condition block **
#end
#set( $UpdateItem = {
  \\"version\\": \\"2018-05-29\\",
  \\"operation\\": \\"UpdateItem\\",
  \\"key\\": $Key,
  \\"update\\": $update
} )
#if( $Conditions )
  #if( $keyConditionExprNames )
    $util.qr($Conditions.expressionNames.putAll($keyConditionExprNames))
  #end
  $util.qr($UpdateItem.put(\\"condition\\", $Conditions))
#end
$util.toJson($UpdateItem)
## [End] Mutation Update resolver. **"
`;

exports[`ModelTransformer:  should not add default primary key when ID is defined 1`] = `
"## [Start] Create Request template. **
#set( $args = $util.defaultIfNull($ctx.stash.transformedArgs, $ctx.args) )
## Set the default values to put request **
#set( $mergedValues = $util.defaultIfNull($ctx.stash.defaultValues, {}) )
## copy the values from input **
$util.qr($mergedValues.putAll($util.defaultIfNull($args.input, {})))
## set the typename **
$util.qr($mergedValues.put(\\"__typename\\", \\"Post\\"))
#set( $PutObject = {
  \\"version\\": \\"2018-05-29\\",
  \\"operation\\": \\"PutItem\\",
  \\"attributeValues\\":   $util.dynamodb.toMapValues($mergedValues),
  \\"condition\\": $condition
} )
#if( $args.condition )
  $util.qr($ctx.stash.conditions.add($args.condition))
#end
## Begin - key condition **
#if( $ctx.stash.metadata.modelObjectKey )
  #set( $keyConditionExpr = {} )
  #set( $keyConditionExprNames = {} )
  #foreach( $entry in $ctx.stash.metadata.modelObjectKey.entrySet() )
    $util.qr($keyConditionExpr.put(\\"keyCondition$velocityCount\\", {
  \\"attributeExists\\": false
}))
    $util.qr($keyConditionExprNames.put(\\"#keyCondition$velocityCount\\", \\"$entry.key\\"))
  #end
  $util.qr($ctx.stash.conditions.add($keyConditionExpr))
#else
  $util.qr($ctx.stash.conditions.add({
  \\"id\\": {
      \\"attributeExists\\": false
  }
}))
#end
## End - key condition **
## Start condition block **
#if( $ctx.stash.conditions && $ctx.stash.conditions.size() != 0 )
  #set( $mergedConditions = {
  \\"and\\": $ctx.stash.conditions
} )
  #set( $Conditions = $util.parseJson($util.transform.toDynamoDBConditionExpression($mergedConditions)) )
  #if( $Conditions.expressionValues && $Conditions.expressionValues.size() == 0 )
    #set( $Conditions = {
  \\"expression\\": $Conditions.expression,
  \\"expressionNames\\": $Conditions.expressionNames
} )
  #end
  ## End condition block **
#end
#if( $Conditions )
  #if( $keyConditionExprNames )
    $util.qr($Conditions.expressionNames.putAll($keyConditionExprNames))
  #end
  $util.qr($PutObject.put(\\"condition\\", $Conditions))
#end
#if( $ctx.stash.metadata.modelObjectKey )
  $util.qr($PutObject.put(\\"key\\", $ctx.stash.metadata.modelObjectKey))
#else
  #set( $Key = {
  \\"id\\":   $util.dynamodb.toDynamoDB($mergedValues.id)
} )
  $util.qr($PutObject.put(\\"key\\", $Key))
#end
$util.toJson($PutObject)
## [End] Create Request template. **"
`;

exports[`ModelTransformer:  should not generate superfluous input and filter types 1`] = `
"
type Entity {
  id: ID!
  str: String
  createdAt: AWSDateTime!
  updatedAt: AWSDateTime!
}

input ModelStringInput {
  ne: String
  eq: String
  le: String
  lt: String
  ge: String
  gt: String
  contains: String
  notContains: String
  between: [String]
  beginsWith: String
  attributeExists: Boolean
  attributeType: ModelAttributeTypes
  size: ModelSizeInput
}

input ModelIntInput {
  ne: Int
  eq: Int
  le: Int
  lt: Int
  ge: Int
  gt: Int
  between: [Int]
  attributeExists: Boolean
  attributeType: ModelAttributeTypes
}

input ModelFloatInput {
  ne: Float
  eq: Float
  le: Float
  lt: Float
  ge: Float
  gt: Float
  between: [Float]
  attributeExists: Boolean
  attributeType: ModelAttributeTypes
}

input ModelBooleanInput {
  ne: Boolean
  eq: Boolean
  attributeExists: Boolean
  attributeType: ModelAttributeTypes
}

input ModelIDInput {
  ne: ID
  eq: ID
  le: ID
  lt: ID
  ge: ID
  gt: ID
  contains: ID
  notContains: ID
  between: [ID]
  beginsWith: ID
  attributeExists: Boolean
  attributeType: ModelAttributeTypes
  size: ModelSizeInput
}

enum ModelAttributeTypes {
  binary
  binarySet
  bool
  list
  map
  number
  numberSet
  string
  stringSet
  _null
}

input ModelSizeInput {
  ne: Int
  eq: Int
  le: Int
  lt: Int
  ge: Int
  gt: Int
  between: [Int]
}

enum ModelSortDirection {
  ASC
  DESC
}

type Query {
  getEntity(id: ID!): Entity
}

"
`;

exports[`ModelTransformer:  should not to auto generate createdAt and updatedAt when the type in schema is not AWSDateTime 1`] = `
"
type Post {
  id: ID!
  str: String
  createdAt: AWSTimestamp
  updatedAt: AWSTimestamp
}

input ModelStringInput {
  ne: String
  eq: String
  le: String
  lt: String
  ge: String
  gt: String
  contains: String
  notContains: String
  between: [String]
  beginsWith: String
  attributeExists: Boolean
  attributeType: ModelAttributeTypes
  size: ModelSizeInput
}

input ModelIntInput {
  ne: Int
  eq: Int
  le: Int
  lt: Int
  ge: Int
  gt: Int
  between: [Int]
  attributeExists: Boolean
  attributeType: ModelAttributeTypes
}

input ModelFloatInput {
  ne: Float
  eq: Float
  le: Float
  lt: Float
  ge: Float
  gt: Float
  between: [Float]
  attributeExists: Boolean
  attributeType: ModelAttributeTypes
}

input ModelBooleanInput {
  ne: Boolean
  eq: Boolean
  attributeExists: Boolean
  attributeType: ModelAttributeTypes
}

input ModelIDInput {
  ne: ID
  eq: ID
  le: ID
  lt: ID
  ge: ID
  gt: ID
  contains: ID
  notContains: ID
  between: [ID]
  beginsWith: ID
  attributeExists: Boolean
  attributeType: ModelAttributeTypes
  size: ModelSizeInput
}

enum ModelAttributeTypes {
  binary
  binarySet
  bool
  list
  map
  number
  numberSet
  string
  stringSet
  _null
}

input ModelSizeInput {
  ne: Int
  eq: Int
  le: Int
  lt: Int
  ge: Int
  gt: Int
  between: [Int]
}

enum ModelSortDirection {
  ASC
  DESC
}

type ModelPostConnection {
  items: [Post]!
  nextToken: String
}

input ModelPostFilterInput {
  id: ModelIDInput
  str: ModelStringInput
  createdAt: ModelIntInput
  updatedAt: ModelIntInput
  and: [ModelPostFilterInput]
  or: [ModelPostFilterInput]
  not: ModelPostFilterInput
}

type Query {
  getPost(id: ID!): Post
  listPosts(filter: ModelPostFilterInput, limit: Int, nextToken: String): ModelPostConnection
}

input ModelPostConditionInput {
  str: ModelStringInput
  createdAt: ModelIntInput
  updatedAt: ModelIntInput
  and: [ModelPostConditionInput]
  or: [ModelPostConditionInput]
  not: ModelPostConditionInput
}

input CreatePostInput {
  id: ID
  str: String
  createdAt: AWSTimestamp
  updatedAt: AWSTimestamp
}

input UpdatePostInput {
  id: ID!
  str: String
  createdAt: AWSTimestamp
  updatedAt: AWSTimestamp
}

input DeletePostInput {
  id: ID!
}

type Mutation {
  createPost(input: CreatePostInput!, condition: ModelPostConditionInput): Post
  updatePost(input: UpdatePostInput!, condition: ModelPostConditionInput): Post
  deletePost(input: DeletePostInput!, condition: ModelPostConditionInput): Post
}

type Subscription {
  onCreatePost: Post @aws_subscribe(mutations: [\\"createPost\\"])
  onUpdatePost: Post @aws_subscribe(mutations: [\\"updatePost\\"])
  onDeletePost: Post @aws_subscribe(mutations: [\\"deletePost\\"])
}

"
`;

exports[`ModelTransformer:  should not to auto generate createdAt and updatedAt when the type in schema is not AWSDateTime 2`] = `
"## [Start] Create Request template. **
#set( $args = $util.defaultIfNull($ctx.stash.transformedArgs, $ctx.args) )
## Set the default values to put request **
#set( $mergedValues = $util.defaultIfNull($ctx.stash.defaultValues, {}) )
## copy the values from input **
$util.qr($mergedValues.putAll($util.defaultIfNull($args.input, {})))
## set the typename **
$util.qr($mergedValues.put(\\"__typename\\", \\"Post\\"))
#set( $PutObject = {
  \\"version\\": \\"2018-05-29\\",
  \\"operation\\": \\"PutItem\\",
  \\"attributeValues\\":   $util.dynamodb.toMapValues($mergedValues),
  \\"condition\\": $condition
} )
#if( $args.condition )
  $util.qr($ctx.stash.conditions.add($args.condition))
#end
## Begin - key condition **
#if( $ctx.stash.metadata.modelObjectKey )
  #set( $keyConditionExpr = {} )
  #set( $keyConditionExprNames = {} )
  #foreach( $entry in $ctx.stash.metadata.modelObjectKey.entrySet() )
    $util.qr($keyConditionExpr.put(\\"keyCondition$velocityCount\\", {
  \\"attributeExists\\": false
}))
    $util.qr($keyConditionExprNames.put(\\"#keyCondition$velocityCount\\", \\"$entry.key\\"))
  #end
  $util.qr($ctx.stash.conditions.add($keyConditionExpr))
#else
  $util.qr($ctx.stash.conditions.add({
  \\"id\\": {
      \\"attributeExists\\": false
  }
}))
#end
## End - key condition **
## Start condition block **
#if( $ctx.stash.conditions && $ctx.stash.conditions.size() != 0 )
  #set( $mergedConditions = {
  \\"and\\": $ctx.stash.conditions
} )
  #set( $Conditions = $util.parseJson($util.transform.toDynamoDBConditionExpression($mergedConditions)) )
  #if( $Conditions.expressionValues && $Conditions.expressionValues.size() == 0 )
    #set( $Conditions = {
  \\"expression\\": $Conditions.expression,
  \\"expressionNames\\": $Conditions.expressionNames
} )
  #end
  ## End condition block **
#end
#if( $Conditions )
  #if( $keyConditionExprNames )
    $util.qr($Conditions.expressionNames.putAll($keyConditionExprNames))
  #end
  $util.qr($PutObject.put(\\"condition\\", $Conditions))
#end
#if( $ctx.stash.metadata.modelObjectKey )
  $util.qr($PutObject.put(\\"key\\", $ctx.stash.metadata.modelObjectKey))
#else
  #set( $Key = {
  \\"id\\":   $util.dynamodb.toDynamoDB($mergedValues.id)
} )
  $util.qr($PutObject.put(\\"key\\", $Key))
#end
$util.toJson($PutObject)
## [End] Create Request template. **"
`;

exports[`ModelTransformer:  should not to auto generate createdAt and updatedAt when the type in schema is not AWSDateTime 3`] = `
"## [Start] Mutation Update resolver. **
#set( $args = $util.defaultIfNull($ctx.stash.transformedArgs, $ctx.args) )
## Set the default values to put request **
#set( $mergedValues = $util.defaultIfNull($ctx.stash.defaultValues, {}) )
## copy the values from input **
$util.qr($mergedValues.putAll($util.defaultIfNull($args.input, {})))
## set the typename **
## Initialize the vars for creating ddb expression **
#set( $expNames = {} )
#set( $expValues = {} )
#set( $expSet = {} )
#set( $expAdd = {} )
#set( $expRemove = [] )
#if( $ctx.stash.metadata.modelObjectKey )
  #set( $Key = $ctx.stash.metadata.modelObjectKey )
#else
  #set( $Key = {
  \\"id\\":   $util.dynamodb.toDynamoDB($args.input.id)
} )
#end
## Model key **
#if( $ctx.stash.metadata.modelObjectKey )
  #set( $keyFields = [] )
  #foreach( $entry in $ctx.stash.metadata.modelObjectKey.entrySet() )
    $util.qr($keyFields.add(\\"$entry.key\\"))
  #end
#else
  #set( $keyFields = [\\"id\\"] )
#end
#foreach( $entry in $util.map.copyAndRemoveAllKeys($mergedValues, $keyFields).entrySet() )
  #if( !$util.isNull($ctx.stash.metadata.dynamodbNameOverrideMap) && $ctx.stash.metadata.dynamodbNameOverrideMap.containsKey(\\"$entry.key\\") )
    #set( $entryKeyAttributeName = $ctx.stash.metadata.dynamodbNameOverrideMap.get(\\"$entry.key\\") )
  #else
    #set( $entryKeyAttributeName = $entry.key )
  #end
  #if( $util.isNull($entry.value) )
    #set( $discard = $expRemove.add(\\"#$entryKeyAttributeName\\") )
    $util.qr($expNames.put(\\"#$entryKeyAttributeName\\", \\"$entry.key\\"))
  #else
    $util.qr($expSet.put(\\"#$entryKeyAttributeName\\", \\":$entryKeyAttributeName\\"))
    $util.qr($expNames.put(\\"#$entryKeyAttributeName\\", \\"$entry.key\\"))
    $util.qr($expValues.put(\\":$entryKeyAttributeName\\", $util.dynamodb.toDynamoDB($entry.value)))
  #end
#end
#set( $expression = \\"\\" )
#if( !$expSet.isEmpty() )
  #set( $expression = \\"SET\\" )
  #foreach( $entry in $expSet.entrySet() )
    #set( $expression = \\"$expression $entry.key = $entry.value\\" )
    #if( $foreach.hasNext() )
      #set( $expression = \\"$expression,\\" )
    #end
  #end
#end
#if( !$expAdd.isEmpty() )
  #set( $expression = \\"$expression ADD\\" )
  #foreach( $entry in $expAdd.entrySet() )
    #set( $expression = \\"$expression $entry.key $entry.value\\" )
    #if( $foreach.hasNext() )
      #set( $expression = \\"$expression,\\" )
    #end
  #end
#end
#if( !$expRemove.isEmpty() )
  #set( $expression = \\"$expression REMOVE\\" )
  #foreach( $entry in $expRemove )
    #set( $expression = \\"$expression $entry\\" )
    #if( $foreach.hasNext() )
      #set( $expression = \\"$expression,\\" )
    #end
  #end
#end
#set( $update = {} )
$util.qr($update.put(\\"expression\\", \\"$expression\\"))
#if( !$expNames.isEmpty() )
  $util.qr($update.put(\\"expressionNames\\", $expNames))
#end
#if( !$expValues.isEmpty() )
  $util.qr($update.put(\\"expressionValues\\", $expValues))
#end
## Begin - key condition **
#if( $ctx.stash.metadata.modelObjectKey )
  #set( $keyConditionExpr = {} )
  #set( $keyConditionExprNames = {} )
  #foreach( $entry in $ctx.stash.metadata.modelObjectKey.entrySet() )
    $util.qr($keyConditionExpr.put(\\"keyCondition$velocityCount\\", {
  \\"attributeExists\\": true
}))
    $util.qr($keyConditionExprNames.put(\\"#keyCondition$velocityCount\\", \\"$entry.key\\"))
  #end
  $util.qr($ctx.stash.conditions.add($keyConditionExpr))
#else
  $util.qr($ctx.stash.conditions.add({
  \\"id\\": {
      \\"attributeExists\\": true
  }
}))
#end
## End - key condition **
#if( $args.condition )
  $util.qr($ctx.stash.conditions.add($args.condition))
#end
## Start condition block **
#if( $ctx.stash.conditions && $ctx.stash.conditions.size() != 0 )
  #set( $mergedConditions = {
  \\"and\\": $ctx.stash.conditions
} )
  #set( $Conditions = $util.parseJson($util.transform.toDynamoDBConditionExpression($mergedConditions)) )
  #if( $Conditions.expressionValues && $Conditions.expressionValues.size() == 0 )
    #set( $Conditions = {
  \\"expression\\": $Conditions.expression,
  \\"expressionNames\\": $Conditions.expressionNames
} )
  #end
  ## End condition block **
#end
#set( $UpdateItem = {
  \\"version\\": \\"2018-05-29\\",
  \\"operation\\": \\"UpdateItem\\",
  \\"key\\": $Key,
  \\"update\\": $update
} )
#if( $Conditions )
  #if( $keyConditionExprNames )
    $util.qr($Conditions.expressionNames.putAll($keyConditionExprNames))
  #end
  $util.qr($UpdateItem.put(\\"condition\\", $Conditions))
#end
$util.toJson($UpdateItem)
## [End] Mutation Update resolver. **"
`;

exports[`ModelTransformer:  should not to include createdAt and updatedAt field when timestamps is set to null 1`] = `
"
type Post {
  id: ID!
  str: String
}

input ModelStringInput {
  ne: String
  eq: String
  le: String
  lt: String
  ge: String
  gt: String
  contains: String
  notContains: String
  between: [String]
  beginsWith: String
  attributeExists: Boolean
  attributeType: ModelAttributeTypes
  size: ModelSizeInput
}

input ModelIntInput {
  ne: Int
  eq: Int
  le: Int
  lt: Int
  ge: Int
  gt: Int
  between: [Int]
  attributeExists: Boolean
  attributeType: ModelAttributeTypes
}

input ModelFloatInput {
  ne: Float
  eq: Float
  le: Float
  lt: Float
  ge: Float
  gt: Float
  between: [Float]
  attributeExists: Boolean
  attributeType: ModelAttributeTypes
}

input ModelBooleanInput {
  ne: Boolean
  eq: Boolean
  attributeExists: Boolean
  attributeType: ModelAttributeTypes
}

input ModelIDInput {
  ne: ID
  eq: ID
  le: ID
  lt: ID
  ge: ID
  gt: ID
  contains: ID
  notContains: ID
  between: [ID]
  beginsWith: ID
  attributeExists: Boolean
  attributeType: ModelAttributeTypes
  size: ModelSizeInput
}

enum ModelAttributeTypes {
  binary
  binarySet
  bool
  list
  map
  number
  numberSet
  string
  stringSet
  _null
}

input ModelSizeInput {
  ne: Int
  eq: Int
  le: Int
  lt: Int
  ge: Int
  gt: Int
  between: [Int]
}

enum ModelSortDirection {
  ASC
  DESC
}

type ModelPostConnection {
  items: [Post]!
  nextToken: String
}

input ModelPostFilterInput {
  id: ModelIDInput
  str: ModelStringInput
  and: [ModelPostFilterInput]
  or: [ModelPostFilterInput]
  not: ModelPostFilterInput
}

type Query {
  getPost(id: ID!): Post
  listPosts(filter: ModelPostFilterInput, limit: Int, nextToken: String): ModelPostConnection
}

input ModelPostConditionInput {
  str: ModelStringInput
  and: [ModelPostConditionInput]
  or: [ModelPostConditionInput]
  not: ModelPostConditionInput
}

input CreatePostInput {
  id: ID
  str: String
}

input UpdatePostInput {
  id: ID!
  str: String
}

input DeletePostInput {
  id: ID!
}

type Mutation {
  createPost(input: CreatePostInput!, condition: ModelPostConditionInput): Post
  updatePost(input: UpdatePostInput!, condition: ModelPostConditionInput): Post
  deletePost(input: DeletePostInput!, condition: ModelPostConditionInput): Post
}

type Subscription {
  onCreatePost: Post @aws_subscribe(mutations: [\\"createPost\\"])
  onUpdatePost: Post @aws_subscribe(mutations: [\\"updatePost\\"])
  onDeletePost: Post @aws_subscribe(mutations: [\\"deletePost\\"])
}

"
`;

exports[`ModelTransformer:  should not to include createdAt and updatedAt field when timestamps is set to null 2`] = `
"## [Start] Create Request template. **
#set( $args = $util.defaultIfNull($ctx.stash.transformedArgs, $ctx.args) )
## Set the default values to put request **
#set( $mergedValues = $util.defaultIfNull($ctx.stash.defaultValues, {}) )
## copy the values from input **
$util.qr($mergedValues.putAll($util.defaultIfNull($args.input, {})))
## set the typename **
$util.qr($mergedValues.put(\\"__typename\\", \\"Post\\"))
#set( $PutObject = {
  \\"version\\": \\"2018-05-29\\",
  \\"operation\\": \\"PutItem\\",
  \\"attributeValues\\":   $util.dynamodb.toMapValues($mergedValues),
  \\"condition\\": $condition
} )
#if( $args.condition )
  $util.qr($ctx.stash.conditions.add($args.condition))
#end
## Begin - key condition **
#if( $ctx.stash.metadata.modelObjectKey )
  #set( $keyConditionExpr = {} )
  #set( $keyConditionExprNames = {} )
  #foreach( $entry in $ctx.stash.metadata.modelObjectKey.entrySet() )
    $util.qr($keyConditionExpr.put(\\"keyCondition$velocityCount\\", {
  \\"attributeExists\\": false
}))
    $util.qr($keyConditionExprNames.put(\\"#keyCondition$velocityCount\\", \\"$entry.key\\"))
  #end
  $util.qr($ctx.stash.conditions.add($keyConditionExpr))
#else
  $util.qr($ctx.stash.conditions.add({
  \\"id\\": {
      \\"attributeExists\\": false
  }
}))
#end
## End - key condition **
## Start condition block **
#if( $ctx.stash.conditions && $ctx.stash.conditions.size() != 0 )
  #set( $mergedConditions = {
  \\"and\\": $ctx.stash.conditions
} )
  #set( $Conditions = $util.parseJson($util.transform.toDynamoDBConditionExpression($mergedConditions)) )
  #if( $Conditions.expressionValues && $Conditions.expressionValues.size() == 0 )
    #set( $Conditions = {
  \\"expression\\": $Conditions.expression,
  \\"expressionNames\\": $Conditions.expressionNames
} )
  #end
  ## End condition block **
#end
#if( $Conditions )
  #if( $keyConditionExprNames )
    $util.qr($Conditions.expressionNames.putAll($keyConditionExprNames))
  #end
  $util.qr($PutObject.put(\\"condition\\", $Conditions))
#end
#if( $ctx.stash.metadata.modelObjectKey )
  $util.qr($PutObject.put(\\"key\\", $ctx.stash.metadata.modelObjectKey))
#else
  #set( $Key = {
  \\"id\\":   $util.dynamodb.toDynamoDB($mergedValues.id)
} )
  $util.qr($PutObject.put(\\"key\\", $Key))
#end
$util.toJson($PutObject)
## [End] Create Request template. **"
`;

exports[`ModelTransformer:  should not to include createdAt and updatedAt field when timestamps is set to null 3`] = `
"## [Start] Mutation Update resolver. **
#set( $args = $util.defaultIfNull($ctx.stash.transformedArgs, $ctx.args) )
## Set the default values to put request **
#set( $mergedValues = $util.defaultIfNull($ctx.stash.defaultValues, {}) )
## copy the values from input **
$util.qr($mergedValues.putAll($util.defaultIfNull($args.input, {})))
## set the typename **
## Initialize the vars for creating ddb expression **
#set( $expNames = {} )
#set( $expValues = {} )
#set( $expSet = {} )
#set( $expAdd = {} )
#set( $expRemove = [] )
#if( $ctx.stash.metadata.modelObjectKey )
  #set( $Key = $ctx.stash.metadata.modelObjectKey )
#else
  #set( $Key = {
  \\"id\\":   $util.dynamodb.toDynamoDB($args.input.id)
} )
#end
## Model key **
#if( $ctx.stash.metadata.modelObjectKey )
  #set( $keyFields = [] )
  #foreach( $entry in $ctx.stash.metadata.modelObjectKey.entrySet() )
    $util.qr($keyFields.add(\\"$entry.key\\"))
  #end
#else
  #set( $keyFields = [\\"id\\"] )
#end
#foreach( $entry in $util.map.copyAndRemoveAllKeys($mergedValues, $keyFields).entrySet() )
  #if( !$util.isNull($ctx.stash.metadata.dynamodbNameOverrideMap) && $ctx.stash.metadata.dynamodbNameOverrideMap.containsKey(\\"$entry.key\\") )
    #set( $entryKeyAttributeName = $ctx.stash.metadata.dynamodbNameOverrideMap.get(\\"$entry.key\\") )
  #else
    #set( $entryKeyAttributeName = $entry.key )
  #end
  #if( $util.isNull($entry.value) )
    #set( $discard = $expRemove.add(\\"#$entryKeyAttributeName\\") )
    $util.qr($expNames.put(\\"#$entryKeyAttributeName\\", \\"$entry.key\\"))
  #else
    $util.qr($expSet.put(\\"#$entryKeyAttributeName\\", \\":$entryKeyAttributeName\\"))
    $util.qr($expNames.put(\\"#$entryKeyAttributeName\\", \\"$entry.key\\"))
    $util.qr($expValues.put(\\":$entryKeyAttributeName\\", $util.dynamodb.toDynamoDB($entry.value)))
  #end
#end
#set( $expression = \\"\\" )
#if( !$expSet.isEmpty() )
  #set( $expression = \\"SET\\" )
  #foreach( $entry in $expSet.entrySet() )
    #set( $expression = \\"$expression $entry.key = $entry.value\\" )
    #if( $foreach.hasNext() )
      #set( $expression = \\"$expression,\\" )
    #end
  #end
#end
#if( !$expAdd.isEmpty() )
  #set( $expression = \\"$expression ADD\\" )
  #foreach( $entry in $expAdd.entrySet() )
    #set( $expression = \\"$expression $entry.key $entry.value\\" )
    #if( $foreach.hasNext() )
      #set( $expression = \\"$expression,\\" )
    #end
  #end
#end
#if( !$expRemove.isEmpty() )
  #set( $expression = \\"$expression REMOVE\\" )
  #foreach( $entry in $expRemove )
    #set( $expression = \\"$expression $entry\\" )
    #if( $foreach.hasNext() )
      #set( $expression = \\"$expression,\\" )
    #end
  #end
#end
#set( $update = {} )
$util.qr($update.put(\\"expression\\", \\"$expression\\"))
#if( !$expNames.isEmpty() )
  $util.qr($update.put(\\"expressionNames\\", $expNames))
#end
#if( !$expValues.isEmpty() )
  $util.qr($update.put(\\"expressionValues\\", $expValues))
#end
## Begin - key condition **
#if( $ctx.stash.metadata.modelObjectKey )
  #set( $keyConditionExpr = {} )
  #set( $keyConditionExprNames = {} )
  #foreach( $entry in $ctx.stash.metadata.modelObjectKey.entrySet() )
    $util.qr($keyConditionExpr.put(\\"keyCondition$velocityCount\\", {
  \\"attributeExists\\": true
}))
    $util.qr($keyConditionExprNames.put(\\"#keyCondition$velocityCount\\", \\"$entry.key\\"))
  #end
  $util.qr($ctx.stash.conditions.add($keyConditionExpr))
#else
  $util.qr($ctx.stash.conditions.add({
  \\"id\\": {
      \\"attributeExists\\": true
  }
}))
#end
## End - key condition **
#if( $args.condition )
  $util.qr($ctx.stash.conditions.add($args.condition))
#end
## Start condition block **
#if( $ctx.stash.conditions && $ctx.stash.conditions.size() != 0 )
  #set( $mergedConditions = {
  \\"and\\": $ctx.stash.conditions
} )
  #set( $Conditions = $util.parseJson($util.transform.toDynamoDBConditionExpression($mergedConditions)) )
  #if( $Conditions.expressionValues && $Conditions.expressionValues.size() == 0 )
    #set( $Conditions = {
  \\"expression\\": $Conditions.expression,
  \\"expressionNames\\": $Conditions.expressionNames
} )
  #end
  ## End condition block **
#end
#set( $UpdateItem = {
  \\"version\\": \\"2018-05-29\\",
  \\"operation\\": \\"UpdateItem\\",
  \\"key\\": $Key,
  \\"update\\": $update
} )
#if( $Conditions )
  #if( $keyConditionExprNames )
    $util.qr($Conditions.expressionNames.putAll($keyConditionExprNames))
  #end
  $util.qr($UpdateItem.put(\\"condition\\", $Conditions))
#end
$util.toJson($UpdateItem)
## [End] Mutation Update resolver. **"
`;

exports[`ModelTransformer:  should support timestamp parameters when generating resolvers and output schema 1`] = `
"
type Post {
  id: ID!
  str: String
  createdOn: AWSDateTime!
  updatedOn: AWSDateTime!
}

input ModelStringInput {
  ne: String
  eq: String
  le: String
  lt: String
  ge: String
  gt: String
  contains: String
  notContains: String
  between: [String]
  beginsWith: String
  attributeExists: Boolean
  attributeType: ModelAttributeTypes
  size: ModelSizeInput
}

input ModelIntInput {
  ne: Int
  eq: Int
  le: Int
  lt: Int
  ge: Int
  gt: Int
  between: [Int]
  attributeExists: Boolean
  attributeType: ModelAttributeTypes
}

input ModelFloatInput {
  ne: Float
  eq: Float
  le: Float
  lt: Float
  ge: Float
  gt: Float
  between: [Float]
  attributeExists: Boolean
  attributeType: ModelAttributeTypes
}

input ModelBooleanInput {
  ne: Boolean
  eq: Boolean
  attributeExists: Boolean
  attributeType: ModelAttributeTypes
}

input ModelIDInput {
  ne: ID
  eq: ID
  le: ID
  lt: ID
  ge: ID
  gt: ID
  contains: ID
  notContains: ID
  between: [ID]
  beginsWith: ID
  attributeExists: Boolean
  attributeType: ModelAttributeTypes
  size: ModelSizeInput
}

enum ModelAttributeTypes {
  binary
  binarySet
  bool
  list
  map
  number
  numberSet
  string
  stringSet
  _null
}

input ModelSizeInput {
  ne: Int
  eq: Int
  le: Int
  lt: Int
  ge: Int
  gt: Int
  between: [Int]
}

enum ModelSortDirection {
  ASC
  DESC
}

type ModelPostConnection {
  items: [Post]!
  nextToken: String
}

input ModelPostFilterInput {
  id: ModelIDInput
  str: ModelStringInput
  and: [ModelPostFilterInput]
  or: [ModelPostFilterInput]
  not: ModelPostFilterInput
}

type Query {
  getPost(id: ID!): Post
  listPosts(filter: ModelPostFilterInput, limit: Int, nextToken: String): ModelPostConnection
}

input ModelPostConditionInput {
  str: ModelStringInput
  and: [ModelPostConditionInput]
  or: [ModelPostConditionInput]
  not: ModelPostConditionInput
}

input CreatePostInput {
  id: ID
  str: String
}

input UpdatePostInput {
  id: ID!
  str: String
}

input DeletePostInput {
  id: ID!
}

type Mutation {
  createPost(input: CreatePostInput!, condition: ModelPostConditionInput): Post
  updatePost(input: UpdatePostInput!, condition: ModelPostConditionInput): Post
  deletePost(input: DeletePostInput!, condition: ModelPostConditionInput): Post
}

type Subscription {
  onCreatePost: Post @aws_subscribe(mutations: [\\"createPost\\"])
  onUpdatePost: Post @aws_subscribe(mutations: [\\"updatePost\\"])
  onDeletePost: Post @aws_subscribe(mutations: [\\"deletePost\\"])
}

"
`;

exports[`ModelTransformer:  should support timestamp parameters when generating resolvers and output schema 2`] = `
"## [Start] Create Request template. **
#set( $args = $util.defaultIfNull($ctx.stash.transformedArgs, $ctx.args) )
## Set the default values to put request **
#set( $mergedValues = $util.defaultIfNull($ctx.stash.defaultValues, {}) )
## copy the values from input **
$util.qr($mergedValues.putAll($util.defaultIfNull($args.input, {})))
## set the typename **
$util.qr($mergedValues.put(\\"__typename\\", \\"Post\\"))
#set( $PutObject = {
  \\"version\\": \\"2018-05-29\\",
  \\"operation\\": \\"PutItem\\",
  \\"attributeValues\\":   $util.dynamodb.toMapValues($mergedValues),
  \\"condition\\": $condition
} )
#if( $args.condition )
  $util.qr($ctx.stash.conditions.add($args.condition))
#end
## Begin - key condition **
#if( $ctx.stash.metadata.modelObjectKey )
  #set( $keyConditionExpr = {} )
  #set( $keyConditionExprNames = {} )
  #foreach( $entry in $ctx.stash.metadata.modelObjectKey.entrySet() )
    $util.qr($keyConditionExpr.put(\\"keyCondition$velocityCount\\", {
  \\"attributeExists\\": false
}))
    $util.qr($keyConditionExprNames.put(\\"#keyCondition$velocityCount\\", \\"$entry.key\\"))
  #end
  $util.qr($ctx.stash.conditions.add($keyConditionExpr))
#else
  $util.qr($ctx.stash.conditions.add({
  \\"id\\": {
      \\"attributeExists\\": false
  }
}))
#end
## End - key condition **
## Start condition block **
#if( $ctx.stash.conditions && $ctx.stash.conditions.size() != 0 )
  #set( $mergedConditions = {
  \\"and\\": $ctx.stash.conditions
} )
  #set( $Conditions = $util.parseJson($util.transform.toDynamoDBConditionExpression($mergedConditions)) )
  #if( $Conditions.expressionValues && $Conditions.expressionValues.size() == 0 )
    #set( $Conditions = {
  \\"expression\\": $Conditions.expression,
  \\"expressionNames\\": $Conditions.expressionNames
} )
  #end
  ## End condition block **
#end
#if( $Conditions )
  #if( $keyConditionExprNames )
    $util.qr($Conditions.expressionNames.putAll($keyConditionExprNames))
  #end
  $util.qr($PutObject.put(\\"condition\\", $Conditions))
#end
#if( $ctx.stash.metadata.modelObjectKey )
  $util.qr($PutObject.put(\\"key\\", $ctx.stash.metadata.modelObjectKey))
#else
  #set( $Key = {
  \\"id\\":   $util.dynamodb.toDynamoDB($mergedValues.id)
} )
  $util.qr($PutObject.put(\\"key\\", $Key))
#end
$util.toJson($PutObject)
## [End] Create Request template. **"
`;

exports[`ModelTransformer:  should support timestamp parameters when generating resolvers and output schema 3`] = `
"## [Start] Mutation Update resolver. **
#set( $args = $util.defaultIfNull($ctx.stash.transformedArgs, $ctx.args) )
## Set the default values to put request **
#set( $mergedValues = $util.defaultIfNull($ctx.stash.defaultValues, {}) )
## copy the values from input **
$util.qr($mergedValues.putAll($util.defaultIfNull($args.input, {})))
## set the typename **
## Initialize the vars for creating ddb expression **
#set( $expNames = {} )
#set( $expValues = {} )
#set( $expSet = {} )
#set( $expAdd = {} )
#set( $expRemove = [] )
#if( $ctx.stash.metadata.modelObjectKey )
  #set( $Key = $ctx.stash.metadata.modelObjectKey )
#else
  #set( $Key = {
  \\"id\\":   $util.dynamodb.toDynamoDB($args.input.id)
} )
#end
## Model key **
#if( $ctx.stash.metadata.modelObjectKey )
  #set( $keyFields = [] )
  #foreach( $entry in $ctx.stash.metadata.modelObjectKey.entrySet() )
    $util.qr($keyFields.add(\\"$entry.key\\"))
  #end
#else
  #set( $keyFields = [\\"id\\"] )
#end
#foreach( $entry in $util.map.copyAndRemoveAllKeys($mergedValues, $keyFields).entrySet() )
  #if( !$util.isNull($ctx.stash.metadata.dynamodbNameOverrideMap) && $ctx.stash.metadata.dynamodbNameOverrideMap.containsKey(\\"$entry.key\\") )
    #set( $entryKeyAttributeName = $ctx.stash.metadata.dynamodbNameOverrideMap.get(\\"$entry.key\\") )
  #else
    #set( $entryKeyAttributeName = $entry.key )
  #end
  #if( $util.isNull($entry.value) )
    #set( $discard = $expRemove.add(\\"#$entryKeyAttributeName\\") )
    $util.qr($expNames.put(\\"#$entryKeyAttributeName\\", \\"$entry.key\\"))
  #else
    $util.qr($expSet.put(\\"#$entryKeyAttributeName\\", \\":$entryKeyAttributeName\\"))
    $util.qr($expNames.put(\\"#$entryKeyAttributeName\\", \\"$entry.key\\"))
    $util.qr($expValues.put(\\":$entryKeyAttributeName\\", $util.dynamodb.toDynamoDB($entry.value)))
  #end
#end
#set( $expression = \\"\\" )
#if( !$expSet.isEmpty() )
  #set( $expression = \\"SET\\" )
  #foreach( $entry in $expSet.entrySet() )
    #set( $expression = \\"$expression $entry.key = $entry.value\\" )
    #if( $foreach.hasNext() )
      #set( $expression = \\"$expression,\\" )
    #end
  #end
#end
#if( !$expAdd.isEmpty() )
  #set( $expression = \\"$expression ADD\\" )
  #foreach( $entry in $expAdd.entrySet() )
    #set( $expression = \\"$expression $entry.key $entry.value\\" )
    #if( $foreach.hasNext() )
      #set( $expression = \\"$expression,\\" )
    #end
  #end
#end
#if( !$expRemove.isEmpty() )
  #set( $expression = \\"$expression REMOVE\\" )
  #foreach( $entry in $expRemove )
    #set( $expression = \\"$expression $entry\\" )
    #if( $foreach.hasNext() )
      #set( $expression = \\"$expression,\\" )
    #end
  #end
#end
#set( $update = {} )
$util.qr($update.put(\\"expression\\", \\"$expression\\"))
#if( !$expNames.isEmpty() )
  $util.qr($update.put(\\"expressionNames\\", $expNames))
#end
#if( !$expValues.isEmpty() )
  $util.qr($update.put(\\"expressionValues\\", $expValues))
#end
## Begin - key condition **
#if( $ctx.stash.metadata.modelObjectKey )
  #set( $keyConditionExpr = {} )
  #set( $keyConditionExprNames = {} )
  #foreach( $entry in $ctx.stash.metadata.modelObjectKey.entrySet() )
    $util.qr($keyConditionExpr.put(\\"keyCondition$velocityCount\\", {
  \\"attributeExists\\": true
}))
    $util.qr($keyConditionExprNames.put(\\"#keyCondition$velocityCount\\", \\"$entry.key\\"))
  #end
  $util.qr($ctx.stash.conditions.add($keyConditionExpr))
#else
  $util.qr($ctx.stash.conditions.add({
  \\"id\\": {
      \\"attributeExists\\": true
  }
}))
#end
## End - key condition **
#if( $args.condition )
  $util.qr($ctx.stash.conditions.add($args.condition))
#end
## Start condition block **
#if( $ctx.stash.conditions && $ctx.stash.conditions.size() != 0 )
  #set( $mergedConditions = {
  \\"and\\": $ctx.stash.conditions
} )
  #set( $Conditions = $util.parseJson($util.transform.toDynamoDBConditionExpression($mergedConditions)) )
  #if( $Conditions.expressionValues && $Conditions.expressionValues.size() == 0 )
    #set( $Conditions = {
  \\"expression\\": $Conditions.expression,
  \\"expressionNames\\": $Conditions.expressionNames
} )
  #end
  ## End condition block **
#end
#set( $UpdateItem = {
  \\"version\\": \\"2018-05-29\\",
  \\"operation\\": \\"UpdateItem\\",
  \\"key\\": $Key,
  \\"update\\": $update
} )
#if( $Conditions )
  #if( $keyConditionExprNames )
    $util.qr($Conditions.expressionNames.putAll($keyConditionExprNames))
  #end
  $util.qr($UpdateItem.put(\\"condition\\", $Conditions))
#end
$util.toJson($UpdateItem)
## [End] Mutation Update resolver. **"
`;

exports[`ModelTransformer:  the datastore table should be configured 1`] = `
"## [Start] Sync Request template. **
#set( $args = $util.defaultIfNull($ctx.stash.transformedArgs, $ctx.args) )
#if( !$util.isNullOrEmpty($ctx.stash.authFilter) )
  #set( $filter = $ctx.stash.authFilter )
  #if( !$util.isNullOrEmpty($args.filter) )
    #set( $filter = {
  \\"and\\":   [$filter, $args.filter]
} )
  #end
#else
  #if( !$util.isNullOrEmpty($args.filter) )
    #set( $filter = $args.filter )
  #end
#end
#if( !$util.isNullOrEmpty($filter) )
  #set( $filterExpression = $util.parseJson($util.transform.toDynamoDBFilterExpression($filter)) )
  #if( !$util.isNullOrBlank($filterExpression.expression) )
    #if( $filterExpression.expressionValues.size() == 0 )
      $util.qr($filterExpression.remove(\\"expressionValues\\"))
    #end
    #set( $filter = $filterExpression )
  #end
#end
{
  \\"version\\": \\"2018-05-29\\",
  \\"operation\\": \\"Sync\\",
  \\"filter\\":   #if( $filter )
$util.toJson($filter)
  #else
null
  #end,
  \\"limit\\": $util.defaultIfNull($args.limit, 100),
  \\"lastSync\\": $util.toJson($util.defaultIfNull($args.lastSync, null)),
  \\"nextToken\\": $util.toJson($util.defaultIfNull($args.nextToken, null))
}
## [End] Sync Request template. **"
`;

exports[`ModelTransformer:  the datastore table should be configured 2`] = `
"## [Start] ResponseTemplate. **
#if( $ctx.error )
  $util.error($ctx.error.message, $ctx.error.type, $ctx.result)
#else
  $util.toJson($ctx.result)
#end
## [End] ResponseTemplate. **"
`;
